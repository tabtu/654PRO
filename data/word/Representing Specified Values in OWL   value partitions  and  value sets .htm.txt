representing specified values in owl value partitions and value sets representing specified values in owl value partitions and value sets w3c working group note 17 may 2005 this version http www.w3.org tr 2005 note-swbp-specified-values-20050517 latest version http www.w3.org tr swbp-specified-values previous version http www.w3.org tr 2004 wd-swbp-specified-values-20040803 editors alan rector university of manchester copyright 2005 w3c mit ercim keio all rights reserved. w3c liability trademark document use rules apply. abstract modelling various descriptive features also known variously as qualities attributes or modifiers is a frequent requirement when creating ontologies. for example size may describe persons or other physical objects and be constrained to take the values small medium or large rank may describe military officers and restricted to a specific list of values depending on the military organisation. in owl such descriptive features are modelled as properties whose range specifies the constraints on the values that the property can take on. this document describes two methods to represent such features and their specified values 1 as partitions of classes and 2 as enumerations of individuals. it does not discuss the use of datatypes to represent lists of values. status of this document this section describes the status of this document at the time of its publication. other documents may supersede this document. a list of current w3c publications and the latest revision of this technical report can be found in the w3c technical reports index at http www.w3.org tr this document is a working group note produced by the ontology engineering and patterns task force in the semantic web best practices and deployment working group part of the w3c semantic web activity. this document is one of a series of documents that is produced by the task force. comments on this document may be sent to public-swbp-wg@w3.org a mailing list with a public archive. publication as a working group note does not imply endorsement by the w3c membership. this is a draft document and may be updated replaced or obsoleted by other documents at any time. it is inappropriate to cite this document as other than work in progress. general issue it is a common requirement in developing ontologies to be able to represent notions such as a small man a high ranking officer or a health person. there are many such features also known as qualities attributes or modifiers in almost all such cases it is necessary to specify the constraints on the values for the feature e.g. that size may be small medium or large or that a person may be in poor health medium health or good health in some circumstances we may also want to represent modified values e.g. very large moderately large etc. or to otherwise further subdivide the original values. in other circumstances it is useful to be able to have two different collections of values covering the same feature for example to have different collections of color values all partitioning the same colour space or to break up health status into four rather than three levels. there are at least three different ways to represent such specified collections of values as individuals whose enumeration makes up the parent class representing the feature see pattern 1 as disjoint classes which exhaustively partition the parent class representing the feature. see pattern 2 as datatypes. data types will more usually be used when there is a literal numeric or derived data types rather than when there is an enumerated list of values. datatypes will not be considered further in this note because technical discussions are still continuing in other w3c committees. a supplement may be issued later when these issues are resolved. use case examples we want to describe persons as having qualities such as having size that is small medium or large body type that is slender medium or obese and as having health status that is good health medium health or poor health. it should not be possible to have more than one value for any of the qualities e.g. it should be inconsistent unsatisfiable to be both slender and obese or in good health and poor health. we will use the feature health in the examples. the others follow analogously. conventions used in this note diagramming the diagramming conventions used in this document are summarised below. examples are given in the appendix. ellipses represent classes. squares represent instances. arrows closed undecorated arrows pointing upwards if possible represent rdfs subclassof open undecorated arrows indicate rdf type arrows decorated with a blob on the origin indicate restrictions if between classes or facts if between individuals. dotted arrows indicate that the information represented is inferrable by a reasoner and not present explicitly in the code given. upward facing square union symbols if spanning a set of rdfs subclassof arrowsor rdf type arrowsindicate that the subclasses or individuals exhaust the class i.e. that they cover all possibilities. this is expressed in owl using owl unionof for classes or owl oneof for individuals downwards facing braces are used to indicate pairwise disjointness between subclasses or owl alldifferent for individuals. all sibling classes are disjoint and all individuals of each type are different in these examples. syntax for code in keeping with swbp policy the syntax within the body of note is n3. details in alternative syntaxes are given by links. vocabulary partition a class is partitioned by a group of subclasses if a the subclasses are mutually exclusive i.e. pairwise disjoint and b the subclasses completely cover the parent class i.e. that the union of the subclasses is equal to the parent class. feature a characteristic of some entity. other words for feature include quality welty and guarino attribute characteristic and modifier for purposes of this note no distinction will be made between these terms. for further information on representing more complex qualities see the note on n-ary relations. feature space the range of values that a feature can take on conceived of as a continuous range or space also called quality space see welty and guarino representation patterns two patterns are introduced. the first is simple and intuitive but has limitations. the second is more complex but is more flexible. some classifiers also work more reliably with pattern 2 than pattern 1. pattern 1 values as sets of individuals in this approach the class health_value is considered as the enumeration of the individuals good_health medium_health and poor_health. values are sets of individuals. to say that john is is in good health is to say that john has the value good_health for health_status this assumes that a value is just a unique symbol and a value set is just a a set of such symbols. normally the values will all need to be asserted to be different from each other. in owl any two individuals might represent the same thing unless there is an axiom to say explicitly that they are different. in other words owl does not make the unique names assumption if we did not include the differentfrom axiom in the example then it would be possible that good_health and poor_health where the same thing so that it would be possible to have a person who was both in good health and poor health simultaneously. the approach is shown diagrammatically in figure 1. figure 1 a class-instance diagram of the use of enumerated instances to represent lists of values representation for pattern 1 the value set and make it equal to the enumeration of the three individual values health_value a owl class owl equivalentclass a owl class define as one of three individuals owl oneof medium_health good_health poor_health good_health a health_value the next line make values different. otherwise might be inferred the same owl differentfrom poor_health medium_health define each of the individual values as an individual of type health_value medium_health a health_value owl differentfrom poor_health good_health poor_health a health_value owl differentfrom good_health medium_health has_health_status a owl objectproperty owl functionalproperty rdfs range health_value define the individual john and state that he has health_status good_health john a person has_health_status good_health define the class healthy_person as the class of person that has health_status good_health i.e. an individual of type person and has_health_status value good_health healthy_person a owl class owl equivalentclass a owl class owl intersectionof person a owl restriction owl hasvalue good_health owl onproperty has_health_status considerations using pattern 1 there is a straight forward match to the usage in databases and many frame systems without any assumptions or conventions about anonymous individuals. many people find this the more intuitive approach. there is no possibility of further subpartitioning of values. this is because owl supports only equality or difference between individuals. it does not allow individuals to have partial overlaps. it is not possible as it is for classes to say that one individual is equivalent to the the union disjunction of two other individuals. there is no way to represent alternative partitionings of the same feature space. because individuals cannot overlap if health_value is defined as equivalent to enumeration of one list of distinct values it cannot also be equivalent to a different list of distinct values. to do so would cause the reasoner to indicate a contradiction. i.e that health_value was unsatisfiable the representation is in owl-dl and dl reasoners should eventually be expected to make correct inferences with individuals used in this way. however neither fact nor racer the two most widespread open source reasoners in use today perform all the expected inferences reliably. owl code for this example n3 rdf xml abbrev abstract syntax pattern 2 values as subclasses partitioning a feature in this approach we consider the feature as a class representing a continuous space that is partitioned by the values in the collection of values. to say that john is in good health is to say that his health is inside the good_health_values partition of the health_value feature. theoretically there is an individual health value johns_health but all we know about it is that it lies someplace in the good_health_value partition. the cass healthy_person is the class of all those persons who have a health in the good_health_value partition. figure 2 a class-instance diagram of the use of partitioning classes for collections of values some may find an alternative diagrammatic format adapted from venn diagrams as shown in figure 3 makes the intention clearer as it shows the partioning more explicitly. figure 3 an adapted venn diagram showing the use of partitioning classes to represent lists of values. representation for two variants of pattern 2 there are two variants presented one in which the individual johns_health is explicitly represented the other in which it is implied by an existential restriction. representation variant 1 using a fact about the individual define the parent value class to be partitioned health_value a owl class owl equivalentclass a owl class the next line makes the partition exhaustive owl unionof poor_health_value medium_health_value good_health_value define each of the subclasses that make up the partitioon and make them pairwise disjoint good_health_value a owl class rdfs subclassof health_value the disjoint axioms make the subclasses partitioning owl disjointwith poor_health_value medium_health_value medium_health_value a owl class rdfs subclassof health_value owl disjointwith poor_health_value good_health_value poor_health_value a owl class rdfs subclassof health_value owl disjointwith good_health_value medium_health_value define the functional property has_health_status with domain person and range health_value has_health_status the property must be functional a owl objectproperty owl functionalproperty rdfs domain person domain is optional and might be broader rdfs range health_value range is constrained to be health_value and is mandatory for the pattern define the class person its subclass healthy_person person a owl class. define healthy_person a healthy_person is anything that is both a person and whose health status is in the good_health_value subclass of health_value healthy_person a owl class owl equivalentclass a owl class owl intersectionof person a owl restriction owl onproperty has_health_status owl somevaluesfrom good_health_value define john as an individual of type person and state that he has a health status johns_health john a person has_health_status johns_health define the individual johns_health as a good_health_value johns_health a good_health_value representation using variant 2 placing an existential restriction on the individual it is not actually necessary to create the individual johns_health explicitly. instead it is possible to use an existential restriction to imply its existence but leave it anonymous. in figure 3 below this is shown by preceding the name with an underscore and showing the box in dotted lines. figure 4 pattern 2 variant 2 with an anonymous individual for john s health to understand how this is done formally remember that restrictions in owl are formally just another type of class so to add a restriction to an individual you make the individual a type of the restriction. so john is not only of of type person but also of type restriction has_health_status somevaluesfrom goodhealthstatus or in n3 syntax define john as an individual of type person and of type has_health_status somevaluesfrom good_health_status john a person a owl restriction owl onproperty has_health_status owl somevaluesfrom good_health_value considerations using pattern 2 the result is in owl-dl and classifies correctly using either fact or racer and almost certainly any other reasoner that handles any reasonable subset of owl-dl.the semantics faithfully represent the partitioning of a continuous feature space into a collection of discrete value. the values can be further subpartitioned e.g. good_health_value might be split into moderately_good_health_value and robust_good_health_value simply by subdividing the good_health_value partition. there can be several alternative partitionings of the same feature space. if variant 2 is to be used as part of a database schema or similar then a convention for creating anonymous instances in the database is required. logicians call such anonymous instances skolem constants in practice this can usually be ignored. a common convention is to use the class name or a string derived from it e.g. good_health as the symbol in the database. the fact that strictly speaking the semantics require the symbol to be interpreted in each case as a different anonymous instance of the class good_health_value will be irrelevant to most applications and invisible to most users. a problem only arises if the database is to be re-interpreted in owl in which case either variant 1 or variant 2 must be chosen and the necessary anonymous variables or restrictions constructed for each occurrence of the value in the database. the use of classes for values seems unintuitive to many people who come from the database and frame communities where value sets are usually enumerated lists of symbols. code for this example n3 rdf xml abbrev abstract syntax additional considerations we would advise against mixing pattern 1 and pattern 2 in the same ontology because it becomes difficult for authors to remember when to use one and when the other. maintaining a consistent style is almost always to be preferred. in this note we have maintained the naming conventions that classes begin with upper case letters and included the suffix value on the subclasses that make up value partitions. creating a group of pairwise disjoint classes requires combinatorially many disjoint axioms i.e. it requires one axiom for every pair of pairwise disjoint classes. this does not happen with individuals because the owl standard provides an alldifferent axiom. unfortunately it does not provide an analogous allldisjoint axiom. tools that implement owl literally will encounter this problem and owl files implemented literally may grow very large very quickly. there is a known work around that will be covered in a supplementary note and is being implemented in some tools. acknowledgements the code in these examples should be viewable with any owl tools. the following is for information only and with thanks to those involved in developing the tools. there is no endorsement intended or implied for the specific tools. these examples have been produced using the protege owl plugin and co-ode additional wizards and owlviz available from http protege.stanford.edu and following plugins backends owl. some files may require the co-ode plugins linked to that page or at http www.co-ode.org. classification involving individuals cannot all be shown in this form and has been tested using oiled available from http oiled.man.ac.uk. in all cases the racer classifier has been used available from http www.sts.tu-harburg.de r.f.moeller racer special thanks to matthew horridge for help with the final drawings to pat hayes for help with draft diagrams and to mike uschold for detailed reviews. references rector a. modularisation of domain ontologies implemented in description logics and related formalisms including owl. in knowledge capture 2003 sanibel island fl 2003 acm 121-128. pdf here welty c. and guarino n. supporting ontological uow.acc.tab.analysis of taxonomic relationships. data and knowledge engineering 39 1 51-74. pdf here appendix diagramming conventions ellipses represent classes e.g. squares represent instances. e.g. john arrows closed undecorated arrows pointing upwards if possible represent rdfs subclassof open undecorated arrows indicate rdf type arrows decorated with a blob on the origin indicate restrictions if between classes or facts if between individuals. dotted arrows indicate that the information represented is inferrable by a reasoner and not present explicitly in the code given. upward facing square union symbols if spanning a set of rdfs subclassof arrowsor rdf type arrowsindicate that the subclasses or individuals exhaust the class i.e. that they cover all possibilities. this is expressed in owl using owl unionof for classes or owl oneof for individuals downwards facing braces are used to indicate pairwise disjointness between subclasses or owl alldifferent for individuals. all sibling classes are disjoint and all individuals of each type are different in these examples. 