xml schema datatypes in rdf and owl xml schema datatypes in rdf and owl w3c working group note 14 march 2006 this version http www.w3.org tr 2006 note-swbp-xsch-datatypes-20060314 latest version http www.w3.org tr swbp-xsch-datatypes previous version http www.w3.org tr 2005 wd-swbp-xsch-datatypes-20050427 editors jeremy j. carroll hp lab jeff z. pan university of aberdeen copyright 2006 w3c mit ercim keio all rights reserved. w3c liability trademark and document use rules apply. abstract the rdf and owl recommendations use the simple types from xml schema. this document addresses three questions left unanswered by these recommendations which uriref should be used to refer to a user defined datatype which values of which xml schema simple types are the same how to use the problematic xsd duration in rdf and owl in addition we further describe how to integrate owl dl with user defined datatypes in appendix b status of this document this section describes the status of this document at the time of its publication. other documents may supersede this document. a list of current w3c publications and the latest revision of this technical report can be found in the w3c technical reports index at http www.w3.org tr this document is a working group note produced by the semantic web best practices and deployment working group part of the w3c semantic web activity. as of the publication of this working group note the swbpd working group has completed work on this document. changes from the previous working draft are summarized in appendix c. comments on this document may be sent to public-swbp-wg@w3.org a mailing list with a public archive. further discussion on this material may be sent to the semantic web interest group mailing list semantic-web@w3.org also with a public archive. this document was produced by a group operating under the 5 february 2004 w3c patent policy. this document is informative only. w3c has a public list of any patent disclosures made in connection with the deliverables of the group that page also includes instructions for disclosing a patent. publication as a working group note does not imply endorsement by the w3c membership. this is a draft document and may be updated replaced or obsoleted by other documents at any time. it is inappropriate to cite this document as other than work in progress. table of contents 1. introduction 1.1 reading this document 1.2 namespaces used in this document 1.3 xml schema simple types 2. user defined datatypes 2.1 problem statement 2.2 component designators solution 2.3 using the id attribute 2.4 suggested practice 3. comparison of values 3.1 problem statement 3.2 all primitive types differ 3.3 formal analysis 3.4 examples 3.5 using sparql for equality 3.6 value approximate mapping 4. duration 5. the use of numeric types 6. acknowledgements 7. references appendix a the semantics of datatyping in the semantic web recommendations a.1 datatypes in rdf a.2 datatypes in owl dl appendix b integrating description logics with user-defined datatypes appendix c changes since working draft of 27 april 2005 1. introduction an overview of the datatype abstraction used by rdf is found in the rdf concepts and abstract syntax this is shared by the owl abstract syntax the semantics of rdf datatyping and owl datatyping are summarized in appendix a. rdf and owl allow the use of typed literal values in the description of resources and ontologies. see the rdf primer and the owl guide for a more introductory treatments for rdf and owl. both the rdf semantics and the owl semantics use the lexical-to-value mapping of the datatype to give the interpretation the value of a typed literal thus the semantics of typed literals is given by the type system. the type systems are defined externally to rdf and owl most notably by xml schema2 concrete syntaxes for typed literals are found in rdf syntax n-triples and n3 some questions about xml schema datatypes in the semantic web are not directly answered by the published w3c recommendations. this document considers four of them within rdf and owl how to refer to an xml schema user defined simple type with a uri. details of the denotational semantics of the values of the primitive xml schema simple types. xml schema principally gives an operational semantics. rdf and owl applications need a denotational semantics for interoperable behaviour. a possible solution to the problems concerning xsd duration which are reported in rdf semantics appropriate use of numeric types for engineering applications. 1.1 reading this document while this document can be read from start to finish many readers will benefit from skipping sections. the intended reader is informed about rdf and or owl and may be a creator or user of metadata or ontologies or may be an implementor of systems that implement the rdf or owl recommendations or may be the author or editor of related specifications. the reader who is interested in defining their own datatypes should read section 2 and maybe appendix b which gives a formal treatment in terms of owl dl and user defined datatypes that has not been covered by the owl semantics the reader who is interested in the correct use of datatypes should read section 3 concerning which values are the same and section 5 concerning numerics particularly but not exclusively for engineering applications. implementors probably should read most of the document appendix a summarizes the formal treatment of datatyping from the recommendations section 3 gives an extended discussion about equality section 2 discusses the mapping from uris to user defined types. readers most interested in formal semantics will find most value in appendix b concerning user defined datatypes and section 3 concerning equality. such readers should start by reviewing appendix a which should be familiar. section 4 on durations is of more limited interest but is significant to any reader who wishes to use implement or build on top of duration datatypes. 1.2 namespaces used in this document in this document we use n3 such as 10 xsd int following the subset used by the owl test cases with the following namespace prefixes prefix dc http purl.org dc elements 1.1 prefix eg http www.example.org prefix egdt http example.org simpletypes# prefix xsd http www.example.org prefix rdf http www.w3.org 1999 02 22-rdf-syntax-ns# prefix rdfs http www.w3.org 2000 01 rdf-schema# prefix owl http www.w3.org 2002 07 owl# prefix xsd http www.w3.org 2001 xmlschema# 1.3 xml schema simple types xml schema2 defines facilities for defining simple types to be used in xml schema as well as other xml specifications. it is influenced by earlier work on datatypes such as iso 11404 definition an xml schema simple type d is characterised by a value space v d which is a non-empty set a lexical space l d which is a non-empty set of unicode strings and a set of facets f d each of which characterizes a value space along independent axes or dimensions. xml schema simple types are divided into disjoint built-in simple types and derived simple types. derived datatypes can be defined from primitive or existing derived datatypes by the following three means by restriction i.e. by using facets on an existing type so as to limit the number of possible values of the derived type. by union i.e. to allow values from a list of simple types. by list i.e. to define the list type of an existing simple type. example 1a the following is the definition of a derived simple type of the base datatype xsd integer which restricts values to integers greater than or equal to 0 and less than 150 using the facets mininclusive and maxexclusive. xsd schema xsd simpletype name humanage xsd restriction base integer xsd mininclusive value 0 xsd maxexclusive value 150 xsd restriction xsd simpletype xsd schema 2. user defined datatypes xml schema2 predefines about forty simple types the ones suitable for rdf and owl are listed in rdf semantics in addition xml schema permits users to refine these builtin types by taking a restriction including only some of the values or some of the lexical forms. example 2a as a further example we may wish to talk about ages of adults in years where an adult is over 18. this can be described as a restriction on the xsd integer datatype. xsd schema xsd simpletype name adultage xsd restriction base integer xsd mininclusive value 18 xsd restriction xsd simpletype xsd schema in a semantic web context this may be used with the objects of triples of an eg age property used for instance when describing some members of a club which is restricted to adults e.g. a nightclub or a political party. we will use this example throughout this section and assume it can be retrieved from http example.org simpletypes. within rdf and rdf reasoning this additional restriction may be enough to catch some typos or data entry errors e.g. putting an inappropriate value of 0 for the eg age property within owl and owl reasoning this may interact with axioms in the ontology to significantly restrict the possible interpretations adding to the modelling power of the language. this section only deals with the problem of how to refer to such datatypes. their semantics is treated in the appendices. appendix a reviews the semantics of datatypes from the rdf and owl recommendations. appendix b describes how to integrate description logics such as the shoin dl which is the underpinning of owl dl with user defined datatypes. we will also consider the topic of the target namespace from xml schema1 for clarity we will consider two variants on this example. the first has no target namespace the second defines one. example 2b xs schema xmlns xs http www.w3.org 2001 xmlschema xs simpletype name adultage xs restriction base integer xs mininclusive value 18 xs restriction xs simpletype xs schema example 2c xs schema targetnamespace http example.org ns elementformdefault qualified xmlns egn http example.org ns xmlns xs http www.w3.org 2001 xmlschema xs simpletype name adultage xs restriction base integer xs mininclusive value 18 xs restriction xs simpletype xs schema the case where the xml schema has been assembed from multiple schema documents lies outside the scope of this document. this case is discussed in xml schema1 and explicitly not discussed in xscd 2.1 problem statement when describing a resource with rdf or building an ontology with owl in which a user defined simple xml schema datatype such as adultage above what uri should be used to identify this datatype 2.2 component designators solution following xml schema component designators xscd example 2b has uri reference http example.org simpletypes#xscd type adultage a uri reference for example 2c requires a choice of prefix for the namespace http example.org ns. a good choice is to use the prefix used by the schema itself i.e. egn. the resulting uri reference for the datatype is then http example.org simpletypes#xmlns egn http example.org ns xscd type egn adultage when the schema does not define a prefix for the target namespace perhaps by using the default namespace then an arbitrary prefix needs to be chosen. as always with namespace prefixes it is permitted to use any prefix of your choice even when a conventional prefix is used in the schema document. xml schema component designators xscd defines an xpointer scheme that navigates the xml schema document to identify any of the schema components using a fragment. this is very general fragments are defined that identify many different aspects of the document including unnamed simple types within complex schema. our example 2b becomes eg membersage rdfs range http example.org simpletypes#xscd type adultage amember eg name jane doe amember eg membersage 24 http example.org simpletypes#xscd type adultage one way of reading the fragment is that it provides full semantic clarity about what is being identified the xscd shows that an xml schema component is being identified the type indicates that a type is being identified the adultage shows which type is being identified. the above urirefs cannot be abbreviated as eg membersage rdfs range egdt xscd type adultage amember eg name jane doe amember eg membersage 24 egdt xscd type adultage because xscd type adultage does not match the ncname production. overall referring to xml schema datatypes in the manner proposed by the xml schema working group is a good practice and will be moreso when xscd reaches recommendation status. 2.3 using the id attribute in cases where the xml schema is under the control of a semantic web author the full generality of xscd is not needed. this section shows how when defining your own datatype derived from an xml schema type it is possible to use a simpler method by slightly modifying the schema defining the datatype. example 2a becomes xsd schema xsd simpletype id adultage name adultage xsd restriction base integer xsd mininclusive value 18 xsd restriction xsd simpletype xsd schema the difference is that the datatype we wish to use is not only identified by the name attribute but also by an id attribute. while it is technically possibly to use different values for these two attributes it would be confusing. the uri reference http example.org simpletypes#adultage can then be used to refer to the datatype. in the terminology of rfc 3986 the uri http example.org simpletypes#adultage identifies a secondary resource. when http example.org simpletypes is retrieved as an xml schema document with mimetype application xml this may be taken as a shorthand pointer from the xpointer framework this identifies a view on the xml representation of the primary resource being the xml element with the matching id attribute. when used in rdf see rdf concepts this uri reference may be understood with the uri http example.org simpletypes as identifying the schema and the uri http example.org simpletypes#adultage as identifying the datatype itself a resource defined or described by the representation identified by the application xml retrieval. it is preferred that no targetnamespace is given in the schema for this usage. if there is no id attribute with the given name the xpointer framework is clear that this is an error if no element information item is identified by a shorthand pointer s ncname the pointer is in error. our example rdf is eg membersage rdfs range http example.org simpletypes#adultage amember eg name jane doe amember eg membersage 24 http example.org simpletypes#adultage or eg membersage rdfs range egdt adultage amember eg name jane doe amember eg membersage 24 egdt adultage as a further example a club which has members of all ages but wishes to have a class of its adult members could use an owl expression like the following in the owl abstract syntax class adultmembers insersectionof members restriction eg membersage allvaluesfrom egdt adultage 2.4 suggested practice when referring to arbitrary user defined datatypes in arbitrary xml schema the xscd solution is appropriate. when an rdf or owl author or tool is writing an xml schema for use with an rdf xml document the id solution may be preferred. 3. comparison of values two different authors publishing the same information on the semantic web may make different syntactic choices. they then say the same thing in different ways. this is seen most clearly when the two documents entail one another as determined by the rdf semantics or owl semantics one aspect of the syntactic choices facing an author is which datatypes to use. even if they use only the built in xml schema2 simple types there are non-trivial choices and different authors may legitimately choose different datatypes. this section addresses the issue of how implementations of rdf semantics and owl semantics should allow for the different choices of datatype made by different authors. 3.1 problem statement what is the relationship between the value spaces of the various xml schema built-in simple types when used within rdf and owl or in other words when do two literals which are written down differently refer to the same value. for example 10 xsd integer and 010 xsd integer both denote the integer ten. 3.2 all primitive types differ the most appropriate solution is that all primitive xml schema datatypes are treated as having disjoint value spaces. this approach is both easy to understand and easy to implement. formally in a unary datatype group value spaces of primitive base datatypes are required to be defined as disjoint with each other. for instance if the value space datatype d1 is a subset of that of the datatype d2 then d1 and d2 can not be both primitive base datatypes in a unary datatype group. 3.3 formal analysis in discussing the examples we presented pairs of literals which denoted the same value. this relationship of denoting the same value forms an equivalence relation which we will write as it is conventionally written as and called equality. it is reflexive symmetric and transitive. in terms of the rdf semantics see appendix a.1 the equivalence relation can be constructed from the interpretation function il in the following way x y il x il y for any x y lv in terms of owl semantics see appendix a.2 this can be constructed in terms of the interpretation function ed as x y ed x ed y for any x y lv a key term we will use in the following examples is primitive base datatype in a type system. a recursive definition is each built in primitive datatype is its own primitive base datatype. the primitive base datatype of a derived simple type is the primitive base datatype of its base datatype. in other words the primitive base datatype of a type system is found by walking up the restriction tree until reaching a primitive type. note that the concept of primitive base datatypes in a type system is slightly different from the concept of primitive base datatypes in a unary datatype group. this is because it is possible that a primitive base datatype of a type system is not in a datatype map but its derived datatypes are. for instance in example_b xsd integer is a primitive base datatype in the unary datatype group g1. 3.4 examples we give two sets of examples. the first set of examples depend on comparisons where the primitive base datatype is the same. the second set where the primitive base datatype is not. however the second set are intended to be slightly counter-intuitive and to illustrate limitations in this approach to comparing typed literals. each example is presented in two ways as a pair of literals which may or may not denote the same value. as a possible entailment. technically the intended entailment is a d-entailment in terms of rdf semantics or an owl full entailment in terms of the owl semantics similar slightly longer owl dl entailments could be constructed illustrating the same issues. 3.4.1 easy examples it is uncontested that in xml schema2 a datatype derived by restriction refers to a subset of the values of its base datatype and not to different values see xml schema2 hence two typed literals whose type have the same primitive base datatype and whose lexical forms are equivalent are equal. in addition rdf semantics explicitly sanctions identification of rdf plain literals without language tags with corresponding typed literals with datatype xsd string. derived numerics as a first example 15 xsd byte and 15.0 xsd decimal both denote the same value fifteen. this follows because xsd byte has primitive base datatype xsd decimal. this licenses the following entailment example 3a eg jane eg age 15 xsd byte entails eg jane eg age 15.0 xsd decimal the same result holds for two types both of which have primitive base datatype decimal. for example 15 xsd byte and 15 xsd nonnegativeinteger both denote fifteen and the entailment example 3b eg jane eg age 15 xsd nonnegativeinteger entails eg jane eg age 15 xsd byte note that xsd byte is not derived from xsd nonnegativeinteger or vice versa even with intermediate steps. derived strings xsd language has primitive base datatype xsd string. thus en-us xsd language and en-us xsd string denote the same value and the following entailment holds example 3c eg doc dc language en-us xsd language entails eg doc dc language en-us xsd string however despite the language identifier being case insensitive according to rfc 3066 this case insensitivity is not represented in the datatype so that en-us xsd language and en-us xsd language denote different values and we have the following non-entailment example 3d eg doc dc language en-us xsd language does not entail eg doc dc language en-us xsd language plain strings the rdf semantics says in an informative section the value space and lexical-to-value mapping of the xsd datatype xsd string sanctions the identification of typed literals with plain literals without language tags for all character strings which are in the lexical space of the datatype since both of them denote the unicode character string which is displayed in the literal thus en-us xsd string denotes the same as the plain literal en-us and the following two entailments hold example 3e eg doc dc language en-us xsd string entails eg doc dc language en-us example 3f eg doc dc language en-us xsd language entails eg doc dc language en-us 3.4.2 hard examples when the two typed literals being compared have different primitive base datatypes all the values are assumed to be different and entailments do not follow even when this is counterintuitive. the number one for instance can be a float a double or a decimal. since they all have different primitive base datatypes these are all different. float and decimal a human age is conventionally given as an integer number of years except for babies but a float is a plausible alternative representation. on april 7th 2004 jeremy was forty 40 xsd integer has a different primitive basetype to 40 xsd float so that they are not equal and example 3g eg jeremycarroll eg ageinyears 40 xsd integer does not entail eg jeremycarroll eg ageinyears 40 xsd float similarly float and double are different primitive base datatypes and so superficially similar values such as 1.3 xsd float and 1.3 xsd decimal are different and example 3h eg car eg enginesizeinlitres 1.3 xsd decimal does not entail eg car eg enginesizeinlitres 1.3 xsd float float and double as with float and decimal neither float or double is derived from the other. thus 40 xsd double and 40 xsd float are treated as not equal and example 3j eg jeremycarroll eg ageinyears 40 xsd double does not entail eg jeremycarroll eg ageinyears 40 xsd float similarly example 3k eg car eg enginesizeinlitres 1.3 xsd double does not entail eg car eg enginesizeinlitres 1.3 xsd float string and anyuri similarly the two types string and anyuri are distinct primitive base datatypes. so that despite superficial similarities http www.example.org doc xsd string is different from http www.example.org doc xsd anyuri and example 3l eg doc dc identifier http www.example.org doc xsd anyuri does not entail eg doc dc identifier http www.example.org doc xsd string hexbinary and base64binary the final case where the value spaces of two xml schema simple types appear to the same is for xsd hexbinary and xsd base64binary. for both the value space is described as the set of finite-length sequences of binary octets. for instance the binary sequence of two octets 00001111 10110111 i.e. the 16-bit integer 4023 can be written in hexadecmial as 0fb7. in base64 encoding rfc 2045 this same sequence of two octets is represented as d7c despite this the two types hexbinary and base64binary are distinct primitive base datatypes. so that 0fb7 xsd hexbinary is different from d7c xsd base64binary and example 3m eg doc eg checksum 0fb7 xsd hexbinary does not entail eg doc eg checksum d7c xsd base64binary 3.5 using sparql for equality while some of the non-entailments shown may be counterintuitive it is possible to use sparql to query a graph and retrieve literal values that are similar even if not derived from the same primitive base type. for example related to examples 3h and 3k. given a graph including the following three triples eg car eg enginesizeinlitres 1.3 xsd double eg car eg enginesizeinlitres 1.3 xsd decimal eg car eg enginesizeinlitres 1.3 xsd float the following sparql query will match all three. select size where eg car eg enginesizeinlitres size filter size 1.3 in the current sparql working draft the mapping from the typed literal as a syntactic object to its corresponding value is done as part of the operation of the operator in the above query rather than as part of say a d-interpretation from rdf semantics this mapping is specified in functions operators and being strongly typed is not identical with that specified in rdf semantics 3.6 value approximate mapping a different approach better embedded in rdf semantics could enable meaningful mappings among values from different datatypes. this could give better foundations for operations such as the type promotion of the xml path language 2.0 xpath 2.0 and the operator in sparql mentioned in section 3.5. a quick sketch is that we extend the rdf d-interpretation to support value approximate maps as follows definition a value approximate map mapsto is a partial mapping from typed literals to typed literals. example 3n an example value approximate mapping is 1.3 xsd decimal owlx mapsto 1.3 xsd float definition given a datatype map d and a value approximate map mapsto the approximate equality aeq is defined as follows aeq s1 u1 s2 u2 true if l2s d u1 s1 l2s d u2 s2 or if mapsto s1 u1 s3 u2 and l2s d u2 s3 l2s d u2 s2 aeq s1 u1 s2 u2 false otherwise. note that according to the above definition aeq s1 u1 s2 u2 true does not imply that s1 u1 and s2 u2 are interpreted as the same value l2s d u1 s1 l2s d u2 s2 the approximate equality is different from equality and is not necessarily symmetric depending on the corresponding value approxiate map. the unsymmetry is needed to support e.g. type promotions in the xml path language 2.0 xpath 2.0 note that notion of value approxiate mappings is very general it does not disallow having symmetric mappings between two typed literals. in example 3n one can also specify a value approximate mapping from 1.3 xsd float to 1.3 xsd decimal to make the mappings between the two typed literals symmetric. to sum up applications can specify a value approximate map mapsto and make use of the approximate equality aeq for their purposes. 4. duration the rdf semantics recommendation discourages the use of the xsd duration datatype see xml schema2 it says some built-in xml schema datatypes are unsuitable for various reasons and should not be used xsd duration does not have a well-defined value space this may be corrected in later revisions of xml schema datatypes in which case the revised datatype would be suitable for use in rdf datatyping the underlying difficulty is the impossibility of an unequivocal answer to the question how many days in a month this has proved problematic in other applications of xml schema datatypes. the xquery and xslt working groups have a proposed solution. they derive two new datatypes xdt yearmonthduration and xdt daytimeduration from xsd duration sidestepping the unanswerable question. in section 10.2 of functions operators we read definition xdt yearmonthduration is derived from xs duration by restricting its lexical representation to contain only the year and month components. the value space of xdt yearmonthduration is the set of xs integer month values. the year and month components of xdt yearmonthduration correspond to the gregorian year and month components defined in section 5.5.3.2 of iso 8601 respectively. and definition xdt daytimeduration is derived from xs duration by restricting its lexical representation to contain only the days hours minutes and seconds components. the value space of xdt daytimeduration is the set of fractional second values. the components of xdt daytimeduration correspond to the day hour minute and second components defined in section 5.5.3.2 of iso 8601 respectively. these two new datatypes are suitable for use with rdf and owl. note that they are not yet recommended since f&o is still in working draft 5. the use of numeric types for much data on the semantic web a motivation for providing type information is to permit the use of the data by engineering applications and interoperation between engineering applications. most such data will be marked up using the numeric types from xml schema. loss in precision or unexpected changes in values due to automatic type conversion could be problematic in an engineering environment. in the engineering domain there are three important types of usage for numerics count measurement and constant. count a count is an integer representing essentially the cardinal number for a set of things classified by some set of tests. an example would be the count of packages of candy available for shipment. a count is an exact number. tests may include measurements but a count is not an approximation of a sum of these measurements nor is it a sum of the approximation of these measurements. a type such as xsd integer or a type derived from xsd integer is appropriate for counts. measurement a measurement is an inexact numeric value usually represented as a real produced by some measurement method. this value indicates a value range which includes the actual value. the actual value is unknowable but more precise measurement methods can reduce the range of uncertainty. the precision or uncertainty is usually included with the measurement value. either implicitly using significant figures or explicitly using a separate property value such as error range. either the xsd float or xsd double datatypes are appropriate for measurement but it should be noted that these do not include a precision or uncertainity which should be included as the value of a separate property. xml schema2 explicitly states for xsd decimal that precision is not reflected in this value space the number 2.0 is not distinct from the number 2.00. constant a constant is an exact value used in computation. it may or may not be possible to express exactly as a numeric. a millimeter is exactly 0.001 meters but pi is not 3.14159. often an xsd decimal will be more appropriate than an xsd float or xsd double for expressing a constant. example 5a as an example of a measurement with an error range to indicate a weight in the interval 73.0kg 73.2kg eg jeremycarroll eg weight w w eg units kilogram w eg value 73.1 xsd float w eg errorrange 0.1 xsd float these different usages suggest some potential needs and concerns for a type system underlying this. because the value spaces for these types are different measurements are disjoint from counts and constants. some means of capturing precision or error uncertainty is needed for measurement values. some means is desirable for writing down constants that cannot be expressed precisely in numeric form. the first of these issues will generally be reflected in the use of xsd integer for counts xsd float and xsd double for measurements and xsd decimal for constants. the second issue concerning precision of measurements must be addressed at the modelling level by using objects to state precision or error properties for measurements. this is not a bad approach in any case since there are often other properties or metadata associated with a measurement. for the third issue concerning some constants no solution is offered. 6. acknowledgements evan wallace is the author of section 5. evan wallace ashok malhotra pat hayes dave peterson dave reynolds michael sperberg-mcqueen and ralph swick contributed useful reviews. 7. references rdf-semantics rdf semantics patrick hayes editor w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-rdf-mt-20040210 latest version available at http www.w3.org tr rdf-mt rdf primer rdf primer frank manola and eric miller editors w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-rdf-primer-20040210 latest version available at http www.w3.org tr rdf-primer rdf concepts resource description framework rdf concepts and abstract syntax graham klyne and jeremy j. carroll editors w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-rdf-concepts-20040210 latest version available at http www.w3.org tr rdf-concepts rdf syntax rdf xml syntax specification revised dave beckett editor w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-rdf-syntax-grammar-20040210 latest version available at http www.w3.org tr rdf-syntax-grammar n-triples rdf test cases jan grant and dave beckett editors w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-rdf-testcases-20040210 latest version available at http www.w3.org tr rdf-testcases owl abstract syntax owl semantics owl web ontology language semantics and abstract syntax peter f. patel-schneider patrick hayes and ian horrocks editors w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-owl-semantics-20040210 latest version available at http www.w3.org tr owl-semantics owl guide owl web ontology language guide michael k. smith chris welty and deborah l. mcguinness editors w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-owl-guide-20040210 latest version available at http www.w3.org tr owl-guide owl test cases owl web ontology language test cases jeremy j. carroll and jos de roo editors. w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-owl-test-20040210 latest version available at http www.w3.org tr owl-test xpointer framework xpointer framework paul grosso eve maler jonathan marsh and norman walsh editors w3c recommendation 25 march 2003 http www.w3.org tr 2003 rec-xptr-framework-20030325 latest version available at http www.w3.org tr xptr-framework xml-schema1 xml schema part 1 structures second edition w3c recommendation world wide web consortium henry s. thompson david beech murray maloney and noah mendelsohn editors 28 october 2004. this version is http www.w3.org tr 2004 rec-xmlschema-1-20041028 the latest version is available at http www.w3.org tr xmlschema-1 xml-schema2 xml schema part 2 datatypes second edition w3c recommendation world wide web consortium paul v. biron and ashok malhotra editors 28 october 2004. this version is http www.w3.org tr 2004 rec-xmlschema-2-20041028 the latest version is available at http www.w3.org tr xmlschema-2 rfc 2045 n. freed and n. borenstein. rfc 2045 multipurpose internet mail extensions mime part one format of internet message bodies. 1996. available at http www.ietf.org rfc rfc2045.txt rfc 3986 t. berners-lee r. fielding and l. masinter. uniform resource identifiers uri generic syntax. ietf rfc 3986. see http www.ietf.org rfc rfc3986.txt. rfc 3066 h. alvestrand ed. rfc 3066 tags for the identification of languages 2001. available at http www.ietf.org rfc rfc3066.txt iso 8601 iso international organization for standardization representations of dates and times 2000-08-03. available from http www.iso.ch iso 11404 iso international organization for standardization language-independent datatypes. available from http www.iso.ch unicode the unicode standard version 3 the unicode consortium addison-wesley 2000. isbn 0-201-61633-5 as updated from time to time by the publication of new versions. see http www.unicode.org unicode standard versions for the latest version and additional information on versions of the standard and of the unicode character database functions operators xquery 1.0 and xpath 2.0 functions and operators ashok malhotra jim melton and norman walsh editors world wide web consortium working draft work in progress 15 september 2005. this version of functions and operators is http www.w3.org tr 2005 wd-xpath-functions-20050915 the latest version of functions and operators is at http www.w3.org tr xpath-functions xpath 2.0 xml path language xpath 2.0 anders berglund scott boag don chamberlin mary f. fern ndez michael kay jonathan robie and j r me sim on editors w3c candidate recommendation 3 november 2005. this version of xml path language xpath is http www.w3.org tr 2005 cr-xpath20-20051103 the latest version of xml path language xpath is at http www.w3.org tr xpath20 sparql sparql query language for rdf eric prud hommeaux and andy seaborne editors w3c working draft 21 july 2005 http www.w3.org tr 2005 wd-rdf-sparql-query-20050721 latest version available at http www.w3.org tr rdf-sparql-query xscd xml schema component designators mary holstege and asir s. vedamuthu editors w3c working draft 29 march 2005 http www.w3.org tr 2005 wd-xmlschema-ref-20050329 latest version available at http www.w3.org tr xmlschema-ref pan 2004 description logics reasoning support for the semantic web jeff z.pan phd thesis school of computer science the university of manchester 2004. ph 2005 owl-eu adding customised datatypes into owl jeff z.pan and ian horrocks. in proc. of the second european semantic web conference eswc 2005 pages 153-166 2005. an extended version appears in the journal of web semantic 4 1 an online version is available at http www.websemanticsjournal.org ps pub 2005-24. n3 primer getting into rdf semantic web using n3 tim berners-lee dan connolly appendix a the semantics of datatyping in the semantic web recommendations a.1 datatypes in rdf according to rdf semantics see section 5.1 rdf allows the use of datatypes defined by any external type systems e.g. the xml schema type system which conform to the following specification. definition in rdf a datatype d is characterised by a value space v d which is a non-empty set a lexical space l d which is a non-empty set of unicode strings and a total mapping l2v d from the lexical space to the value space. this specification allows the use of non-list xml schema simple types as datatypes in rdf. definition all literals have a lexical form being a unicode unicode string. typed literals are of the form v u where v is a unicode string called the lexical form of the typed literal and u is a uri reference of a datatype. plain literals have a lexical form and optionally a language tag as defined by rfc-3066 normalized to lowercase. example a boolean is a datatype with value space true false lexical space true false 1 0 and lexical-to-value mapping true true false false 1 true 0 false true xsd boolean is a typed literal while true is a plain literal. the associations between datatype uri references e.g. xsd boolean and datatypes e.g. boolean can be provided by datatype maps defined as follows. definition a datatype map d is a partial mapping from datatype uri references to datatypes. an rdfs-interpretation w.r.t. a datatype map d can be defined as follows. definition given a datatype map d an rdfs d-interpretation i of a vocabulary v is any rdfs-interpretation of v u d.d u d which introduces i a distinguished subset lv of ir called the set of literal values which contains all the plain literals in v and ii a mapping il from literals in v into ir and satisfies the following extra conditions lv icext rdfs literal for any plain literal pl v il pl pl. for each pair u d where d d u i u icext rdfs datatype there exists d ir s.t. i u d icext d v d lv for s u v i u d if s l d then il s u l2s d s otherwise il s u ir lv. if d icext rdfs datatype then d i rdfs literal iext rdfs subclassof a.2 datatypes in owl dl owl full datatyping follows the rdf semantics as above owl dl datatyping is specified in section 3.1 of the owl semantics as follows. the fundamental difference between rdf datatyping and owl dl datatyping is the relationship between datatypes and classes. in owl dl datatypes are not classes and object and datatype domains are disjoint with each other. owl allows different owl reasoners to provide different supported datatypes. definition given a datatype map d a datatype uri reference u is called a supported datatype uri reference w.r.t. d if there exists a datatype d such that u d d in this case d is called a supported datatype w.r.t. d otherwise u is called an unsupported datatype uri reference w.r.t. d. owl provides the use of so called enumerated datatypes which are built using literals. definition let y1 yn be literals. an enumerated datatype is of the form oneof y1 yn an owl dl d-interpretation w.r.t. a datatype map d can be defined as follows. definition an owl dl datatype interpretation w.r.t. to a datatype map d is a pair lv ed where the datatype domain lv only contains the value spaces for each datatype in d and pl the value space for plain literals i.e. the union of the set of unicode strings and the set of pairs of unicode strings and language tags and ed is a datatype interpretation function which has to satisfy the following conditions lv ed rdfs literal for any plain literal pl ed pl pl pl. for each supported datatype uriref u let d d u ed u v d lv if s l d then ed s u l2v d s otherwise ed s u is not defined. for each unsupported datatype uriref u ed u lv and ed s u ed u each enumerated datatype oneof y1 yn is interpreted as ed y1 ed yn note that here we simplify the presentation by using ed as the interpretation function for both datatype uri references and literals while owl semantics uses ec for datatypes uri references and l for literals. in owl full the disjointness restriction between object and datatype domains is not required. appendix b integrating description logics with user-defined datatypes pan 2004 and ph 2005 present a scheme of integrating a large family of decidable description logics including shoin the underpinning of owl dl with unary datatype groups so as to support user defined datatypes. a combined dl is decidable if the unary datatype group is conforming. a conforming unary datatype group is equipped with a decision procedure for the satisfiability problem of finite conjunctions over supported datatypes. definition a unary datatype group g is a triple d b dom where d is a datatype map b is the set of primitive base datatype uri references in g and dom is the declared domain function. we call s the set of supported datatype uri references i.e. for each u s d u is defined we require b s. the declared domain function dom has the following properties for each u s if u b dom u u otherwise dom u v where v b. we assume that there exists a datatype uri reference rdfsx datatypebottom such that d rdfsx datatypebottom is undefined. note that in pan 2004 datatype groups allow arbitrary datatype predicates while here we consider only datatypes which can be regarded as unary datatype predicates. example b g1 d1 b1 dom1 is a unary datatype group where d1 xsd integer integer xsd string string xsd nonnegativeinteger 0 xsdx integerlessthann n b1 xsd integer xsd string dom1 xsd integer xsd integer xsd string xsd string xsd nonnegativeinteger xsd integer xsdx integerlessthann xsd integer according to d1 we have s1 xsd integer xsd string xsd nonnegativeinteger xsdx integergreaterthann hence we have b1 s1. note that the value space of n is v n i v integer i l2s integer n and by n we mean there exists a built-in datatype n for each integer l2s integer n in a unary datatype group datatype expressions can be used to represent user defined datatypes. definition let g be a unary datatype group the set unary datatype expressions for g abbreviated dexp g is inductively defined as follows let u be a datatype uri reference u dpexp g let u be a datatype uri reference its relativised negation not u dpexp g let y1 yn be literals the enumerated datatype oneof y1 yn dpexp g for any p q dpexp g their conjunction and p q dpexp g for any p q dpexp g their disjunction or p q dpexp g example c the xml schema user defined datatype humanage defined in example 1a can be represented by the following unary datatype expression and xsd nonnegativeinteger xsdx integerlessthan150 definition a datatype interpretation of a unary datatype group g d b dom is a pair lv ed where the datatype domain lv is a non-empty set and ed is a datatype interpretation function that has to satisfies the following conditions ed rdfs literal lv and ed rdfsx datatypebottom for each plain literal pl ed pl pl pl and pl lv. for any two primitive base datatype uri references u1 and u2 ed u1 ed u2 for each supported datatype uri reference u s let d d u ed u v d v d dom u lv l d u l d dom u and l2s d u l2s d dom u if s l d then ed s u l2v d s otherwise ed s u is not defined. for each unsupported datatype uri reference u s ed u lv and s u ed u the datatype interpretation function ed can be extended to provide semantics to unary datatype expressions as follows relativised negations if u s d ed not u ed dom u ed u otherwise ed not u lv ed u enumerated datatypes ed oneof y1 yn ed y1 ed yn conjunctions ed and p q ed p ed q disjunctions ed or p q ed p ed q ph 2005 shows that we can combine any decidable dl including shoin the underpinning of owl dl that provides the conjunction and bottom constructors with a conforming unary datatype group and the combined dl is still decidable. appendix c changes since working draft of 27 april 2005 c.1 typos etc. semanitcs in introduction. updated syntax for xml schema component designators. deleted broken link from description of iso 11404 added reference to iso homepage instead. c.2 discussion removal the earlier draft was a discussion document. this note is not intended as such so some issues particularly to do with the interactions between various standards recommendations rfcs etc. has been removed. removed daml+oil solution. removed true values solution. removed xpath eq solution. moved owl syntax example from daml+oil section to the end of id section. in the xml schema component designator section discussion of relationship between xscd xpointer and rfc 3023 has been removed. discussion about the exact semantics of an xscd fragment has been removed. deleted words less contentious and moreover from id solution. changed xml schema component designator section to indicate that xscd is a good practice. in particular see last paragraph. changed discussion subsection on user defined datatypes to suggest that both the remaining solutions are appropriate and have no discussion. changed title to suggested practice. discussion of harder examples cut down substantially since these are all trivially non-entailments with the agreed semantics. removed editors opinion notes. c.3 changes in response to comment from ashok malhotra deleted all uses of the word derivation in section 1.3 since it has caused confusion. added links to the xml schema document for union list and restriction to make it clear that the intended concept is derivation as defined by that document. added brief discussion of target namespace after example 2a providing further examples example 2b and example 2c. scoped this document to not address xml schema assembled from multiple schema documents added reference xml schema1 in the xml schema component designator section added more extended discussion of target namespace issue and added example xscd for schema with target namespace. added text showing how the id solution does comply with the secondary resource concept from rfc 3986 when read in conjunction with rdf concepts xpointer and xml schema. c.4 restructuring of section 3 reordered subsections in section 3 deleting old 3.5 3.6 and 3.7 and ordering the remaining subsections as follows 3.1 3.4 3.2 3.3. followed by renumbering. text discussing examples has changed and the change tracking is not detailed. moved definition of primitive base datatype from the examples subsection to the formal uow.acc.tab.analysis subsection. deleted references to the examples from the new section 3.2 was 3.4 added example sparql query to show how to use in sparql to compare across the type hierarchy. added an updated discussion of mapsto. c.5 other changes added further acknowledgements. updated reference to rfc 2396 to be to rfc 3986 updated table of contents removed unused references. updated versions of w3c wd s in references. 