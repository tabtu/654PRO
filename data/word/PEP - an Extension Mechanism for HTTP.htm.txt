pep an extension mechanism for http wd-http-pep-971121 pep an extension mechanism for http w3c working draft 21 november 1997 authors henrik frystyk nielsen dan connolly rohit khare eric prud hommeaux this version http www.w3.org tr wd-http-pep-971121 id wd-http-pep-971121.html v 1.2 1998 04 07 21 31 46 fillault exp latest released version http www.w3.org tr wd-http-pep previous versions http www.w3.org tr wd-http-pep-970714 http www.w3.org tr wd-http-pep-970428 http www.w3.org tr wd-http-pep-970321 http www.w3.org tr wd-http-pep-970131 http www.w3.org tr wd-http-pep-960820 http www.w3.org tr wd-http-pep-960819 http www.w3.org tr wd-http-pep-960222 http www.w3.org tr wd-http-pep-951122 http www.w3.org tr wd-http-pep-960220 status of this document this is a w3c working draft for review by w3c members and other interested parties. it is a draft document and may be updated replaced or made obsolete by other documents at any time. it is inappropriate to use w3c working drafts as reference material or to cite them as other than work in progress. a list of current w3c working drafts can be found at http www.w3.org tr this wd has also been submitted as ietf id draft-ietf-http-pep-05.txt the pep specification has gone through a thorough design phase and entered a steady state where the authors do not intend to modify the document any further. at the same time we have developed practical experience with the pep demo code available from http www.w3.org protocols pep which demonstrates both client server and proxy interactions using dynamic loaded pep extensions. however we believe that it is essential for a specification to be tested in real world applications before being deployed at large which is the reason for the status as experimental. abstract http is used increasingly in applications that need more facilities than the standard version of the protocol provides ranging from distributed authoring collaboration and printing to various remote procedure call mechanisms. the protocol extension protocol pep is an extension mechanism designed to address the tension between private agreement and public specification and to accommodate extension of applications such as http clients servers and proxies. the pep mechanism is designed to associate each extension with a uri 2 and use a few new rfc 822 1 derived header fields to carry the extension identifier and related information between the parties involved in an extended transaction. this document defines pep and describes the interactions between pep and http 1.1 7 pep is intended to be compatible with http 1.0 5 inasmuch as http 1.1 is compatible with http 1.0 see 7 section 19.7 it is proposed that the pep extension mechanism be included in future versions of http. the pep extension mechanism may be applicable to other information exchange not mentioned in this document. it is recommended that readers get acquainted with section 1.4 for a suggested reading of this specification and a list of sections specific for http based applications. table of contents introduction 1.1 requirements 1.2 purpose 1.3 operational overview 1.4 guide to this specification the pep extension space in http notational conventions 3.1 bag syntax extension declarations 4.1 mapping header fields 4.2 the strength of a declaration 4.3 end-to-end extension declarations 4.4 hop-by-hop extension declarations extension policy information 5.1 the realm of a policy 5.2 policy expirations 5.3 extra parameters 5.4 end-to-end policies 5.5 hop-by-hop policies publishing an extension binding http requests 7.1 extending existing http methods 7.2 adding new http methods http status codes 8.1 420 policy not fulfilled 8.2 421 bad mapping http proxy servers 9.1 proxy servers as end-to-end recipients 9.1.1 proxy servers acting on behalf of user agents 9.1.2 proxy servers acting on behalf of origin servers 9.2 proxy servers and repeated hop-by-hop extensions practical considerations for http 10.1 interaction with existing http 1.1 methods 10.2 interaction with existing http 1.1 headers 10.3 server initiated extension declarations security considerations normative references bibliography informative references acknowledgements authors addresses summary of pep interactions examples 17.1 client queries server for dav 17.2 client informs server about zipflate compression extension 17.3 server uses content-digest extension 17.4 server requires client to use payment extension 1. introduction 1.1 requirements http is a generic request-response protocol designed to accommodate a variety of applications from network information exchange and searching to file transfer and repository access to query and forms processing. most http transactions are initiated by a user agent issuing a request to be applied to a resource on some origin server with intermediaries between them in some cases. the origin server replies with a response indicating the result of the transaction. semantically however an http transaction is between the principal accessing a resource end user and the principal responsible for the publication of a given resource publisher the publisher is responsible for the service provided at any particular uri for example the mapping between the uri and any representation of the resource to which it refers. the end user accesses information provided by a publisher. exactly who takes the role as end user or publisher is beyond the scope of this document. http as is the case for most transaction based information exchange protocols is used increasingly in applications that need more facilities than the standard version of the protocol provides from distributed authoring collaboration and printing to various remote procedure call mechanisms. many extended applications do not require agreement across the whole internet about the extended facilities rather it suffices that conforming peers supporting a particular protocol extension or feature can employ it dynamically with no prior agreement that it is possible for one party having a capability for a new protocol to require that the other party either understand and abide by the new protocol or abort the operation that negotiation of matching capabilities is possible. the need for extensibility creates a tension between dynamically extensible applications and public static specifications. 1.2 purpose the protocol extension protocol pep is an extension mechanism designed to accommodate dynamic extension of http applications by software components and to address the tension between private agreement and public specification. the kind of extensions capable of being introduced by pep range from extending a single protocol message introducing new encodings initiating http-derived protocols for new applications to... switching to protocols which once initiated run independent of the original protocol stack. this document defines the protocol extension mechanism referred to as pep the pep design is the result of analyzing a variety of extensions and extension mechanisms in http and http-like protocols and the motivation behind them. the specification also describes the interactions between pep and http 1.1 7 including scoping rules and cache semantics. pep is intended to be compatible with http 1.0 5 inasmuch as http 1.1 is compatible with http 1.0 see section 1.4 and 10 and it is proposed that the pep extension mechanism be included in future versions of http. 1.3 operational overview pep is intended to be used as follows some party designs and specifies an extension the party assigns the extension an identifier which is a uri and makes one or more representations of the extension available at that address see section 6 a party using a pep compliant agent with an implementation of the extension wishes to use it the agent declares the use of the extension by referencing its uri in a pep extension declaration see section 4 information about extensions can be passed between agents including information of where they can be used and under what conditions see section 5 if an extension becomes ubiquitous it may be incorporated into a new version of the base protocol hence transitioning from dynamic extension to static specification. in this case applications can refer to the new version of the base protocol instead of the pep extension see section 6 pep extension declarations are characterized by the following properties they link features introduced by the extension to the uri identifying the extension potentially allowing a recipient to interpret the message correctly with no prior agreement. they contain a strength and a scope allowing the sender to define the appropriate action to be taken by the recipient even if it does not understand the semantics of the extension. any agent can generate declarations independent of other agents the advantage of including the extension identifier is that at the cost of some extra bytes to spell out the uri the use of a central registry of extension names is avoided. pep can also be used to extend applications to support centrally registered extensions assuming a uri is published as part of the registration see section 6 the pep mechanism is designed to accommodate but does not require dynamic extension of clients servers and proxies by software components as follows clients and servers could be implemented with software component interfaces that allow dynamic installation of extension facilities. an implementation compatible with a software component interface supported by the agent could be made available at the uri identifying the extension. an agent receiving a message referring to an extension not known by the agent could dereference the extension s identifier and dynamically load support for the extended facility. the representation and implementation of dynamic extensible software component interfaces is outside the scope of this specification. 1.4 guide to this specification this specification is organized as follows section 2 describes how pep fits into http. this is not required reading but may further the understanding of the specification. section 3 is an overview of the notational conventions used throughout the specification. section 4 5 and 6 is the core part of the specification describing the generic pep extension mechanism. section 7 8 9 and 10 describe the interactions between pep and http 1.1 7 the generic pep extension mechanism may be applicable to other information exchange protocols. such mappings however are outside the scope of this specification. 2. the pep extension space in http pep is designed to support dynamic extensibility of http methods headers and status codes. before describing in detail how pep does this it is constructive to have a look at how methods headers and status codes behave in http methods the method token in an http request indicates the method to be performed on the resource identified by the request-uri. methods need a priori agreement of semantics and can not be extended dynamically. if an http server does not know a method it must report an error message see 7 section 5.1.1 a limitation of the method space is that a request can only contain a single method. hence it is not possible to support multiple simultaneous extensions unless having a multiplicity of methods. status codes the status code element is a 3-digit integer result code of the attempt to understand and satisfy the request. status codes are like method tokens in that there can only be a single status code in a response. however status codes are somewhat easier to extend as unknown status codes must be treated as the x00 cod-e of that class see 7 section 6.1.1 for example a new status code 223 my new code would default to 200 ok headers header fields can be used to pass information about any of the parties involved in the transaction the transaction itself or the resource identified by the request-uri. the advantage of headers is that the header space is relatively open compared to that of methods and status codes. new headers can be introduced and must be ignored if the recipient does not recognize the header without affecting the outcome of the transaction see 7 section 7.1 in order to achieve the desired flexibility pep is designed to use the header space for describing extensions and not directly http methods or status codes. instead pep introduces a placeholder in the method space and status code space respectively guaranteeing that all interactions with existing http applications perform according to the pep specification. the two placeholders are a special pep method and a pep- method prefix which indicates that a request contains one or more pep extensions that must be adhered to or the transaction aborted see section 7 a special status code 420 policy not fulfilled that indicates that the policy for accessing the resource was not met and that further information can be found in the response for diagnosing the problem see section 8.1 these two placeholders allow for multiple pep extensions to be deployed simultaneously without overloading the method space or the status code space. 3. notational conventions this specification uses the same notational conventions and basic parsing constructs as rfc 2068 7 in particular the bnf constructs token quoted-string field-name uri and delta-seconds in this document are to be interpreted as described in rfc 2068 7 the key words must must not required shall shall not should should not recommended may and optional in this document are to be interpreted as described in rfc 2119 9 pep does not rely on particular features defined in urls 3 that cannot potentially be expressed using urns see section 6 therefore the more generic term uri 2 is used throughout the specification. 3.1 bag syntax the bag element is a recursive structure that uses braces and to delimit attribute-value pairs that may consist of tokens quoted-strings uris and recursively defined bags. the bnf for the bag syntax is as follows bag bagname bagitem bagname token bagitem bag token quoted-string the bag semantics are defined by its context and the bag name. the value of a quoted string may be a uri in some cases. unless explicitly defined otherwise all tokens within a bag are case-insensitive. comments as defined by rfc 822 1 indicated by surrounding the comment text with parentheses must not be used within a bag construct. 4. extension declarations extension declaration bags are used to indicate the pep extensions that have been applied to a message. the grammar for an extension declaration is as follows ext-decl req-ext-attr opt-ext-attr req-ext-attr map opt-ext-attr strength attribute-ext map map uri header-prefix strength strength must may attribute-ext bag header-prefix 1 digit the map attribute bag contains the uri identifying the extension and a list of any header field names introduced by the extension see section 4.1 and 6 if the extension identifier is relative it is interpreted relative to the base uri of the message as defined by rfc 1808 4 the strength attribute bag indicates whether the recipient must or may obey the semantics given by the extension or report an error see section 4.2 an extension declaration bag ext-decl can be extended through the use of one or more attribute-ext bags. unrecognized attribute-ext bags should be ignored and must not be removed by proxies when forwarding the extension declaration see section 9 extension declarations can either be hop-by-hop or end-to-end see 7 section 13.5.1 depending on the scope of the declaration see section 4.3 and 4.4 end-to-end declarations must be transmitted to the ultimate recipient of the extension declaration. hop-by-hop declarations are meaningful only for a single transport-level connection. 4.1 mapping header fields the header-prefix in a map attribute bag can be used to indicate that all header fields in the message matching the header-prefix value using string prefix-matching are introduced by this extension declaration instance. this allows an extension instance to dynamically reserve a part of the header space in the message for introducing new header fields without risking header name conflicts with other extension instances. examples of header-prefix values are 1- 435- 546- 2343543645653- agents should not overload well-known or widely deployed header fields with new semantics unless the new semantics are a superset of the existing semantics so that the header fields still can be interpreted according to the old semantics. agents should not reuse already mapped header fields in the same message. if a header field is mapped by multiple extension declarations in the same message the recipient should report an error see section 8.2 proxies adding extension declarations to a message must make sure that any header fields introduced do not conflict with already mapped header fields in that protocol message see section 8.2 4.2 the strength of a declaration the strength attribute bag can be used to specify the actions to be taken by the ultimate recipient of the extension declaration. the strength value can indicate that the recipient must obey the extension declaration or report an error or the recipient may obey the extension declaration or ignore it altogether. if the strength is must the ultimate recipient must consult and adhere to the rules given by the extension when processing the message or report an error see section 7 and 8.1 if the strength is may the ultimate recipient of the extension may consult and adhere to the rules given by the extension when processing the message or ignore the extension declaration completely. an agent may not be able to distinguish whether the ultimate recipient does not understand an extension referred to by an extension declaration of strength may or simply ignores the extension declaration. if no strength attribute is present the default strength is may not accepting or ignoring an extension declaration is different from not accepting a mapping of header field-names introduced by the map attribute bag. if the ultimate recipient cannot accept a mapping for example if a field-name is already mapped by another extension declaration in that protocol message it should report an error see section 8.2 4.3 end-to-end extension declarations end-to-end declarations must be transmitted to the ultimate recipient of the declaration. the pep header field is an end-to-end header field and is defined as follows pep pep 1#ext-decl for example get http 1.1 host some.host pep map http www.w3.org pep dav if multiple end-to-end extensions are declared in the same message the declarations must be listed in the order in which they were applied to the message. proxies may under certain conditions act as the ultimate recipient of declarations on behalf of user agents and origin servers see section 9.1 4.4 hop-by-hop extension declarations hop-by-hop extension declarations are meaningful only for a single transport-level connection. the c-pep header field is a hop-by-hop header field and must not be communicated by proxies over further connections. the c-pep header has the following grammar c-pep c-pep 1#ext-decl for example get http 1.1 host some.host c-pep map http www.w3.org pep proxyauth 43- 43-credentials fsdgfag connection c-pep credentials in http the c-pep header field must be protected by a connection header by including c-pep as a connection header directive. the directive must be handled according to the http 1.1 specification of the connection header see section 10.2 and 7 section 14.10 an agent must not send the c-pep header field to an http 1.0 proxy as it does not obey the http 1.1 rules for parsing the connection header field see 7 section 19.7.1 if multiple hop-by-hop extensions are declared in the same message the extension declarations must be listed in the order in which they were applied. hop-by-hop c-pep declarations must be processed before any end-to-end pep declarations. 5. extension policy information extension policy bags are used to indicate the extensions that may be applied to a message. extension policies differ from extension declarations in that the latter is information about which extensions have been applied to a message. an extension policy is defined as follows policy-decl req-pol-attr opt-pol-attr req-pol-attr id opt-pol-attr for max-age parameters strength attribute-ext id id uri for for uri-wildcard max-age max-age delta-seconds parameters params bagitem uri-wildcard uri wildcard wildcard the id attribute specifies the uri identifying the extension see section 6 if the extension identifier is relative it is interpreted relative to the base uri of the message as defined by rfc 1808 4 the for attribute bag specifies which resources the policy is intended for see section 5.1 and the max-age attribute bag when the information should be considered stale see section 5.2 the params attribute bag can be used to pass additional information about the extension policy see section 5.3 the strength attribute indicates whether the policy is a requirement or optional for the resource s for which it applies see section 4.2 an extension policy bag policy-decl can be extended through the use of one or more attribute-ext bags. unrecognized attribute-ext bags should be ignored and must not be removed by proxies when forwarding the extension policy see section 9 extension policies can either be hop-by-hop or end-to-end policies see 7 section 13.5.1 depending on the scope see section 5.4 and 5.5 end-to-end policies must be transmitted to the ultimate recipient of the extension policy. hop-by-hop policies are meaningful only for a single transport-level connection. note it is expected that extension policies will be integrated with other metadata initiatives like the rdf initiative 11 for example. 5.1 the realm of a policy the for attribute bag can be used to specify the resource s identified by uri s to which the policy applies. this allows extension policies to be deployed to third party sites and to be distributed by other means than directly between the involved parties. a uri followed by a lws and a wildcard represents the set of uris that contains the given uri using prefix matching. a uri with no wildcard means that uri only. examples of uri-wildcards are for for http www.w3.org pub for secret overview.html an empty for attribute bag no bagitems included indicates that the policy is not applied to any resource. if no for attribute bag is present the default value is the request-uri. a realm can include any number of resources but note that a single wildcard is not a valid uri-wildcard value. 5.2 policy expirations the max-age attribute bag can be used to specify a date time after which the recipient should consider the policy stale. the max-age attribute bag value indicates that the information should no longer be used if the age is greater than the specified time in seconds see 7 section 13.2.3 for how to calculate the age a max-age attribute bag cannot be used to force the recipient to discard the policy information its semantics apply only to the caching mechanism of policy information. 5.3 extra parameters the params attribute bag can be used to include additional information about the extension or modifiers on the use of the extension. the params values may or may not be case-sensitive depending on the semantics of the parameter name. the params attribute bag is defined as a generic bag structure which may be nested. no default parameters are defined. note pep implementations should pass any parameters to the module or modules handling the particular extension as this may have impact the use of the extension. 5.4 end-to-end policies end-to-end policies must be transmitted to the ultimate recipient of a message. the pep-info header field is an end-to-end header and is defines as follows pep-info pep-info 1#policy-decl for example http 1.1 200 ok content-type text html content-length 412 pep-info id http some.org payment-extension for cgi-bin buy strength must doctype html public w3c dtd html 3.2 en html proxies may under certain conditions act as the ultimate recipients of extension policies on behalf of user agents and origin servers see section 9.1 5.5 hop-by-hop policies hop-by-hop policies are meaningful only for a single transport-level connection. the c-pep-info header field is a hop-by-hop header field and must not be communicated by proxies over further connections. the c-pep-info header has the following grammar c-pep-info c-pep-info 1#policy-decl for example http 1.1 420 policy not fulfilled c-pep-info id http some.org provide-stats for connection c-pep-info in http the c-pep-info header field must be protected by a connection header by including c-pep-info as a connection header directive. the directive must be handled according to the http 1.1 specification of the connection header see section 10.2 and 7 section 14.10 an agent must not send the c-pep-info header field to an http 1.0 proxy as it does not obey the http 1.1 rules for parsing the connection header field see 7 section 19.7.1 6. publishing an extension while the protocol extension definition should be published at the address of the extension identifier this is not a requirement of this specification. the only absolute requirement is that distinct names be used for distinct semantics. for example one way to achieve this is to use a mid cid or uuid uri. the association between the extension identifier and the specification might be made by distributing a specification which references the extension identifier. it is strongly recommended that the integrity and persistence of the extension identifier is maintained and kept unquestioned throughout the lifetime of the extension. care should be taken not to distribute conflicting specifications that reference the same name. even when a uri is used to publish extension specifications care must be taken that the specification made available at that address does not change significantly over time. one agent may associate the identifier with the old semantics and another might associate it with the new semantics. the extension definition may be made available in different representations ranging from a human-readable specification defining the extension semantics downloadable code which implements the semantics defined by the extension a formal interface description provided by the extension to a machine-readable specification defining the extension semantics. for example a software component that implements the specification may reside at the same address as a human-readable specification distinguished by content negotiation the human-readable representation serves to document the extension and encourage deployment while the software component allows clients and servers to be dynamically extended. 7. binding http requests an http request is called a binding request if it includes at least one pep extension declaration of strength must an http server must not return a 2xx status-code without obeying all extension declaration s of strength must in a binding request. this section describes how the binding request mechanism in pep interacts with existing http applications. in 7 section 7.1 it is stated that unrecognized header fields should be ignored by the recipient and must be forwarded by proxies. hence using a pep or a c-pep extension declaration is not sufficient to evoke the correct behavior from existing http agents in a binding request. however in 7 section 5.1.1 method it is said that servers should return 501 not implemented if the method is unrecognized or not implemented by the server. a similar statement is made in 5 section 9.5. it is therefore safe to assume that using the method name will produce the correct result from existing http servers and proxies. pep uses the http request method name to extend existing http 1.1 methods and to introduce new methods see section 1.3 in both cases a binding http request invalidates cached entries as described in 7 section 13.10. responses to binding requests are not cachable. 7.1 extending existing http methods the method name of all http 1.1 requests containing a pep extension declaration of strength must that semantically extends that method must be prefixed by pep- see section 10.1 for example a client might express the binding rights-management constraints in an http put request as follows pep-put a-resource http 1.1 pep map http www.w3.org pep rights-management 8- strength must 8-copyright http www.w3.org copyright.html 8-contributions http www.w3.org patches.html host www.w3.org content-length 1203 content-type text html doctype html the ultimate recipient of a binding http request with the pep- prefix on the method name must process the request by performing the following actions in the order they occur identify all extension declarations both hop-by-hop and end-to-end of strength must the server may ignore declarations of strength may without affecting the result of the transaction evaluate and process the extensions identified in 1 in the order they were declared see section 4.3 and 4.4 or if the extension declarations do not match the policy for accessing the resource then respond with a 420 policy not fulfilled status-code see section 8.1 strip the pep- prefix from the method name and process the reminder of the request according to the semantics of the existing http 1.1 method name as defined in 7 the pep- prefix is reserved by pep and must not be used by other http extensions. 7.2 adding new http methods the pep method can be used for all pep extension declarations of strength must that do not naturally extend existing http 1.1 methods. such methods can be address space manipulation extensions like move and copy for example pep source.html http 1.1 pep map http www.w3.org dav move 4- strength must 4-destination destination.html host some.host the pep method indicates that the semantics of this request are defined by one or more pep extension declarations of strength must included in the request. the pep method does not have any http message semantics besides being a placeholder for pep extension declarations and hence all other semantics must be defined by the declaration s included in the request. the ultimate recipient of a pep request must process the request by doing the following identify all extension declarations both hop-by-hop and end-to-end of strength must the server may ignore declarations of strength may without affecting the result of the transaction evaluate and process the extensions identified in 1 in the order they were declared see section 4.3 and 4.4 or if the extension declarations do not match the policy for accessing the resource then respond with a 420 policy not fulfilled status-code see section 8.1 a successful response should be 200 ok if the response includes an entity 202 accepted if the action has not yet been enacted or 204 no content if the response is ok but does not include an entity. if no extension declarations have strength must the response should be 400 bad request the pep method is reserved by pep and must not be used by other http extensions. 8. http status codes pep introduces two new status codes in addition to the ones already defined by http 1.1 7 each status-code is described below including a description the metainformation required in the response. 8.1 420 policy not fulfilled the policy for accessing the resource has not been met in the request. the response must include a pep-info or a c-pep-info header field specifying the extensions required by the publishing party for accessing the resource. the server may use the for attribute bag to indicate whether the policy applies to other resources. the client may repeat the request using the appropriate extension s if the initial request already included the extensions requested in the 420 response then the response indicates that access has been refused for those extension declarations. if the 420 response contains the same set of extension policies as the prior response then the client may present any entity included in the response to the user since that entity may include relevant diagnostic information. implementers may note the similarity to the way authentication challenges are issued with the 401 unauthorized status-code see 7 section 10.4.2 8.2 421 bad mapping the mappings indicated by one or more map attribute bags in the request were not unique and mapped the same header field more than once. the client may repeat the request using a new set of mappings if it believes that it can find a unique set of header fields for which the transaction will succeed. 9. http proxy servers this section describes the role of caching and non-caching proxies and how they interact with pep extensions. normally the ultimate recipient of an end-to-end extension declaration or an end-to-end extension policy is an origin server or a user agent. in this case a proxy must forward all components of the extension including declarations policies headers and any methods and status codes defined by this specification. in other cases however intermediate caching and non-caching proxies may be authorized to act on behalf of origin servers and or user agents. how such an agreement is reached between a party representing the proxy and the party on which behalf it can act is outside the scope of pep but for example the parties may be within the same trust domain. 9.1 proxy servers as end-to-end recipients 9.1.1 proxy servers acting on behalf of user agents in case a proxy is authorized to act as the ultimate recipient on behalf of its proxy clients on end-to-end extensions it must obey the following rules the proxy should remove the extension declaration s and any header fields that are part of these declaration s on which it can act authoritatively before forwarding the response to the proxy client it should issue extension policies for the extensions on which it can act authoritatively as if it was a user agent if an extension declaration added by an http proxy is of strength must the proxy must either prepend the pep- method name prefix or use the pep method instead of the method name used in the proxy client request before forwarding the response to the origin server see section 7.1 an example of a proxy acting on behalf of one or more user agents is an elementary school wishing to enforce a certain policy for accessing information on the internet. the local school proxy can act authoritatively as a retrieval filter on behalf of the pupils instead of having distributed filtering enabled on each of the user agents using the client. 9.1.2 proxy servers acting on behalf of origin servers in case a proxy is authorized to act as the ultimate recipient on behalf of an origin server on end-to-end extensions it must obey the following rules the proxy should remove the extension declaration s and any header fields that are part of these declaration s on which it can act authoritatively before forwarding the request to the origin server it should issue extension policies for the extensions on which it can act authoritatively as if it was an origin server if an extension declaration added by an http proxy is of strength must and there are no other extension declarations of strength must in the request the proxy must remove any pep- method name prefix before forwarding the request to the origin server see section 7.1 if a request uses the pep method the proxy must not forward the request to the origin server unless the communication between the proxy and the origin server can be completed using an existing http 1.1 method. an example of a proxy acting on behalf of an origin server is a corporation having a subscription on an on-line journal. all access to the origin server goes through the corporate firewall that runs a caching proxy server. the organization reports to the publisher of the journal on a monthly basis at which point the subscription is re-evaluated. in the day-to-day access the proxy has the authority to act authoritatively on behalf of the origin server registering usage of the journal. 9.2 proxy servers and repeated hop-by-hop extensions if a pep extension is to be used on parts of a message path including user agents origin servers and proxies not covered by end-to-end or hop-by-hop extension declarations it can be defined as a repeated hop-by-hop extension. this can for example be the case for a proxy extension applied to a subset of proxies in a message path. it is for the designer of the extension to decide whether it can repeat itself on a hop-by-hop basis. in other words any scope more complex than a hop-by-hop or an end-to-end scope is a property of the extension and is transparent to pep. 10. practical considerations for http this section describes some practical considerations intended for pep extended http applications. the issues described may not apply to other information retrieval protocols. 10.1 interaction with existing http 1.1 methods extension designers should consider whether an extension is to work with existing http 1.1 methods using the pep- method token prefix or with the pep method see section 7.1 and 7.2 this specification does not provide an absolute rule for when to use the pep method compared to the pep- method token prefix except that the pep- method token prefix is required in situations where intermediate proxies may act authoritatively on behalf of origin servers or user agents see section 9.1.1 and 9.1.2 in case the extension can be used with existing methods then it should be considered whether the extension can be used with any of the existing http 1.1 methods or only a subset of them. some http 1.1 methods follow the convention of being safe to the requester meaning that they should never have the significance of taking an action other than retrieval see 7 section 9.1 this is for example the case of the get and the head method. as pep extension declarations of strength must explicitly modify or replace the method name existing http applications will never be able to mistake a pep enabled message for any of the existing http messages indicated as being safe. some extensions may have the property of idempotence in that aside from error or expiration issues the side effects of n 0 identical extended requests is the same as for a single extended request. if this is not the case for a pep extension then it should consider whether it wants to 1 disable itself on repeated requests and or 2 inform a user about the behavior of repeating identical requests with this extension. 10.2 interaction with existing http 1.1 headers designers of extensions to be used within the http messaging model should consider the interaction with existing http 1.1 headers. especially it should be noted that pep is designed to be compatible with http 1.0 5 inasmuch as http 1.1 is compatible with http 1.0 see 7 section 19.7 the connection header as described in 7 section 14.10 allows the sender to specify options that are desired for that particular transport connection only. all pep hop-by-hop extension declarations and policies along with any header fields introduced by extension declarations must be included as connection header directives. pep applications must not send any hop-by-hop extension declarations or policies to http 1.0 proxies as they do not obey the rules of http 1.1 for parsing the connection header field see also 7 section 19.7.1 the upgrade header 7 section 14.41 allows the client to specify what additional communication protocols it supports and would like to use if the server finds it appropriate to switch protocols. pep provides the same functionality but without the need for a central registry of protocol names. pep compliant agents may use the 101 switching protocols status code to switch to http-based protocols and protocols which once initiated run completely independently of http. the content coding values in the content-encoding header as described in 7 section 14.12 indicate an encoding transformation that has been applied to an entity. pep provides the same functionality but without the need for a central registry of content codings. as both content codings and pep extension declarations are ordered using both may lead to ambiguous situations. simultaneous use of both mechanisms is therefore strongly discouraged. an origin server can explicitly prevent intermediaries from applying a content-encoding to a resource by using the no-transform cache-control directive see 7 section 14.9.4 10.3 server initiated extension declarations pep extension declarations can be generated by servers as well as clients. if a pep compliant server sends a response with an extension declaration referring to an extension that modifies the message in such a way that the message can not be decoded without using the extension and the corresponding request was either received from a client whose version is lower than http 1.1 or received with a via header field indicating that it was forwarded by a proxy whose version is lower than http 1.1 and the response does not already include an expires header then the sender should include an expires header field whose field-value is identical to the field-value of its date header field see 7 section 14.12 if all agents in the message path are http 1.1 then the sender should use the cache-control header field instead of the expires header field to mark the entity uncachable. 11. security considerations the for parameter allows one party to give information about the extensions used by another party s resources. the parties may provide resources on different servers or at different addresses on the same server. while distinguishing between the parties responsible for different resources at the same server may be infeasible clients should ignore information given by one server about another unless they have reason to trust it or reason to believe that trusting it will have no significant negative consequences. dynamic installation of extension facilities as described in the introduction involves software written by one party the provider of the implementation to be executed under the authority of another the party operating the host software this opens the host party to a variety of trojan horse attacks by the provider or a malicious third party that forges implementations under a provider s name. see for example rfc2046 6 section 4.5.2 for a discussion of these risks. 12. normative references 1 d. h. crocker. standard for the format of arpa internet text messages std 11 rfc 822 udel august 1982 2 t. berners-lee universal resource identifiers in www. a unifying syntax for the expression of names and addresses of objects on the network as used in the world-wide web rfc 1630 cern june 1994. 3 t. berners-lee l. masinter m. mccahill. uniform resource locators url rfc 1738 cern xerox parc university of minnesota december 1994. 4 r. fielding relative uniform resource locators rfc 1808 uc irvine june 1995. 5 t. berners-lee r. fielding h. frystyk hypertext transfer protocol http 1.0 rfc 1945 w3c mit uc irvine w3c mit may 1996. 6 n. freed n. borenstein multipurpose internet mail extensions mime part two media types rfc 2046 innosoft first virtual november 1996. 7 r. fielding j. gettys j. c. mogul h. frystyk t. berners-lee hypertext transfer protocol http 1.1 rfc 2068 u.c. irvine dec w3c mit dec w3c mit w3c mit january 1997 8 d. kristol l. montulli http state management mechanism rfc 2109 bell laboratories lucent technologies netscape communications february 1997 9 s. bradner key words for use in rfcs to indicate requirement levels rfc 2119 harvard university march 1997 10 j. c. mogul r. fielding j. gettys h. frystyk use and interpretation of http version numbers internet draft rfc 2145 dec u.c. irvine dec w3c mit w3c mit http working group may 1997. 11 o. lassila r. swick resource description framework rdf model and syntax w3c nokia w3c w3c working draft october 1997. this is work in progress 12 h. schulzrinne a. rao r. lanphier real time streaming protocol rtsp internet draft draft-ietf-mmusic-rtsp-05 columbia u. netscape progressive networks march 1997. this is work in progress 13 t. berners-lee r. fielding l. masinter uniform resource locators url internet draft draft-fielding-url-syntax-09 w3c mit u.c. irvine xerox corporation may 1997. this is work in progress 13. bibliography informative references 14 d. eastlake universal payment preamble internet draft draft-eastlake-universal-payment-03 cybercash march 1996. this is work in progress. 15 d. m. kristol a proposed extension mechanism for http internet draft draft-kristokl-http-extensions-00 january 1995. document expired. 16 jepi selecting payment mechanisms over http internet draft draft-khare-jepi-uppflow-00 w3c august 1996. document expired. 17 j. miller et al pics label syntax and communication protocols version 1.1 w3c recommendation rec-pics-labels w3c 31 october 1996 18 y. goland et al extensions for distributed authoring and versioning internet draft draft-jensen-webdav-ext-01 26 march 1997. this is work in progress. 19 n. borenstein a user agent configuration mechanism for multimedia mail format information rfc 1524 pp. 12 bellcore september 1993. 20 j. klensin n. freed m. rose e. stefferud and d. crocker. smtp service extensions rfc 1869 mci innosoft dover beach consulting network management associates brandenburg consulting november 1995. 21 d. robinson the www common gateway interface version 1.1 internet draft draft-robinson-www-interface-01 february 1996. document expired. 22 a. baird-smith jigsaw an object oriented server w3c note june 1996 23 h. frystyk libwww architecture december 1996 24 r. thau design considerations for the apache server api fifth international world wide web conference may 6-10 1996 paris france 25 netscape corporation the netscape server api 26 microsoft corporation internet server api documentation 27 open market inc fastcgi restoring all cgi s good properties and then some 28 spyglass spyglass microserver application development interface 29 j. franks wn a server for the http 30 roxen introduction to roxen challenger 14. acknowledgements the pep protocol is the product of a substantial amount of investigation and collaboration. dave kristol did some of the first writing on http extension mechanisms 15 jim miller and dave raggett sketched out an initial design which rohit khare wrote up in a number of drafts. tim berners-lee anselm baird-smith paul leach and daniel dardailler deserve special recognition for their efforts in commenting in the design phase of the protocol. also thanks to henning schulzrinne anup rao and robert lanphier for pointing out the generalities of pep and providing support for integration with rtsp 12 this specification is a direct reflection of some implementation work a client implementation in 23 see the htpep module and a server implementation by eui-suk chung and anit chakraborty for the jepi project. this document has benefited greatly from the comments of all those participating in the http-wg. in addition to those already mentioned the following individuals have contributed to this specification eui-suk chung don eastlake roy fielding jim gettys yaron goland phill hallam-baker paul hoffman koen holtman ora lassila larry masinter and jim whitehead 15. authors addresses dan connolly architecture domain lead world wide web consortium mit laboratory for computer science 545 technology square cambridge ma 02139 u.s.a. email connolly@w3.org rohit khare technical staff world wide web consortium mit laboratory for computer science 545 technology square cambridge ma 02139 u.s.a. email khare@w3.org henrik frystyk nielsen technical staff world wide web consortium mit laboratory for computer science 545 technology square cambridge ma 02139 u.s.a. email frystyk@w3.org eric prud hommeaux contractor world wide web consortium mit laboratory for computer science 545 technology square cambridge ma 02139 u.s.a. email eric@w3.org appendices 16. summary of pep interactions the following tables summarize the outcome of strength and scope rules in pep transactions involving pep compliant and non-pep compliant http proxies and origin servers. the summary is intended as a guide and index to the text but is necessarily cryptic and incomplete. this summary should never be used or referenced separately from the complete pep specification. the tables should be read as follows standard processing the action taken by an ultimate recipient not understanding or ignoring the extension see section 4.2 extended processing the action taken by an ultimate recipient understanding and obeying the extension see section 4.2 forward extension the action taken by an intermediate party which is not an ultimate recipient see section 9 strip extension the action taken by an intermediate party which is the ultimate recipient see section 9 420 policy not fulfilled the response from an ultimate recipient not understanding or not wishing to obey the extension see section 8.1 501 not implemented the response from an ultimate recipient not understanding the pep method or pep- method token prefix see section 6 table 1 origin server scope hop-by-hop end-to-end strength optional may required must optional may required must pep not supported standard processing 501 not implemented standard processing 501 not implemented extension not supported standard processing 420 policy not fulfilled standard processing 420 policy not fulfilled extension supported extended processing extended processing extended processing extended processing table 2 proxy server scope hop-by-hop end-to-end strength optional may required must optional may required must pep not supported strip extension 501 not implemented forward extension 501 not implemented extension not supported strip extension 420 policy not fulfilled forward extension forward extension extension supported extended processing and strip extended processing and strip extended processing and strip extended processing and strip 17. examples the following examples show various scenarios using pep in http 1.1 requests and responses. information not essential for illustrating the examples is left out referred to as 17.1 client queries server for dav in this example the purpose of using pep in the request is to determine whether a server understands and supports the distributed authoring and versioning dav protocol extension 18 by making the request binding see section 7 the client forces the server to process the extension declaration and obey the extension or report an error. pep-get some.url http 1.1 host some.host pep map http www.w3.org pep dav http 1.1 200 ok pep-info id http www.w3.org pep dav for henrik the response shows that the server does understand dav and that the client can use it on all resources matching the prefix henrik on that server. the policy is informational and other factors like access control may prevent the client from actually using dav on any of these resources. pep does not distinguish between querying about or using an extension the pep declaration is identical. whether it in fact is a query may depend on the request method name and request modifiers. 17.2 client informs server about zipflate compression extension this example shows a client informing a server that it is capable of handling the zipflate compression extension in a response. by issuing an extension policy instead of an extension declaration the client indicates that the extension is not used in the request. get index http 1.1 host some.host pep-info id http www.w3.org pep encoding http 1.1 200 ok pep map http www.w3.org pep encoding cache-control no-transform vary the response shows that the server knows the extension and decides to use it in the response. it furthermore includes the no-transform cache-control directive in order to avoid that proxies add their own content-coding to the message see section 10.2 and a vary header field indicating that a cache may not use the response to reply to a subsequent request without revalidation. in this example the client could have used an extension declaration of strength may instead of an extension policy to achieve the same effect. the request would not have been affected as the compression applies to message bodies and not headers. if the request were to include a message body however the difference would be whether the zipflate extension was applied to that body or not. 17.3 server uses content-digest extension this example shows a server applying the content-digest extension to a response message indicating that the client may ignore it. the client has not indicated whether it supports the extension or even if it supports pep. get index http 1.1 host some.host http 1.1 200 ok pep map http www.w3.org pep digest 4- 4-content-digest a0b1c2d3e4f5g6h7i8j9 cache-control max-age 3600 the response is fully cachable and does not require revalidation when replying to subsequent requests. 17.4 server requires client to use payment extension the last example shows how a server requires a client to use a micro-payment extension in order to access a resource causing an additional roundtrip using the 420 policy not fulfilled status code see section 8.1 the first request does not contain any pep constructs leading to the error message. a non-pep compliant client will treat this as a 400 bad request status code and will not be able to fulfill the server s requirement in a second request see 7 section 10.4.1 get index http 1.1 host some.host 420 policy not fulfilled pep-info id http www.w3.org pep minipayment params price 0.02usd strength must pep-get index http 1.1 host some.host pep map http www.w3.org pep minipayment 12- strength must 12-price 0.02usd http 1.1 200 ok the actual price is passed as an extra parameter in the extension policy. the client agrees to the price and issues a new request containing the proper extension declaration. if it did not agree with the price it could have tried a lower price and depending on the policy of that resource the server may have responded positively. copyright 1998 w3c mit inria keio all rights reserved. w3c liability trademark document use and software licensing rules apply. 