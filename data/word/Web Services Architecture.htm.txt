web services architecture web services architecture w3c working group note 11 february 2004 this version http www.w3.org tr 2004 note-ws-arch-20040211 latest version http www.w3.org tr ws-arch previous version http www.w3.org tr 2003 wd-ws-arch-20030808 editors david booth w3c fellow hewlett-packard hugo haas w3c francis mccabe fujitsu labs of america eric newcomer until october 2003 iona michael champion until march 2003 software ag chris ferris until march 2003 ibm david orchard until march 2003 bea systems this document is also available in these non-normative formats postscript version and pdf version. copyright 2004 w3c mit ercim keio all rights reserved. w3c liability trademark document use and software licensing rules apply. abstract this document defines the web services architecture. it identifies the functional components and defines the relationships among those components to effect the desired properties of the overall architecture. status of this document this section describes the status of this document at the time of its publication. other documents may supersede this document. a list of current w3c publications and the latest revision of this technical report can be found in the w3c technical reports index at http www.w3.org tr this is a public working group note produced by the w3c web services architecture working group which is part of the w3c web services activity. this publication as a working group note coincides with the end of the working group s charter period and represents the culmination of the group s work. discussion of this document is invited on the public mailing list www-ws-arch@w3.org public archives a list of remaining open issues is included in 4 conclusions. patent disclosures relevant to this specification may be found on the working group s patent disclosure page. publication as a working group note does not imply endorsement by the w3c membership. this is a draft document and may be updated replaced or obsoleted by other documents at any time. it is inappropriate to cite this document as other than work in progress. other documents may supersede this document. table of contents 1 introduction 1.1 purpose of the web service architecture 1.2 intended audience 1.3 document organization 1.4 what is a web service 1.4.1 agents and services 1.4.2 requesters and providers 1.4.3 service description 1.4.4 semantics 1.4.5 overview of engaging a web service 1.5 related documents 2 concepts and relationships 2.1 introduction 2.2 how to read this section 2.2.1 concepts 2.2.2 relationships 2.2.3 concept maps 2.2.4 model 2.2.5 conformance 2.3 the architectural models 2.3.1 message oriented model 2.3.1.1 address 2.3.1.2 delivery policy 2.3.1.3 message 2.3.1.4 message body 2.3.1.5 message correlation 2.3.1.6 message envelope 2.3.1.7 message exchange pattern mep 2.3.1.8 message header 2.3.1.9 message receiver 2.3.1.10 message reliability 2.3.1.11 message sender 2.3.1.12 message sequence 2.3.1.13 message transport 2.3.2 the service oriented model 2.3.2.1 action 2.3.2.2 agent 2.3.2.3 choreography 2.3.2.4 capability 2.3.2.5 goal state 2.3.2.6 provider agent 2.3.2.7 provider entity 2.3.2.8 requester agent 2.3.2.9 requester entity 2.3.2.10 service 2.3.2.11 service description 2.3.2.12 service interface 2.3.2.13 service intermediary 2.3.2.14 service role 2.3.2.15 service semantics 2.3.2.16 service task 2.3.3 the resource oriented model 2.3.3.1 discovery 2.3.3.2 discovery service 2.3.3.3 identifier 2.3.3.4 representation 2.3.3.5 resource 2.3.3.6 resource description 2.3.4 the policy model 2.3.4.1 audit guard 2.3.4.2 domain 2.3.4.3 obligation 2.3.4.4 permission 2.3.4.5 permission guard 2.3.4.6 person or organization 2.3.4.7 policy 2.3.4.8 policy description 2.3.4.9 policy guard 2.4 relationships 2.4.1 the is a relationship 2.4.1.1 definition 2.4.1.2 relationships to other elements 2.4.1.3 explanation 2.4.2 the describes relationship 2.4.2.1 definition 2.4.2.2 relationships to other elements 2.4.2.3 explanation 2.4.3 the has a relationship 2.4.3.1 definition 2.4.3.2 relationships to other elements 2.4.3.3 explanation 2.4.4 the owns relationship 2.4.4.1 definition 2.4.4.2 relationships to other elements 2.4.4.3 explanation 2.4.5 the realized relationship 2.4.5.1 definition 2.4.5.2 relationships to other elements 2.4.5.3 explanation 3 stakeholder s perspectives 3.1 service oriented architecture 3.1.1 distributed systems 3.1.2 web services and architectural styles 3.1.3 relationship to the world wide web and rest architectures 3.2 web services technologies 3.2.1 xml 3.2.2 soap 3.2.3 wsdl 3.3 using web services 3.4 web service discovery 3.4.1 manual versus autonomous discovery 3.4.2 discovery registry index or peer-to-peer 3.4.2.1 the registry approach 3.4.2.2 the index approach 3.4.2.3 peer-to-peer p2p discovery 3.4.2.4 discovery service trade-offs 3.4.3 federated discovery services 3.4.4 functional descriptions and discovery 3.5 web service semantics 3.5.1 message semantics and visibility 3.5.2 semantics of the architectural models 3.5.3 the role of metadata 3.6 web services security 3.6.1 security policies 3.6.2 message level security threats 3.6.2.1 message alteration 3.6.2.2 confidentiality 3.6.2.3 man-in-the-middle 3.6.2.4 spoofing 3.6.2.5 denial of service 3.6.2.6 replay attacks 3.6.3 web services security requirements 3.6.3.1 authentication mechanisms 3.6.3.2 authorization 3.6.3.3 data integrity and data confidentiality 3.6.3.4 integrity of transactions and communications 3.6.3.5 non-repudiation 3.6.3.6 end-to-end integrity and confidentiality of messages 3.6.3.7 audit trails 3.6.3.8 distributed enforcement of security policies 3.6.4 security consideration of this architecture 3.6.4.1 cross-domain identities 3.6.4.2 distributed policies 3.6.4.3 trust policies 3.6.4.4 secure discovery mechanism 3.6.4.5 trust and discovery 3.6.4.6 secure messaging 3.6.5 privacy considerations 3.7 peer-to-peer interaction 3.8 web services reliability 3.8.1 message reliability 3.8.2 service reliability 3.8.3 reliability and management 3.9 web service management 3.10 web services and edi transaction tracking 3.10.1 when something goes wrong 3.10.2 the need for tracking 3.10.3 examples of tracking 3.10.4 requirements for effective tracking 3.10.5 tracking and uris 4 conclusions 4.1 requirements analysis 4.2 value of this work 4.3 significant unresolved issues appendices a overview of web services specifications non-normative b an overview of web services security technologies non-normative b.1 xml-signature and xml-encryption b.2 web services security b.3 xml key management specification xkms 2.0 b.4 security assertion markup language saml b.5 xacml communicating policy information b.6 identity federation c references non-normative d acknowledgments non-normative 1 introduction 1.1 purpose of the web service architecture web services provide a standard means of interoperating between different software applications running on a variety of platforms and or frameworks. this document wsa is intended to provide a common definition of a web service and define its place within a larger web services framework to guide the community. the wsa provides a conceptual model and a context for understanding web services and the relationships between the components of this model. the architecture does not attempt to specify how web services are implemented and imposes no restriction on how web services might be combined. the wsa describes both the minimal characteristics that are common to all web services and a number of characteristics that are needed by many but not all web services. the web services architecture is an interoperability architecture it identifies those global elements of the global web services network that are required in order to ensure interoperability between web services. 1.2 intended audience this document is intended for a diverse audience. expected readers include web service specification authors creators of web service software people making decisions about web service technologies and others. 1.3 document organization this document has two main sections a core concepts section 2 concepts and relationships and a stakeholder s perspectives section 3 stakeholder s perspectives 2 concepts and relationships provides the bulk of the conceptual model on which conformance constraints could be based. for example the resource concept states that resources have identifiers in fact they have uris using this assertion as a basis we can assess conformance to the architecture of a particular resource by looking for its identifier. if in a given instance of this architecture a resource has no identifier then it is not a valid instance of the architecture. while the concepts and relationships represent an enumeration of the architecture the stakeholders perspectives approaches from a different viewpoint how the architecture meets the goals and requirements. in this section we elucidate the more global properties of the architecture and demonstrate how the concepts actually achieve important objectives. a primary goal of the stakeholder s perspectives section is to provide a top-down view of the architecture from various perspectives. for example in the 3.6 web services security section we show how the security of web services is addressed within the architecture. the aim here is to demonstrate that web services can be made secure and indicate which key concepts and features of the architecture achieve that goal. the key stakeholder s perspectives supported in this document reflect the major goals of the architecture itself interopability extensibility security web integration implementation and manageability. 1.4 what is a web service for the purpose of this working group and this architecture and without prejudice toward other definitions we will use the following definition definition a web service is a software system designed to support interoperable machine-to-machine interaction over a network. it has an interface described in a machine-processable format specifically wsdl other systems interact with the web service in a manner prescribed by its description using soap messages typically conveyed using http with an xml serialization in conjunction with other web-related standards. 1.4.1 agents and services a web service is an abstract notion that must be implemented by a concrete agent. see figure 1-1 the agent is the concrete piece of software or hardware that sends and receives messages while the service is the resource characterized by the abstract set of functionality that is provided. to illustrate this distinction you might implement a particular web service using one agent one day perhaps written in one programming language and a different agent the next day perhaps written in a different programming language with the same functionality. although the agent may have changed the web service remains the same. 1.4.2 requesters and providers the purpose of a web service is to provide some functionality on behalf of its owner a person or organization such as a business or an individual. the provider entity is the person or organization that provides an appropriate agent to implement a particular service. see figure 1-1 basic architectural roles. a requester entity is a person or organization that wishes to make use of a provider entity s web service. it will use a requester agent to exchange messages with the provider entity s provider agent. in most cases the requester agent is the one to initiate this message exchange though not always. nonetheless for consistency we still use the term requester agent for the agent that interacts with the provider agent even in cases when the provider agent actually initiates the exchange. note a word on terminology many documents use the term service provider to refer to the provider entity and or provider agent. similarly they may use the term service requester to refer to the requester entity and or requester agent. however since these terms are ambiguous sometimes referring to the agent and sometimes to the person or organization that owns the agent this document prefers the terms requester entity provider entity requester agent and provider agent. in order for this message exchange to be successful the requester entity and the provider entity must first agree on both the semantics and the mechanics of the message exchange. this is a slight simplification that will be explained further in 3.3 using web services. 1.4.3 service description the mechanics of the message exchange are documented in a web service description wsd see figure 1-1 the wsd is a machine-processable specification of the web service s interface written in wsdl. it defines the message formats datatypes transport protocols and transport serialization formats that should be used between the requester agent and the provider agent. it also specifies one or more network locations at which a provider agent can be invoked and may provide some information about the message exchange pattern that is expected. in essence the service description represents an agreement governing the mechanics of interacting with that service. again this is a slight simplification that will be explained further in 3.3 using web services. 1.4.4 semantics the semantics of a web service is the shared expectation about the behavior of the service in particular in response to messages that are sent to it. in effect this is the contract between the requester entity and the provider entity regarding the purpose and consequences of the interaction. although this contract represents the overall agreement between the requester entity and the provider entity on how and why their respective agents will interact it is not necessarily written or explicitly negotiated. it may be explicit or implicit oral or written machine processable or human oriented and it may be a legal agreement or an informal non-legal agreement. once again this is a slight simplification that will be explained further in 3.3 using web services. while the service description represents a contract governing the mechanics of interacting with a particular service the semantics represents a contract governing the meaning and purpose of that interaction. the dividing line between these two is not necessarily rigid. as more semantically rich languages are used to describe the mechanics of the interaction more of the essential information may migrate from the informal semantics to the service description. as this migration occurs more of the work required to achieve successful interaction can be automated. 1.4.5 overview of engaging a web service there are many ways that a requester entity might engage and use a web service. in general the following broad steps are required as illustrated in figure 1-1 1 the requester and provider entities become known to each other or at least one becomes know to the other 2 the requester and provider entities somehow agree on the service description and semantics that will govern the interaction between the requester and provider agents 3 the service description and semantics are realized by the requester and provider agents and 4 the requester and provider agents exchange messages thus performing some task on behalf of the requester and provider entities. i.e. the exchange of messages with the provider agent represents the concrete manifestation of interacting with the provider entity s web service. these steps are explained in more detail in 3.4 web service discovery. some of these steps may be automated others may be performed manually. figure 1-1. the general process of engaging a web service 1.5 related documents the working group produced the following companion documents in the process of defining this architecture requirements document wsa reqs usage scenarios wsaus glossary ws glossary owl ontology owlo 2 concepts and relationships 2.1 introduction the formal core of the architecture is this enumeration of the concepts and relationships that are central to web services interoperability. 2.2 how to read this section the architecture is described in terms of a few simple elements concepts relationships and models. concepts are often noun-like in that they identify things or properties that we expect to see in realizations of the architecture similarly relationships are normally linguistically verbs. as with any large-scale effort it is often necessary to structure the architecture itself. we do this with the larger-scale meta-concept of model. a model is a coherent portion of the architecture that focuses on a particular theme or aspect of the architecture. 2.2.1 concepts a concept is expected to have some correspondence with any realizations of the architecture. for example the message concept identifies a class of object not to be confused with objects and classes as are found in object oriented programming languages that we expect to be able to identify in any web services context. the precise form of a message may be different in different realizations but the message concept tells us what to look for in a given concrete system rather than prescribing its precise form. not all concepts will have a realization in terms of data objects or structures occurring in computers or communications devices for example the person or organization refers to people and human organizations. other concepts are more abstract still for example message reliability denotes a property of the message transport service a property that cannot be touched but nonetheless is important to web services. each concept is presented in a regular stylized way consisting of a short definition an enumeration of the relationships with other concepts and a slightly longer explanatory description. for example the concept of agent includes as relating concepts the fact that an agent is a computational resource has an identifier and an owner. the description part of the agent explains in more detail why agents are important to the archicture. 2.2.2 relationships relationships denote associations between concepts. grammatically relationships are verbs or more accurately predicates. a statement of a relationship typically takes the form concept predicate concept. for example in agent we state that an agent is a computational resource this statement makes an assertion in this case about the nature of agents. many such statements are descriptive others are definitive a message has a message sender such a statement makes an assertion about valid instances of the architecture we expect to be able to identify the message sender in any realization of the architecture. conversely any system for which we cannot identify the sender of a message is not conformant to the architecture. even if a service is used anonymously the sender has an identifier but it is not possible to associate this identifier with an actual person or organization. 2.2.3 concept maps many of the concepts in the architecture are illustrated with concept maps. a concept map is an informal graphical way to illustrate key concepts and relationships. for example the diagram figure 2-1. concept map shows three concepts which are related in various ways. each box represents a concept and each arrow or labeled arc represents a relationship. the merit of a concept map is that it allows rapid navigation of the key concepts and illustrates how they relate to each other. it should be stressed however that these diagrams are primarily navigational aids the written text is the definitive source. 2.2.4 model a model is a coherent subset of the architecture that typically revolves around a particular aspect of the overall architecture. although different models share concepts it is usually from different points of view the major role of a model is to explain and encapsulate a significant theme within the overall web services architecture. for example the message oriented model focuses and explains web services strictly from a message passing perspective. in particular it does not attempt to relate messages to services provided. the service oriented model however lays on top of and extends the message oriented model in order to explain the fundamental concepts involved in service in effect to explain the purpose of the messages in the message oriented model. each model is described separately below in terms of the concepts and relationships inherent to the model. the ordering of the concepts in each model section is alphabetical this should not be understood to imply any relative importance. for a more focused viewpoint the reader is directed to the stakeholder s perspectives section which examines the architecture from the perspective of key stakeholders of the architecture. the reason for choosing an alphabetical ordering is that there is a large amount of cross-referencing between the concepts. as a result it is very difficult if not misleading to choose a non-alphabetic ordering that reflects some sense of priority between the concepts. furthermore the optimal ordering depends very much on the point of view of the reader. hence we devote the stakeholders perspectives section to a number of prioriterized readings of the architecture. 2.2.5 conformance unlike language specifications or protocol specifications conformance to an architecture is necessarily a somewhat imprecise art. however the presence of a concept in this enumeration is a strong hint that in any realization of the architecture there should be a corresponding feature in the implementation. furthermore if a relationship is identified here then there should be corresponding relationships in any realized architecture. the consequence of non-conformance is likely to be reduced interoperability the absence of such a concrete feature may not prevent interoperability but it is likely to make such interoperability more difficult. a primary function of the architecture s enumeration in terms of models concepts and relationships is to give guidance about conformance to the architecture. for example the architecture notes that a message has a message sender any realization of this architecture that does not permit a message to be associated with its sender is not in conformance with the architecture. for example smtp could be used to transmit messages. however since smtp at present allows forgery of the sender s identity smtp by itself is not sufficient to discharge this responsibility. 2.3 the architectural models this architecture has four models illustrated in figure 2-2. each model in figure 2-2 is labeled with what may be viewed as the key concept of that model. figure 2-2. meta model of the architecture the four models are the message oriented model focuses on messages message structure message transport and so on without particular reference as to the reasons for the messages nor to their significance. figure 2-3. simplified message oriented model the essence of the message model revolves around a few key concepts illustrated above the agent that sends and receives messages the structure of the message in terms of message headers and bodies and the mechanisms used to deliver messages. of course there are additional details to consider the role of policies and how they govern the message level model. the abridged diagram shows the key concepts the detailed diagram expands on this to include many more concepts and relationships. the service oriented model focuses on aspects of service action and so on. while clearly in any distributed system services cannot be adequately realized without some means of messaging the converse is not the case messages do not need to relate to services. figure 2-4. simplified service oriented model the service oriented model is the most complex of all the models in the architecture. however it too revolves around a few key ideas. a service is realized by an agent and used by another agent. services are mediated by means of the messages exchanged between requester agents and provider agents. a very important aspect of services is their relationship to the real world services are mostly deployed to offer functionality in the real world. we model this by elaborating on the concept of a service s owner which whether it is a person or an organization has a real world responsibility for the service. finally the service oriented model makes use of meta-data which as described in 3.1 service oriented architecture is a key property of service oriented architectures. this meta-data is used to document many aspects of services from the details of the interface and transport binding to the semantics of the service and what policy restrictions there may be on the service. providing rich descriptions is key to successful deployment and use of services across the internet. the resource oriented model focuses on resources that exist and have owners. figure 2-5. simplified resource oriented model the resource model is adopted from the web architecture concept of resource. we expand on this to incorporate the relationships between resources and owners. the policy model focuses on constraints on the behavior of agents and services. we generalize this to resources since policies can apply equally to documents such as descriptions of services as well as active computational resources. figure 2-6. simplified policy model policies are about resources. they are applied to agents that may attempt to access those resources and are put in place or established by people who have responsibility for the resource. policies may be enacted to represent security concerns quality of service concerns management concerns and application concerns. 2.3.1 message oriented model the message oriented model focuses on those aspects of the architecture that relate to messages and the processing of them. specifically in this model we are not concerned with any semantic significance of the content of a message or its relationship to other messages. however the mom does focus on the structure of messages on the relationship between message senders and receivers and how messages are transmitted. the mom is illustrated in the figure 2-7 figure 2-7. message oriented model 2.3.1.1 address 2.3.1.1.1 definition an address is that information required by a message transport mechanism in order to deliver a message appropriately. 2.3.1.1.2 relationships to other elements an address is information used to describe how and where to deliver messages. an address may be a uri. an address is typically transport mechanism specific. an address may be contained in the message envelope. 2.3.1.1.3 explanation in order for message transport mechanisms to function it is normally necessary to provide information that allows messages to be delivered. this is called the address of the message receiver. typically the form of the address information will depend of the particular message transport. in the case of an http message transport the address information will take the form of a url. the precise method that a message sender uses to convey address information will also depend on the transport mechanism used. on occasion the address information may be provided as additional arguments to the invoking procedure. or the address information may be located within the message itself typically in the message envelope. 2.3.1.2 delivery policy 2.3.1.2.1 definition a delivery policy is a policy that constrains the methods by which messages are delivered by the message transport. 2.3.1.2.2 relationships to other elements delivery policy is a policy delivery policy constrains message transport delivery policy may be expressed in a policy description language delivery policy may express the quality of service associated with delivering a message by a message transport mechanism 2.3.1.2.3 explanation delivery policies are those policies that relate to the delivery of messages. typically a delivery policy applies to the combination of a particular message and a particular message transport mechanism. the policies that apply however may originate from descriptions in the message itself or be intrinsic to the transport mechanism or both. examples of delivery policies include quality of service assurances such as reliable versus best effort message delivery and security assurances such as encrypted versus unencrypted message transport. another kind of delivery policy could take the form of assertions about recording an audit of how the message was delivered. 2.3.1.3 message 2.3.1.3.1 definition a message is the basic unit of data sent from one web services agent to another in the context of web services. 2.3.1.3.2 relationships to other elements a message is a unit of data sent from one agent to another a message may be part of a message sequence a message may be described using a service description language a message has a message sender a message has one or more message recipients a message may have an identifier a message has a message body a message has zero or more message headers a message has a message envelope a message is delivered by a message transport system a message may have a delivery policy associated with it 2.3.1.3.3 explanation a message represents the data structure passed from its sender to its recipients. the structure of a message is defined in a service description. the main parts of a message are its envelope a set of zero or more headers and the message body. the envelope serves to encapsulate the component parts of the message and it serves as a well-known location for message transport services to locate necessary addressing information. the header holds ancillary information about the message and facilitates modular processing. the body of the message contains the message content or uris to the actual data resource. a message can be as simple as an http get request in which the http headers are the headers and the parameters encoded in the url are the content. note that extended web services functionality in this architecture is not supported in http headers. a message can also simply be a plain xml document. however such messages do not support extended web services functionality defined in this architecture. a message can be a soap xml in which the soap headers are the headers. extended web services functionality are supported in soap headers. 2.3.1.4 message body 2.3.1.4.1 definition a message body is the structure that represents the primary application-specific content that the message sender intends to deliver to the message recipient. 2.3.1.4.2 relationships to other elements a message body is contained by the message envelope. a message body is the application-specific content intended for the message recipient. 2.3.1.4.3 explanation the message body provides a mechanism for transmitting information to the recipient of the message. the form of the message body and other constraints on the body may be expressed as part of the service description. in many cases the precise interpretation of the message body will depend on the message headers that are in the message. 2.3.1.5 message correlation 2.3.1.5.1 definition message correlation is the association of a message with a context. message correlation ensures that a requester agent can match the reply with the request especially when multiple replies may be possible. 2.3.1.5.2 relationships to other elements message correlation is a means of associating a message within a specific conversational context. message correlation may be realized by including message identifiers to enable messages to be identified. 2.3.1.5.3 explanation message correlation allows a message to be associated with a particular purpose or context. in a conversation it is important to be able to determine that an actual message that has been received is the expected message. often this is implicit when conversations are relayed over stream-oriented message transports but not all transports allow correlation to be established so implicitly. for situations where correlation must be handled explicitly one technique is to associate a message identifier with messages. the message identifier is an identifier that allows a received message to be correlated with the originating request. the sender may also add an identifier for a service not necessarily the originating sender who will be the recipient of the message see asynchronous messaging correlation may also be realized by the underlying protocol. for example http 1.1 allows one to correlate a request with its response. 2.3.1.6 message envelope 2.3.1.6.1 definition a message envelope is the structure that encapsulates the component parts of a message the message body and the message headers. 2.3.1.6.2 relationships to other elements a message envelope may contain address information about the intended recipients of its associated message a message envelope contains the message body. a message envelope contains the message headers. 2.3.1.6.3 explanation issue message_with_address how is a message associated with its destination address there is an unresolved issue here. a message somehow must be associated with its destination address. this combination of the message with its destination address seems to be a significant architectural concept yet soap does not require that the address be included in the message header. resolution none recorded. the message envelope may contain information needed to actually deliver messages. if so it must at least contain sufficient address information so that the message transport can deliver the message. typically this information is part of the service binding information found in a wsdl document. other metadata that may be present in an envelope includes security information to allow the message to be authenticated and quality of service information. a correctly design message transport mechanism should be able to deliver a message based purely on the information in the envelope. for example an encrypted message that fully protects the identities of the sender recipient as well as the message content may still be delivered using only the address information and the encrypted data stream itself 2.3.1.7 message exchange pattern mep 2.3.1.7.1 definition a message exchanage pattern mep is a template devoid of application semantics that describes a generic pattern for the exchange of messages between agents. it describes relationships e.g. temporal causal sequential etc. of multiple messages exchanged in conformance with the pattern as well as the normal and abnormal termination of any message exchange conforming to the pattern. 2.3.1.7.2 relationships to other elements a message exchange pattern describes a generic pattern for the exchange of messages between agents. a message exchange pattern should have a unique identifier a message exchange pattern may realize message correlation a message exchange pattern may describe a service invocation 2.3.1.7.3 explanation distributed applications in a web services architecture communicate via message exchanges. these message exchanges are logically factored into patterns that may be composed at different levels to form larger patterns. a message exchange pattern mep is a template devoid of application semantics that describes a generic pattern for the exchange of one-way messages between agents. the patterns can be described by state machines that define the flow of the messages including the handling of faults that may arise and the correlation of messages. issue mep_vs_chor what is the difference between an mep and a choreography the precise difference between an mep and a choreography is unresolved. some view meps as being atomic patterns and a choreography as including composition of patterns. also a choreography generally describes patterns that include application semantics choreography meps application semantics whereas an mep is devoid of application semantics. finally there is usually a difference in scale between an mep and a choregraphy a choreography often makes use of meps as building blocks. resolution none recorded. messages that are instances of an mep are correlated either explicitly or implicitly. the exchanges may be synchronous or asynchronous. in order to promote interoperability it is useful to define common meps that are broadly adopted and unambiguously identified. when a mep is described for the purpose of interoperability it should be associated with a uri that will identify that mep. some protocols may natively support certain meps e.g. http natively supports request-response. in other cases there is may be additional glue needed to map meps onto a protocol. web service description languages at the level of wsdl view meps from the perspective of a particular service actor. a simple request-reponse mep for example appears as an incoming message which invokes an operation and an associated outgoing message with a reply. an mep is not necessarily limited to capturing only the inputs and outputs of a single service. consider the pattern agent a uses an instance of an mep possibly request-response to communicate initially with b. agent b then uses a separate but related instance of an mep to communicate with c. agent a uses another instance of an mep to communicate with c but gets a reply only after c has processed 2 this example makes it clear that the overall pattern cannot be described in terms of the inputs and outputs of any single interaction. the pattern involves constraints and relationships among the messages in the various mep instances. it also illuminates the fact that exchange 1 is in in-out mep from the perspective of actor b and mirrored by an out-in mep from the perspective of actor a. finally an actual application instantiates this communication pattern and completes the picture by adding computation at a b and c to carry out application-specific operations. it is instructive to consider the kinds of fault reporting that occur in such a layering. consider a fault at the transport protocol level. this transport level may itself be able to manage certain faults e.g. re-tries but it may also simply report the fault to the binding level. similarly the binding level may manage the fault e.g. by re-initiating the underlying protocol or may report a soap fault. the choreography and application layers may be intertwined or separated depending on how they are architected. there is also no rigid distinction between the choreography and binding layers binding-level meps are essentially simple choreographies. conceptually the choreographic level can enforce constraints on message order maintain state consistency communicate choreographic faults to the application etc. in ways that transcend particular bindings and transports. 2.3.1.8 message header 2.3.1.8.1 definition a message header is the part of the message that contains information about a specific aspect of the message. 2.3.1.8.2 relationships to other elements a message header is contained in a message envelope a message header may be a specific well known types editorial note the is-a relationship here is used in a different way than elsewhere in the document. a message header may identify a service role which denotes the kind of processing expected for the header. a message header may be processed independently of the message body 2.3.1.8.3 explanation message headers represent information about messages that is independently standardized such as ws-security and may have separate semantics from the message body. for example there may be standard forms of message header that describe authentication of messages. the form of such headers is defined for all messages although of course a given authentication header will be specific to the particular message. the primary function of headers is to facilitate the modular processing of the message although they can also be used to support routing and related aspects of message processing. the header part of a message can include information pertinent to extended web services functionality such as security transaction context orchestration information message routing information or management information. message headers may be processed independently of the message body each message header may have an identifying service role that indicates the kind of processing that should be performed on messages with that header. each message may have several headers each potentially identifying a different service role. although many headers will relate to infrastructure facilities such as security routing load balancing and so on it is also possible that headers will be application specific. for example a purchase order processing web service may be structured into layers corresponding to different functions within the organization. these stakeholders may process headers of different messages in standardized ways the customer information may be captured in one standardized header the stock items by a different standardized header and so on. 2.3.1.9 message receiver 2.3.1.9.1 definition a message receiver is an agent that receives a message. 2.3.1.9.2 relationships to other elements a message receiver is a agent a message receiver is the recipient of a message 2.3.1.9.3 explanation the message receiver is an agent that is intended to receive a message from the message sender. messages may be passed through intermediaries that process aspects of the message typically by examining the message headers. the message recipient may or may not be aware of processing by such intermediaries. often a specific message receiver the ultimate recipient is identified as the final recipient of a message. the ultimate recipient will be responsible for completing the processing of the message. 2.3.1.10 message reliability 2.3.1.10.1 definition message reliability is the degree of certainty that a message will be delivered and that sender and receiver will both have the same understanding of the delivery status. 2.3.1.10.2 relationships to other elements message reliability is a property of message delivery. message reliability may be realized by a combination of message acknowledgement and correlation. message reliability may be realized by a transport mechanism 2.3.1.10.3 explanation the goal of reliable messaging is to both reduce the error frequency for messaging and to provide sufficient information about the status of a message delivery. such information enables a participating agent to make a compensating decision when errors or less than desired results occur. high level correlation such as two-phase commit is needed if more than two agents are involved. note that in a distributed system it is theoretically not possible to guarantee correct notification of delivery however in practice simple techniques can greatly increase the overall confidence in the message delivery. it is important to note that a guarantee of the delivery of messages alone may not improve the overall reliability of a web service due to the need for end-to-end reliability. see end-to-end arguments in system design it may however reduce the overall cost of a web service. message reliability may be realized with a combination of message receipt acknowledgement and correlation. in the event that a message has not been properly received and acted upon the sender may attempt a resend or some other compensating action at the application level. 2.3.1.11 message sender 2.3.1.11.1 definition a message sender is the agent that transmits a message. 2.3.1.11.2 relationships to other elements a message sender is an agent a message sender is the originator of a message 2.3.1.11.3 explanation a message sender is an agent that transmits a message to another agent. although every message has a sender the identity of the sender may not be available to others in the case of anonymous interactions. messages may also be passed through intermediaries that process aspects of the message typically by examining the message headers. the sending agent may or may not be aware of such intermediaries. 2.3.1.12 message sequence 2.3.1.12.1 definition a message sequence is a sequence of related messages. 2.3.1.12.2 relationships to other elements a message sequence is a sequence of related messages a message sequence may realize a documented message exchange pattern 2.3.1.12.3 explanation a requester agent and a provider agent exchange a number of messages during an interaction. the ordered set of messages exchanged is a message sequence. this sequence may be realizing a well-defined mep usually identified by a uri. 2.3.1.13 message transport 2.3.1.13.1 definition a message transport is a mechanism that may be used by agents to deliver messages. 2.3.1.13.2 relationships to other elements a message transport is a mechanism that delivers messages a message transport has zero or more capabilities a message transport is constrained by various delivery policies a message transport must know sufficient address information in order to deliver a message. 2.3.1.13.3 explanation the message transport is the actual mechanism used to deliver messages. examples of message transport include http over tcp smtp message oriented middleware and so on. the responsibility of the message transport is to deliver a message from a sender to one or more recipient i.e. transport a soap infoset from one agent to another possibly with some implied semantics e.g. http methods semantics message transports may provide different features e.g. message integrity quality of service guaranties etc. for a message transport to function the sending agent must provide the address of the recipient. 2.3.2 the service oriented model the service oriented model som focuses on those aspects of the architecture that relate to service and action. the primary purpose of the som is to explicate the relationships between an agent and the services it provides and requests. the som builds on the mom but its focus is on action rather than message. the concepts and relationships in the som are illustrated in figure 2-8 figure 2-8. service oriented model 2.3.2.1 action 2.3.2.1.1 definition an action for the purposes of this architecture is any action that may be performed by an agent possibly as a result of receiving a message or which results in sending a message or another observable state change. 2.3.2.1.2 relationships to other elements an action may result in a desired goal state an action may be the sending of a message an action may be the processing of a received message 2.3.2.1.3 explanation at the core of the concept of service is the notion of one party performing action s at the behest of another party. from the perspective of requester and provider agents an action is typically performed by executing some fragment of a program. in the wsa the actions performed by requester and provider agents are largely out of scope except in so far as they are the result of messages being sent or received. in effect the programs that are executed by agents are not in scope of the architecture however the resulting messages are in scope. 2.3.2.2 agent 2.3.2.2.1 definition an agent is a program acting on behalf of person or organization. this definition is a specialization of the definition in web arch it corresponds to the notion of software agent in web arch 2.3.2.2.2 relationships to other elements an agent is a computational resource an agent has an owner that is a person or organization an agent may realize zero or more services an agent may request zero or more services 2.3.2.2.3 explanation agents are programs that engage in actions on behalf of someone or something else. for our purposes agents realize and request web services. in effect software agents are the running programs that drive web services both to implement them and to access them. software agents are also proxies for the entities that own them. this is important as many services involve the use of resources which also have owners with a definite interest in their disposition. for example services may involve the transfer of money and the incurring of legal obligations as a result. we specifically avoid any attempt to govern the implementation of agents we are only concerned with ensuring interopability between systems. 2.3.2.3 choreography 2.3.2.3.1 definition a choreography defines the sequence and conditions under which multiple cooperating independent agents exchange messages in order to perform a task to achieve a goal state. editorial note this is a different level of abstraction from the definition used by the w3c web services choreography working group. 2.3.2.3.2 relationships to other elements a choreography uses one or more service interfaces a choreography defines the pattern of possible interactions between a set of agents a choreography may be expressed in a choreography description language a choreography pertains to a given task a choreography defines the relationship between exchanged messages and tasks of a service. 2.3.2.3.3 explanation a choreography is a model of the sequence of operations states and conditions that control the interactions involved in the participating services. the interaction prescribed by a choreography results in the completion of some useful function. examples include the placement of an order information about its delivery and eventual payment or putting the system into a well-defined error state. a choreography can be distinguished from an orchestration. an orchestration defines the sequence and conditions in which one web service invokes other web services in order to realize some useful function. a choreography may be described using a choreography description language. a choreography description language permits the description of how web services can be composed how service roles and associations in web services can be established and how the state if any of composed services is to be managed. 2.3.2.4 capability 2.3.2.4.1 definition a capability is a named piece of functionality or feature that is declared as supported or requested by an agent. 2.3.2.4.2 relationships to other elements a capability has a identifier which is a uri a capability has a a description of its semantics a capability can be advertised by an agent that supports it a capability can be required by agent that wishes to use it a capability may be referenced by a service description 2.3.2.4.3 explanation agents participating in an exchange may implement a wide variety of features. for example there may be different ways to achieve the reliable delivery of a message or there may be several mechanisms available to support security. a web service may advertise that it supports a particular capability and an agent requiring that capability might select the service on that basis. or a web service may indicate that it requires a particular capability of any requester agent that uses it and a requester agent may select it or avoid it on that basis. there may also be a negotiation either manual or automatic about which capabilities to select. the concept of capability encompasses soap features but is broader. 2.3.2.5 goal state 2.3.2.5.1 definition a goal state is a state of some service or resource that is desireable from some person or organization s point of view. 2.3.2.5.2 relationships to other elements a goal state is a state of the real world which includes the state of relevant resources a goal state is desired by some person or organization which has an interest in defining it. a goal state may be characterized informally or formally with a formal expression. 2.3.2.5.3 explanation goal states are associated with tasks. tasks are the unit of action associated with services that have a measurable meaning. typically measured from the perspective of the owner of a service a goal state is characterized by a predicate that is true of that state for example a book selling service may have as its goal state that a book has been purchased by a legitimate customer. it is difficult to be formal about vague properties such as desireable however it is also clear that services are deployed and used with an intention. an e-commerce service is oriented towards buying and selling a stock ticker service is oriented towards giving timely information. a goal state is simply a way of being able to declare success when a task has completed sucessfully. 2.3.2.6 provider agent 2.3.2.6.1 definition a provider agent is an agent that is capable of and empowered to perform the actions associated with a service on behalf of its owner the provider entity. 2.3.2.6.2 relationships to other elements a provider agent is a web service software agent a provider agent realizes one or more services a provider agent performs or causes to perform the actions associated with a task a provider agent acts on behalf of a provider entity 2.3.2.6.3 explanation the provider agent is the software agent that realizes a web service by performing tasks on behalf of its owner the provider entity. a given service may be offered by more than one agent especially in the case of composite services and a given provider agent may realize more than one web service. 2.3.2.7 provider entity 2.3.2.7.1 definition the provider entity is the person or organization that is providing a web service. 2.3.2.7.2 relationships to other elements a provider entity is a person or organization a provider entity offers a web service a provider entity owns a provider agent 2.3.2.7.3 explanation the provider entity is the person or organization that is offering a web service. the provider agent acts on behalf of the provider entity that owns it. 2.3.2.8 requester agent 2.3.2.8.1 definition a requester agent is a software agent that wishes to interact with a provider agent in order to request that a task be performed on behalf of its owner the requester entity. 2.3.2.8.2 relationships to other elements a requester agent is an agent a requester agent uses a service a requester agent acts on behalf of a requester entity 2.3.2.8.3 explanation the requester agent is the software agent that requires a certain function to be performed on behalf of its owner the requester entity. from an architectural perspective this is the agent that is looking for and invoking or initiating an interaction with a provider agent. 2.3.2.9 requester entity 2.3.2.9.1 definition the requester entity is the person or organization that wishes to use a provider entity s web service. 2.3.2.9.2 relationships to other elements a requester entity is a person or organization a requester entity owns a requester agent 2.3.2.9.3 explanation the requester entity is the person or organization that wishes to make use of a web service. the requester entity is the counterpart to the provider entity. 2.3.2.10 service 2.3.2.10.1 definition a service is an abstract resource that represents a capability of performing tasks that represents a coherent functionality from the point of view of provider entities and requester entities. to be used a service must be realized by a concrete provider agent. 2.3.2.10.2 relationships to other elements a service is a resource a service performs one or more tasks a service has a service description a service has a service interface a service has service semantics a service has an identifier a service has a service semantics a service has one or more service roles in relation to the service s owner a service may have one or more policies applied to it. a service is owned by a person or organization. a service is provided by a person or organization. a service is realized by a provider agent. a service is used by a requester agent. 2.3.2.10.3 explanation a service is an abstract resource that represents a person or organization in some collection of related tasks as having specific service roles. the service may be realized by one or more provider agents that act on behalf of the person or organization the provider entity. the critical distinction of a web service compared to other web resources is that web services do not necessarily have a representation however they are associated with actions. issue ws_get what should be the representation returned by an http get on a web service uri what should be the representation of a web service should a service description be available at the service uri resolution none recorded. for a web service to be compliant with this architecture there must be sufficient service descriptions associated with the service to enable its use by other parties. ideally a service description will give sufficient information so that an automatic agent may not only use the service but also decide if the service is appropriate that in turn implies a description of the semantics of the service. we distinguish a number of things in their relation to a service a service has an owner a service must be realized by a software provider agent a requester agent may interact with a provider agent and a provider agent has an owner the provider entity web services are inherently about computer-to-computer interactions between requester and provider agents yet they are also ultimately deployed in human service because the requester and provider agents act on behalf of their owners. web services are focused on actions. it is convenient for the purposes of characterizing their semantics to capture this in terms of tasks. the semantics of any computational system is bound with the behavior of the system and the intended semantics is bound with some desired behavior. tasks combine the concept of action with intention i.e. web services are conventionally invoked with a given purpose in mind. the purpose can be expressed as an intended goal state such as a book being delivered or a temperature reading being taken. there is no requirement for there to be a one-to-one correspondence between messages and services. a given message may be processed by more than one service especially in the situation where there are service intermediaries and a given service may of course process more than one kind of message. we formalize this by asserting that a service adopts one or more service roles. the service role identifies the intended role as determined by the owner of the service. a given role is characterized by the aspects of messages it is concerned with. 2.3.2.11 service description 2.3.2.11.1 definition a service description is a set of documents that describe the interface to and semantics of a service. 2.3.2.11.2 relationships to other elements a service description is a machine-processable description of a service a service description is a machine-processable description of the service s interface a service description contains a machine-processable description of the messages that are exchanged by the service a service description may include a description of the service s semantics a service description is expressed in a service description language 2.3.2.11.3 explanation a service description contains the details of the interface and potentially the expected behavior of the service. this includes its data types operations transport protocol information and address. it could also include categorization and other metadata to facilitate discovery and utilization. the complete description may be realized as a set of xml description documents. there are many potential uses of service descriptions they may be used to facilitate the construction and deployment of services they may be used by people to locate appropriate services and they may be used by requester agents to automatically discover appropriate provider agents in those case where requester agents are able to make suitable choices. 2.3.2.12 service interface 2.3.2.12.1 definition a service interface is the abstract boundary that a service exposes. it defines the types of messages and the message exchange patterns that are involved in interacting with the service together with any conditions implied by those messages. 2.3.2.12.2 relationships to other elements a service interface defines the messages relevant to the service 2.3.2.12.3 explanation a service interface defines the different types of messages that a service sends and receives along with the message exchange patterns that may be used. 2.3.2.13 service intermediary 2.3.2.13.1 definition a service intermediary is a web service whose main role is to transform messages in a value-added way. from a messaging point of view an intermediary processes messages en route from one agent to another. specifically we say that a service intermediary is a service whose outgoing messages are equivalent to its incoming messages in some application-defined sense. 2.3.2.13.2 relationships to other elements a service intermediary is a service. a service intermediary adopts a specific service role. a service intermediary preserves the semantics of messages it receives and sends. 2.3.2.13.3 explanation a service intermediary is a specific kind of service which typically acts as a kind of filter on messages it handles. normally intermediaries do not consume messages but rather forward them to other services. of course intermediaries do often modify messages but it is of the essence that from some application specific perspective they do not modify the meaning of the message. of course if a message is altered in any way then from some perspectives it is no longer the same message. however just as a paper document is altered whenever anyone writes a comment on the document and yet it is still the same document so an intermediary modifies the messages that it receives forwarding the same message with some changes. coupled with the concept of service intermediary is the service role is adopts. typically this involves one or more of the messages headers rather than the bodies of messages. the specification of the header is coupled with the permissable semantics of the intermediary should make it clear to what extent the messages forwarded by an itnermediary are the same message and what modifications are permitted. there are a number of situations where additional processing of messages is required. for example messages that are exchanged between agents within an enterprise may not need encryption however if a message has to leave the enterprise then good security may suggest that it be encrypted. rather than burden every software agent with the means of encrypting and decrypting messages this functionality can be realized by means of an intermediary. the main responsiblity of the software agents then becomes ensuring that the messages are routed appropriately and have the right headers targetted at the appropriate intermediaries. 2.3.2.14 service role 2.3.2.14.1 definition a service role is an abstract set of tasks which is identified to be relevant by a person or organization offering a service. service roles are also associated with particular aspects of messages exchanged with a service. 2.3.2.14.2 relationships to other elements a service role is a set of service tasks a service role may be defined in terms of particular properties of messages. a service role may be established by a service owner. 2.3.2.14.3 explanation a service role is an intermediate abstraction between service and task. a given message that is received by a service may involve processing associated with several service roles. similarly messages emitted may also involve more than one service role. we can formalize the distinction by noting that a service role is typically associated with a particular property of messages. for ultimate processing the service role may be to determine some final disposition of messages received. however other service roles may be associated with more generic properties of messages such as their encryption or whether they reference a customer or inventory item. service roles identify the points of interest that a service owner has in the processing of messages. as such they are established by the party that offers in the service. 2.3.2.15 service semantics 2.3.2.15.1 definition the semantics of a service is the behavior expected when interacting with the service. the semantics expresses a contract not necessarily a legal contract between the provider entity and the requester entity. it expresses the intended real-world effect of invoking the service. a service semantics may be formally described in a machine readable form identified but not formally defined or informally defined via an out of band agreement between the provider entity and the requester entity. 2.3.2.15.2 relationships to other elements a service semantics is the contract between the provider entity and the requester entity concerning the effects and requirements pertaining to the use of a service a service semantics describes the intended effects of using a service a service semantics is about the service tasks that constitute the service. a service semantics should be identified in a service description a service semantics may be described in a formal machine-processable language 2.3.2.15.3 explanation knowing the type of a data structure is not enough to understand the intent and meaning behind its use. for example methods to deposit and withdraw from an account typically have the same type signature but with a different effect. the effects of the operations are the semantics of the operation. it is good practice to be explicit about the intended effects of using a web service perhaps even to the point of constructing a machine readable description of the semantics of a service. machine processable semantic descriptions provide the potential for sophisticated usage of web services. for example by accessing such descriptions a requester agent may autonomously choose which provider agent to use. apart from the expected behavior of a service other semantic aspects of a service include any policy restrictions on the service the relationship between the provider entity and the requester entity and what manageability features are associated with the service. 2.3.2.16 service task 2.3.2.16.1 definition a service task is an action or combination of actions that is associated with a desired goal state. performing the task involves executing the actions and is intended to achieve a particular goal state. 2.3.2.16.2 relationships to other elements a service task is an action or combination of actions. a service task is associated with one or more intended goal states. a service task is performed by executing the actions associated with the task. a service task has a service interface 2.3.2.16.3 explanation a service task is an abstraction that encapsulates some intended effect of invoking a service. tasks are associated with goal states characterized by predicates that are satisfied on successful completion. the performance of a task is made observable by the exchange of messages between the requester agent and the provider agent. the specific pattern of messages is what defines the choreography associated with the task. in addition to exchanged messages there may be other private actions associated with a task. for example in a database update task the task may be signaled by an initiating message and a completion message which are public and the actual database update which is typically private. in the case of a service oriented architecture only the public aspects of a task are important and these are expressed entirely in terms of the messages exchanged. tasks represent a useful unit in modeling the semantics of a service and indeed of a service role a given service may consist of a number of tasks. 2.3.3 the resource oriented model the resource oriented model focuses on those aspects of the architecture that relate to resources. resources are a fundamental concept that underpins much of the web and much of web services for example a web service is a particular kind of resource that is important to this architecture. the rom focuses on the key features of resources that are relevant to the concept of resource independent of the role the resource has in the context of web services. thus we focus on issues such as the ownership of resources policies associated with resources and so on. then by virtue of the fact that web services are resources these properties are inherited by web services. we illustrate the basic concepts and relationships in the rom in figure 2-9 figure 2-9. resource oriented model 2.3.3.1 discovery 2.3.3.1.1 definition discovery is the act of locating a machine-processable description of a web service-related resource that may have been previously unknown and that meets certain functional criteria. it involves matching a set of functional and other criteria with a set of resource descriptions. the goal is to find an appropriate web service-related resource. ws glossary 2.3.3.1.2 relationships to other elements discovery is the act of locating a resource description discovery involves matching a set of functional and other criteria with a set of resource descriptions. discovery may be performed by an agent or by an end-user discovery may be realized using a discovery service 2.3.3.1.3 explanation in the context of web services the resources being discovered are usually service descriptions. if a requester entity does not already know what service it wishes to engage the requester entity must discover one. there are various means by which discovery can be performed. various things human end users or agents may initiate discovery. requester entities may find service descriptions during development for static binding or during execution for dynamic binding. for statically bound requester agents using discovery is optional as the service description might be obtained in other ways such as being sent directly from the provider entity to the requester entity developed collaboratively or provided by a third party such as a standards body. 2.3.3.2 discovery service 2.3.3.2.1 definition a discovery service is a service that enables agents to retrieve web service-related resource descriptions. 2.3.3.2.2 relationships to other elements a discovery service is a service a discovery service is used to publish descriptions a discovery service is used to search for resource descriptions a discovery service may be used by an agent 2.3.3.2.3 explanation a discovery service is used to publish and search for descriptions meeting certain functional or semantic criteria. it is primarily intended for use by requester entities to facilitate the process of finding an appropiate provider agent for a particular task. however depending on the implementation and policy of the discovery service 3.4.2 discovery registry index or peer-to-peer it may also be used by provider entities to actively publish their service descriptions. although the resource model is general purpose the most important resource for our purposes is the web service. furthermore the primary role of a discovery service is to facilitate the discovery of web services. for dynamic discovery the requester agent may interact directly with the discovery service to find an appropriate provider agent to engage. for static discovery a human may interact with the discovery service through an appropriate software agent such as a browser. the use of an automated discovery service is optional since other means can be used to enable a requester entity and provider entity to agree on the service description that will govern the interaction. for example the requester entity might obtain the service description directly from the provider entity the two parties might develop the service description collaboratively or in some circumstances the service description may be created by the requester entity and dictated to the provider entity. for example a large company may require its suppliers to provide web services that conform to a particular service description. likewise a requester entity can obtain a service description from other sources besides a discovery service such as a local file system ftp site url or wsil document. 2.3.3.3 identifier 2.3.3.3.1 definition an identifier is an unambiguous name for a resource. 2.3.3.3.2 relationships to other elements an identifier should be realized a uri an identifier identifies a resource that is relevant to the architecture 2.3.3.3.3 explanation identifiers are used to identify resources. in the architecture we use uniform resource identifiers rfc 2396 to identify resources. issue urivsqname should uris be used to identify web services components rather than qnames some specifications use qnames to identify things. however qnames may be ambiguous because the same qname may be used to identify things of different types. in effect specifications having this practice have different symbol spaces to distinguish the different uses of a qname. should uris be preferred instead of qnames for web services a significant majority of this working group believes the answer is yes. resolution none recorded. 2.3.3.4 representation 2.3.3.4.1 definition a representation is a piece of data that describes a resource state. 2.3.3.4.2 relationships to other elements a resource may have a representation 2.3.3.4.3 explanation representations are data objects that reflect the state of a resource. a resource has a unique identifier a uri note that a representation of a resource need not be the same as the resource itself for example the resource asociated with the booking state of a restaurant will have different representations depending on when the representation is retrieved. a representation is usually retrieved by performing an http get on a uri. 2.3.3.5 resource 2.3.3.5.1 definition a resource is defined by rfc 2396 to be anything that can have an identifier. although resources in general can be anything this architecture is only concerned with those resources that are relevant to web services and therefore have some additional characteristics. in particular they incorporate the concepts of ownership and control a resource that appears in this architecture is a thing that has a name may have reasonable representations and which can be said to be owned. the ownership of a resource is critically connected with the right to set policy on the resource. 2.3.3.5.2 relationships to other elements a resource has an identifier a resource may have zero or more representations a resource may have zero or more resource descriptions a resource is owned by a person or organization a resource may be governed by zero or more policies 2.3.3.5.3 explanation resources form the heart of the web architecture itself. the web is a universe of resources that have uris as identifiers as defined in rfc 2396 from a real-world perspective a most interesting aspect of a resource is its ownership a resource is something that can be owned and therefore have policies applied to it. policies applying to resources are relevant to the management of web services security of access to web services and many other aspects of the role that a resource has in the world. 2.3.3.6 resource description 2.3.3.6.1 definition a resource description is any machine readable data that may permit resources to be discovered. resource descriptions may be of many different forms tailored for specific purposes but all resource descriptions must contain the resource s identifier. 2.3.3.6.2 relationships to other elements a resource description contains the resource s identifier a resource description may reference the policies applicable to the resource a resource description may reference the semantics applicable to the resource 2.3.3.6.3 explanation a resource description is a machine-processable description of a resource. resource descriptions are used by and within discovery services to permit agents to discover the resource. the precise contents of a resource description will vary depending on the resource on the purpose of the description and on the accessibility of the resource. however for our purposes it is important to note that the description must contain the resource s identifier. i.e. a description of the form the new resource that is owned by xyz co. is not regarded as a valid resource description because it does not mention the resource s identifier. a primary purpose of resource descriptions is to facilitate the discovery of the resource. to aid that purpose the description is likely to contain information about the location of the resource how to access it and potentially any policies that govern the policy. where the resource is a web service the description may also contain machine-processable information about how to invoke the web service and the expected effect of using the web service. note that a resource description is fundamentally distinct from the resource representation. the latter is a snapshot reflecting the state of resource the description is meta-level information about the resource. 2.3.4 the policy model the policy model focuses on those aspects of the architecture that relate to policies and by extension security and quality of service. security is fundamentally about constraints about constraints on the behavior on action and on accessing resources. similarly quality of service is also about constraints on service. in the pm these constraints are modeled around the core concept of policy and the relationships with other elements of the architecture. thus the pm is a framework in which security can be realized. however there are many other kinds of constraints and policies that are relevant to web services including various application-level constraints. the concepts and relationships in the pm are illustrated in figure 2-10 figure 2-10. policy model 2.3.4.1 audit guard 2.3.4.1.1 definition an audit guard is a mechanism used on behalf of an owner that monitors actions and agents to verify the satisfaction of obligations. 2.3.4.1.2 relationships to other elements a audit guard is a a policy guard an audit guard may monitor one or more resources. an audit guard may monitor actions relative to one or more services. an audit guard may determine if an agent s obligations have been discharged. 2.3.4.1.3 explanation an audit guard is an enforcement mechanism. it is used to monitor the discharge of obligations. the role of the audit guard is to monitor that agents resources and services are consistent with any associated obligations established by the service s owner or manager. typically an audit guard monitors the state of a resource or a service ensuring that the obligation is satisfied. it determines whether the associated obligations are satisfied. by their nature it is not possible to proactively enforce obligations hence an obligation violation may result in some kind of retribution after the fact of the violation. 2.3.4.2 domain 2.3.4.2.1 definition a domain is an identified set of agents and or resources that is subject to the constraints of one of more policies. 2.3.4.2.2 relationships to other elements a domain is a collection of agents and or resources. a domain defines the scope of application of one or more policies 2.3.4.2.3 explanation a domain defines the scope of applicability of policies. a domain may be defined explicitly or implicitly. members of an explicitly defined domain are enumerated by a central authority members of an implicitly defined domain are not. for example membership in an implicitly defined domain may depend on the state of the agent or something it possesses and thus may be dynamic. 2.3.4.3 obligation 2.3.4.3.1 definition an obligation is a kind of policy that prescribes actions and or states of an agent and or resource. 2.3.4.3.2 relationships to other elements an obligation is a kind of policy an obligation may require an agent to perform one or more actions an obligation may require an agent or service to be in one or more allowable states an obligation may be discharged by the performance of an action or other event. 2.3.4.3.3 explanation an obligation is one of two fundamental types of policies. when an agent has an obligation to perform some action then it is required to do so. when the action is performed then the agent can be said to have satisfied its obligations. not all obligations relate to actions. for example an agent providing a service may have an obligation to maintain a certain state of readiness. quality of service policies are often expressed in terms of obligations. such an obligation is typically not discharged by any of the obligee s actions although an event such as a certain time period expiring may discharge the obligation. obligations by their nature cannot be proactively enforced. however obligations are associated with enforcement mechanisms audit guards. these monitor controlled resources and agents and may result in some kind of retribution retributions are not modeled by this architecture. an obligation may continue to exist after its requirements have been met for example an obligation to maintain a particular credit card balance or it may be discharged by some action or event. 2.3.4.4 permission 2.3.4.4.1 definition a permission is a kind of policy that prescribes the allowed actions and states of an agent and or resource. 2.3.4.4.2 relationships to other elements a permission is a type of policy a permission may enable one or more actions a permission may enable one or more allowable states 2.3.4.4.3 explanation a permission is one of two fundamental types of policies. when an agent has permission to perform some action to access some resource or to achieve a certain state then it is expected that any attempt to perform the action etc. will be successful. conversely if an agent does not have the required permission then the action should fail even if it would otherwise have succeeded. permissions are enforced by guards in particular permission guards whose function is to ensure that permission policies are honored. 2.3.4.5 permission guard 2.3.4.5.1 definition a permission guard is a mechanism deployed on behalf of an owner to enforce permission policies. 2.3.4.5.2 relationships to other elements a permission guard is a a policy guard a permission guard is a a mechanism that enforces permission policies a permission guard may control one or more resources. a permission guard enables actions relative to one or more services. 2.3.4.5.3 explanation a permission guard is an enforcement mechanism that is used to enforce permission policies. the role of the permission guard is to ensure that any uses of a service or resource are consistent with the policies established by the service s owner or manager. typically a permission guard sits between a resource or service and the requester of that resource or service. in many situations it is not necessary for a service to be aware of the permission guard. for example one possible role of a message intermediary is to act as a permission guard for the final intended recipient of messages. a permission guard acts by either enabling a requested action or access or by denying it. thus it is normally possible for permission policies to be proactively enforced. 2.3.4.6 person or organization 2.3.4.6.1 definition a person or organization may be the owner of agents that provide or request web services. 2.3.4.6.2 relationships to other elements a person or organization may own an agent a person or organization may belong to a domain a person or organization may establish policies governing resources that they own 2.3.4.6.3 explanation the wsa concept of person or organization is intended to refer to the real-world people that are represented by agents that perform actions on their behalf. all actions considered in this architecture are ultimately rooted in the actions of humans. 2.3.4.7 policy 2.3.4.7.1 definition a policy is a constraint on the behavior of agents or people or organizations. 2.3.4.7.2 relationships to other elements a policy is a constraint on the allowable actions or states of an agent or person or organization a policy may have an identifier a policy may be described in a policy description a policy may define a capability 2.3.4.7.3 explanation a policy is a constraint on the behavior of agents as they perform actions or access resources. there are many kinds of policies some relate to accessing resources in particular ways others relate more generally to the allowable actions an agent may perform both as provider agents and as requester agents. logically we identify two types of policy permissions and obligations. although most policies relate to actions of various kinds it is not exclusively so. for example there may be a policy that an agent must be in a certain state or conversely may not be in a particular state in relation to the services it is requesting or providing. closely associated with policies are the mechanisms for establishing policies and for enforcing them. this architecture does not model the former. policies have applications for defining security properties quality of service properties management properties and even application properties. 2.3.4.8 policy description 2.3.4.8.1 definition a policy description is a machine-processable description of a policy or set of policies. 2.3.4.8.2 relationships to other elements a policy description describes a policy 2.3.4.8.3 explanation a policy description is a machine processable description of some constraint on the behavior of agents as they perform actions access resources. the policy description itself is not the policy but it may define the policy and it may be used to determine if the policy applies in a given situation. policy descriptions may include specific conditions such as agents of xxx co. may access files in directory fff they may also include more general rules such as if an entity has the right to access files in the directory fff it also has the obligation to close them after 20 seconds. 2.3.4.9 policy guard 2.3.4.9.1 definition a policy guard is a mechanism that enforces one or more policies. it is deployed on behalf of an owner. 2.3.4.9.2 relationships to other elements a policy guard has an owner responsible for establishing the guard 2.3.4.9.3 explanation a policy guard is an abstraction that denotes a mechanism that is used by owners of resources to enforce policies. the architecture identifies two kinds of policy guards audit guards and permission guards. these relate to the core kinds of policies obligation and permission policies respectively 2.4 relationships this section defines terms that appear in our architectural models but are not specific to web services or web services architecture. however they are defined here to help clarify our use of these terms in this document. 2.4.1 the is a relationship 2.4.1.1 definition the x is a y relationship denotes the relationship between concepts x and y such that every x is also a y. 2.4.1.2 relationships to other elements assuming that x is a y then true of if p is true of y then p is true of x contains if y has a p then x has a q such that q is a p. transitive if p is true of y then p is true of x 2.4.1.3 explanation essentially when we say that concept x is a y we mean that every feature of y is also a feature of x. note however that since x is presumably a more specific concept than y the features of x may also be more specific variants of the features of y. for example in the service concept we state that every service has an identifier. in the more specific web service concept we note that a web service has an identifier in the form of a uri identifier. 2.4.2 the describes relationship 2.4.2.1 definition the concept y describes x if and only if y is an expression of some language l and that the values of y are instances of x. 2.4.2.2 relationships to other elements assuming that y describes x then if y is a valid expression of l then the values of y are instances of concept x 2.4.2.3 explanation essentially when we say that y describes concept x we are saying that the expression y denotes instances of x. for example in the service description concept we state that service descriptions are expressed in a service description language. that means that we can expect legal expressions of the service description language to be instances of the service description concept. 2.4.3 the has a relationship 2.4.3.1 definition saying that the concept x has a y relationship denotes that every instance of x is associated with an instance of y. 2.4.3.2 relationships to other elements assuming that x has a y then if e is an instance of x then y is valid for e. 2.4.3.3 explanation when we say that concept x has a y we mean that whenever we see an x we should also see a y for example in the web service concept we state that web services have uri identifiers. so whenever the web service concept is found we can assume that the web service referenced has an identifier. this in turn allows implementations to use identifiers to reliably refer to web services. if a given web service does not have an identifier associated with it then the architecture has been violated. 2.4.4 the owns relationship 2.4.4.1 definition the relationship x owns y denotes the relationship between concepts x and y such that every x has the right and authority to control utilize and dispose of y. 2.4.4.2 relationships to other elements assuming that x owns y then policy x has the right to establish policies that constrain agents and other entities in their use of y disposal x has the right to transfer some or all of his rights with respect to y to another entity. transitive if p is true of y then p is true of x 2.4.4.3 explanation essentially when we say that x owns y we mean that x has a significant set of rights with respect to y and that those rights are transferrable. in general ownership is partial and there may be many entities that have rights with respect to some service or resource. 2.4.5 the realized relationship 2.4.5.1 definition the statement concept x is realized as y denotes that the concept x is an abstraction of the concept y. an equivalent view is that the concept x is implemented using y. 2.4.5.2 relationships to other elements assuming that x is realized as y then implemented if y is present or true of a system then the concept x applies to the system reified y is a reification of the concept x. 2.4.5.3 explanation when we say that the concept or feature x is realized as y we mean that y is an implementation or reification of the concept x. i.e. if y is a valid concept of a system then we have also ensured that the concept x is valid of the same system. for example in the correlation feature we state that message correlation requires that we associate identifiers with messages. this can be realized in a number of ways including the identifier in the message header message body in a service binding and so on. the message identifier is a key to the realization of message correlation. 3 stakeholder s perspectives this section examines the architecture from various perspectives each perspective representing one coherent view of the architecture. for example security represents one major stakeholder s perspective of the architecture itself. 3.1 service oriented architecture 3.1.1 distributed systems a distributed system consists of diverse discrete software agents that must work together to perform some tasks. furthermore the agents in a distributed system do not operate in the same processing environment so they must communicate by hardware software protocol stacks over a network. this means that communications with a distributed system are intrinsically less fast and reliable than those using direct code invocation and shared memory. this has important architectural implications because distributed systems require that developers of infrastructure and applications consider the unpredictable latency of remote access and take into account issues of concurrency and the possibility of partial failure dist comp distributed object systems are distributed systems in which the semantics of object initialization and method invocation are exposed to remote systems by means of a proprietary or standardized mechanism to broker requests across system boundaries marshall and unmarshall method argument data etc. distributed objects systems typically albeit not necessarily are characterized by objects maintaining a fairly complex internal state required to support their methods a fine grained or chatty interaction between an object and a program using it and a focus on a shared implementation type system and interface hierarchy between the object and the program that uses it. a service oriented architecture soa is a form of distributed systems architecture that is typically characterized by the following properties logical view the service is an abstracted logical view of actual programs databases business processes etc. defined in terms of what it does typically carrying out a business-level operation. message orientation the service is formally defined in terms of the messages exchanged between provider agents and requester agents and not the properties of the agents themselves. the internal structure of an agent including features such as its implementation language process structure and even database structure are deliberately abstracted away in the soa using the soa discipline one does not and should not need to know how an agent implementing a service is constructed. a key benefit of this concerns so-called legacy systems. by avoiding any knowledge of the internal structure of an agent one can incorporate any software component or application that can be wrapped in message handling code that allows it to adhere to the formal service definition. description orientation a service is described by machine-processable meta data. the description supports the public nature of the soa only those details that are exposed to the public and important for the use of the service should be included in the description. the semantics of a service should be documented either directly or indirectly by its description. granularity services tend to use a small number of operations with relatively large and complex messages. network orientation services tend to be oriented toward use over a network though this is not an absolute requirement. platform neutral messages are sent in a platform-neutral standardized format delivered through the interfaces. xml is the most obvious format that meets this constraint. 3.1.2 web services and architectural styles distributed object systems have a number of architectural challenges. dist comp and others point out problems introduced by latency and unreliability of the underlying transport. the lack of shared memory between the caller and object. the numerous problems introduced by partial failure scenarios. the challenges of concurrent access to remote resources. the fragility of distributed systems if incompatible updates are introduced to any participant. these challenges apply irrespective of whether the distributed object system is implemented using com corba or web services technologies. web services are no less appropriate than the alternatives if the fundamental criteria for successful distributed object architectures are met. if these criteria are met web services technologies may be appropriate if the benefits they offer in terms of platform vendor neutrality offset the performance and implementation immaturity issues they may introduce. conversely using web services technologies to implement a distributed system doesn t magically turn a distributed object architecture into an soa. nor are web services technologies necessarily the best choice for implementing soas if the necessary infrastructure and expertise are in place to use com or corba as the implementation technology and there is no requirement for platform neutrality using soap wsdl may not add enough benefits to justify their costs in performance etc. in general soa and web services are most appropriate for applications that must operate over the internet where reliability and speed cannot be guaranteed where there is no ability to manage deployment so that all requesters and providers are upgraded at once where components of the distributed system run on different platforms and vendor products where an existing application needs to be exposed for use over a network and can be wrapped as a web service. 3.1.3 relationship to the world wide web and rest architectures the world wide web operates as a networked information system that imposes several constraints agents identify objects in the system called resources with uniform resource identifiers uris agents represent describe and communicate resource state via representations of the resource in a variety of widely-understood data formats e.g. xml html css jpeg png agents exchange representations via protocols that use uris to identify and directly or indirectly address the agents and resources. web arch an even more constrained architectural style for reliable web applications known as representation state transfer rest has been proposed by roy fielding and has inspired both the w3c technical architecture group s architecture document web arch and many who see it as a model for how to build web services fielding the rest web is the subset of the www based on http in which agents provide uniform interface semantics essentially create retrieve update and delete rather than arbitrary or application-specific interfaces and manipulate resources only by the exchange of representations. furthermore the rest interactions are stateless in the sense that the meaning of a message does not depend on the state of the conversation. we can identify two major classes of web services rest-compliant web services in which the primary purpose of the service is to manipulate xml representations of web resources using a uniform set of stateless operations and arbitrary web services in which the service may expose an arbitrary set of operations. both classes of web services use uris to identify resources and use web protocols such as http and soap 1.2 and xml data formats for messaging. it should be noted that soap 1.2 can be used in a manner consistent with rest. however soap 1.2 can also be used in a manner that is not consistent with rest. 3.2 web services technologies web service architecture involves many layered and interrelated technologies. there are many ways to visualize these technologies just as there are many ways to build and use web services. figure 3-1 below provides one illustration of some of these technology families. figure 3-1. web services architecture stack in this section we describe some of those technologies that seem critical and the role they fill in relation to this architecture. this is a necessarily bottom-up perspective since in this section we are looking at web services from the perspective of tools which can be used to design build and deploy web serivces. the technologies that we consider here in relation to the architecture are xml soap wsdl. however there are many other technologies that may be useful. for example see the list of web services specifications compiled by roger cutler and paul denning. see also b an overview of web services security technologies 3.2.1 xml xml solves a key technology requirement that appears in many places. by offering a standard flexible and inherently extensible data format xml significantly reduces the burden of deploying the many technologies needed to ensure the success of web services. the important aspects of xml for the purposes of this architecture are the core syntax itself the concepts of the xml infoset xml infoset xml schema and xml namespaces. xml infoset is not a data format per se but a formal set of information items and their associated properties that comprise an abstract description of an xml document xml 1.0 the xml infoset specification provides for a consistent and rigorous set of definitions for use in other specifications that need to refer to the information in a well-formed xml document. serialization of the xml infoset definitions of information may be expressed using xml 1.0 xml 1.0 however this is not an inherent requirement of the architecture. the flexibility in choice of serialization format s allows for broader interoperability between agents in the system. in the future a binary encoding of the xml infoset may be a suitable replacement for the textual serialization. such a binary encoding may be more efficient and more suitable for machine-to-machine interactions. 3.2.2 soap soap 1.2 provides a standard extensible composable framework for packaging and exchanging xml messages. in the context of this architecture soap 1.2 also provides a convenient mechanism for referencing capabilities typically by use of headers soap 1.2 part 1 defines an xml-based messaging framework a processing model and an exensibility model. soap messages can be carried by a variety of network protocols such as http smtp ftp rmi iiop or a proprietary messaging protocol. soap 1.2 part 2 defines three optional components a set of encoding rules for expressing instances of application-defined data types a convention for representing remote procedure calls rpc and responses and a set of rules for using soap with http 1.1. while soap version 1.2 soap 1.2 part 1 doesn t define soap as an acronym anymore there are two expansions of the term that reflect these different ways in which the technology can be interpreted service oriented architecture protocol in the general case a soap message represents the information needed to invoke a service or reflect the results of a service invocation and contains the information specified in the service interface definition. simple object access protocol when using the optional soap rpc representation a soap message represents a method invocation on a remote object and the serialization of in the argument list of that method that must be moved from the local environment to the remote environment. 3.2.3 wsdl wsdl 2.0 wsdl 2.0 part 1 is a language for describing web services. wsdl describes web services starting with the messages that are exchanged between the requester and provider agents. the messages themselves are described abstractly and then bound to a concrete network protocol and message format. web service definitions can be mapped to any implementation language platform object model or messaging system. simple extensions to existing internet infrastructure can implement web services for interaction via browsers or directly within an application. the application could be implemented using com jms corba cobol or any number of proprietary integration solutions. as long as both the sender and receiver agree on the service description e.g. wsdl file the implementations behind the web services can be anything. 3.3 using web services the introduction outlined and illustrated in figure 1-1 the four broad steps involved in the process of engaging a web service see 1.4.5 overview of engaging a web service this section expands on these steps. although these steps are necessary they may not be sufficient many scenarios will require additional steps or significant refinements of these fundamental steps. furthermore the order in which the steps are performed may vary from situation to situation. the requester and provider entities become known to each other in the sense that whichever party initiates the interaction must become aware of the other party. there are two cases. in a typical case the requester agent will be the initiator. in this case we would say that the requester entity must become aware of the provider entity i.e. the requester agent must somehow obtain the address of the provider agent. there are two ways this may typically occur 1 the requester entity may obtain the provider agent s address directly from the provider entity or 2 the requester entity may use a discovery service to locate a suitable service description which contains the provider agent s invocation address via an associated functional description either through manual discovery or autonomous selection. these cases are described more fully in 3.4 web service discovery. in other cases the provider agent may initiate the exchange of messages between the requester and provider agents. in this case saying that the requester and provider entities become known to each other actually means that the provider entity becomes aware of the requester entity i.e. the provider agent somehow obtains the address of the requester agent. how this occurs is application dependent and irrelevant to this architecture. although this case is expected to be less common than when the requester agent is the initiator it is important in some push or subscription scenarios. the requester entity and provider entity agree on the service description a wsdl document and semantics that will govern the interaction between the requester agent and the provider agent. see the note below on agreeing on the same semantics and service description for further explanation of what is meant here by agree this does not necessarily mean that the requester and provider entities must communicate or negotiate with each other. it simply means that both parties must have the same or compatible understandings of the service description and semantics and intend to uphold them. there are many ways this can be achieved such as the requester and provider entities may communicate directly with each other to explicitly agree on the service description and semantics. the provider entity may publish and offer both the service description and semantics as take-it-or-leave-it contracts that the requester entity must accept unmodified as conditions of use. the service description and semantics excepting the network address of the particular service may be defined as a standard by an industry organization and used by many requester and provider entities. in this case the act of the requester and provider entities reaching agreement is accomplished by both parties independently conforming to the same standard. the service description and semantics perhaps excepting the network address of the service may be defined and published by the requester entity even if they are written from provider entity s perspective and offered to provider entities on a take-it-or-leave-it basis. this may occur for example if a large company requires its suppliers to provide web services that conform to a particular service description and semantics. in this case agreement is achieved by the provider entity adopting the service description and semantics that the requester entity has published. depending on the scenario step 2 or portions of step 2 may be performed prior to step 1. the service description and semantics are input to or embodied in both the requester agent and the provider agent as appropriate. in other words the information in them must either be input to or implemented in the requester and provider agents. there are many ways this can be achieved and this architecture does not specify or care what means are used. for example an agent could be hard coded to implement a particular fixed service description and semantics. an agent could be coded in a more general way and the desired service description and or semantics could be input dynamically. an agent could be created first and the service description and or semantics could be generated or deduced from the agent code. for example a tool could examine a set of existing class files to generate a service description. regardless of the approach used from an information perspective both the semantics and the service description must somehow be input to or implemented in both the requester agent and the provider agent before the two agents can interact. this is a slight simplification see the note below on agreeing on the same semantics and service description for further explanation. the requester agent and provider agent exchange soap messages on behalf of their owners. note agreeing on the same semantics and service description. although it is convenient to say that the requester and provider entities must agree on the semantics and the service description it is a slight simplification and perhaps slightly misleading to say that the parties must agree on the same semantics and service description the word agree often connotes an active communication between the parties and an explicit act such as signing a contract to cause the agreement to become binding on the two parties yet neither of these is required in the case of step 2 above. it is a slight simplification to say that the requester and provider agents must implement the same semantics and wsd for two reasons 1 the requester agent implements them from the perspective of the requester entity while the provider agent implements them from the perspective of the provider entity for example one party s input is the other party s output and 2 the requester and provider agents only need to implement those aspects of the service description and semantics that are relevant to their respective roles. in summary it is convenient and evocative to say that the requester and provider entities must agree on the semantics and the service description that will govern the interaction between the requester and provider agents but it would be more accurate to say that they simply need to have a congruent or non-conflicting view of the semantics and service description of the interaction. 3.4 web service discovery if the requester entity wishes to initiate an interaction with a provider entity and it does not already know what provider agent it wishes to engage then the requester entity may need to discover a suitable candidate. discovery is the act of locating a machine-processable description of a web service that may have been previously unknown and that meets certain functional criteria. ws glossary the goal is to find an appropriate web service. a discovery service is a service that facilitates the process of performing discovery. it is a logical role and could be performed by either the requester agent the provider agent or some other agent. figure 3-2 discovery process expands on figure 1-1 to describe the process of engaging a web service when a discovery service is used. figure 3-2. discovery process service engagement using a discovery service proceeds in roughly the following steps. the requester and provider entities become known to each other the discovery service somehow obtains both the web service description wsd in figure 3-2 and an associated functional description fd of the service. the functional description fd in figure 3-2 is a machine-processable description of the functionality or partial semantics of the service that the provider entity is offering. it could be as simple as a few words of meta data or a uri or it may be more complex such as a tmodel in uddi or a collection of rdf daml-s or owl-s statements. this architecture does not specify or care how the discovery service obtains the service description or functional description. for example if the discovery service is implemented as a search engine then it might crawl the web collecting service descriptions wherever it finds them with the provider entity having no knowledge of it. or if the discovery service is implemented as a registry such as uddi then the provider entity may need to actively publish the service description and functional description directly to the discovery service. the requester entity supplies criteria to the discovery service to select a web service description based on its associated functional description capabilities and potentially other characteristics. one might locate a service having certain desired functionality or semantics however it may be possible to specify non-functional criteria related to the provider agent such as the name of the provider entity performance or reliability criteria or criteria related to the provider entity such as the provider entity s vendor rating. the discovery service returns one or more web service descriptions or references to them that meet the specified criteria. if multiple service descriptions are returned the requester entity selects one perhaps using additional criteria. the requester and provider entities agree on the semantics sem in figure 3-2 of the desired interaction. although this may commonly be achieved by the provider entity defining the semantics and offering them on a take-it-or-leave-it basis to the requester entity it could be achieved in other ways. for example both parties may adopt certain standard service semantics that are defined by some industry standards body. or in some circumstances the requester could define the semantics. the important point is that the parties must agree in the sense described in 3.3 using web services on the semantics regardless of how that is achieved. step 2 also requires that the parties agree in the sense described in 3.3 using web services on the service description that is to be used. however since the requester entity obtained the web service description in step 1.c in effect the requester and provider entities have already done so. the service description and semantics are input to or embodied in both the requester agent and the provider agent as appropriate. the requester agent and provider agent exchange soap messages on behalf of their owners. 3.4.1 manual versus autonomous discovery the discovery process described above is not specific about who or what within the requester entity actually performs the discovery. under manual discovery a requester human uses a discovery service typically at design time to locate and select a service description that meets the desired functional and other criteria. under autonomous discovery the requester agent performs this task either at design time or run time. although the steps are similar in either case the constraints and needs are significantly different such as interface requirements. the requirements for something that is intended for human interaction are very different from the requirements for something that is intended for machine interaction. need for standardization. there is far less need to standardize an interface or protocol that humans use than those that machines are intended to use. trust. people do not necessarily trust machines to make decisions that may have significant consequences. this is explained more fully in 3.6.4.5 trust and discovery. in the case of autonomous discovery the need for machine-processable semantics is greatly increased. one situation in which autonomous discovery is often needed is when the requester agent has been interacting with a particular provider agent but for some reason needs to refresh its choice of provider agent either because the previous provider agent is no longer available or other reasons. 3.4.2 discovery registry index or peer-to-peer at present there are three leading viewpoints on how a discovery service should be conceived as a registry as an index or as a peer-to-peer system. what are the differences for what purpose is one better than the other 3.4.2.1 the registry approach a registry is an authoritative centrally controlled store of information. publishing a service description requires an active step by the provider entity it must explicitly place the information into the registry before that information is available to others. in the case of a registry the registry owner decides who has authority to place information into or update the registry. although the owner of registry r may delegate permission to approved provider entities that wish to publish their own service descriptions an arbitrary third party could not publish a description of someone else s service in registry r. this means for example that company x would not be able to register a functional description of company y s service even if that description would be valuable to others and may be superior in some ways to y s own description. the registry owner decides what information is placed in the registry. others cannot independently augment that information. uddi is often seen as an example of the registry approach but it can also be used as an index. 3.4.2.2 the index approach in contrast with a registry an index is a compilation or guide to information that exists elsewhere. it is not authorative and does not centrally control the information that it references. in the case of an index publishing is passive the provider entity exposes the service and functional descriptions on the web and those who are interested the index owners collect them without the provider entity s specific knowledge. anyone can create their own index. when descriptions are exposed they can be harvested using spiders and arranged into an index. multiple organizations may have such indexes. the information contained in an index could be out of date. however since the index contains pointers to the authoritative information the information can be verified before use. an index could include third-party information. different indexes could provide different kinds of information some richer some sparser. free-market forces determine which index people will use to discover the information that they seek. google is often cited as an example of the index approach. it is important to note that the key difference between the registry approach and the index approach is not merely the difference between a registry itself and an index in isolation. indeed uddi could be used as a means to implement an individual index just spider the web and put the results into a uddi registry. rather the key difference is one of control who controls what and how service descriptions get discovered in the registry model it is the owner of the registry who controls this. in the index model since anyone can create an index market forces determine which indexes become popular. hence it is effectively the market that controls what and how service descriptions get discovered. 3.4.2.3 peer-to-peer p2p discovery peer-to-peer p2p computing provides an alternative that does not rely on centralized registries rather it allows web services to discover each other dynamically. under this view a web service is a node in a network of peers which may or may not be web services. at discovery time a requester agent queries its neighbors in search of a suitable web service. if any one of them matches the request then it replies. otherwise each queries its own neighboring peers and the query propagates through the network until a particular hop count or other termination criterion is reached. peer-to-peer architectures do not need a centralized registry since any node will respond to the queries it receives. p2p architectures do not have a single point of failure such as a centralized registry. furthermore each node may contain its own indexing of the existing web services. finally nodes contact each other directly so the information they they receive is known to be current. in contrast in the registry or index approach there may be significant latency between the time a web service is updated and the updated description is reflected in the registry or index. the reliability provided by the high connectivity of p2p systems comes with performance costs and lack of guarantees of predicting the path of propagation. any node in the p2p network has to provide the resources needed to guarantee query propagations and response routing which in turn means that most of the time the node acts as a relayer of information that may be of no interest to the node itself. this results in inefficiencies and large overhead especially as the nodes become more numerous and connectivity increases. furthermore there may be no guarantee that a request will spread across the entire network therefore there is no guarantee to find the providers of a service. 3.4.2.4 discovery service trade-offs because of their respective advantages and disadvantages p2p systems indexes and centralized registries strike different trade-offs that make them appropriate in different situations. p2p systems are more appropriate in dynamic environments in which proximity naturally limits the need to propagate requests such as ubiquitous computing. centralized registries may be more appropriate in more static or controlled environments where information does not change frequently. indexes may be more appropriate in situations that must scale well and accommodate competition and diversity in indexing strategies. 3.4.3 federated discovery services although the registry viewpoint is a more centralized approach to discovery than the index approach there will arise situations where multiple registries exist on the web. it is expected that multiple indexes will also exist. in such an environment web service requesters that need to use a discovery service may need to obtain information from more than one registry or index. federation refers to the ability to consolidate the results of queries that span more than a single registry or index and make them appear more like a single service. a registry or index may contain information about other registries or indexes to help support federation. for example a registry dedicated to air travel services may know about another registry dedicated to rail travel services. a third registry for general travel services may contain information about some travel services but may look to other registries for certain categories of services. a search of the general travel registry may return a referral to the requester pointing them to the rail travel registry. federation of results in this scenario as contrasted to the referral would require the general travel registry to submit a query to the rail travel registry on behalf of the requester. the general travel registry would then merge the results of the query to the rail travel registry with the results of a query to its own registry. the general rail and air travel registries may need to share a common taxonomy or ontology to avoid forwarding inappropriate queries to other registries. in this scenario we assume the general travel registry examined the query from the requester and therefore did not forward the query to the air travel registry. the general travel registry could have discovered the rail travel registry using a spider or index approach. an indexing engine could have come across a registry and based on the information it harvested from the registry classified it as a rail travel registry. an alternative approach would be for the rail travel registry to publish information to the general travel registry and using the shared taxonomy could classify itself as a registry for rail travel services. note that each registry or index may provide a web service for discovery so it may be appropriate to use a choreography or orchestration description language to describe the exchanges among these services needed for federation. 3.4.4 functional descriptions and discovery as mentioned at the beginning of 2.3.3.1 discovery web services discovery requires the ability to search for appropriate web services based on functional descriptions fd in figure 3-2 or other criteria. because these functional descriptions need to be machine processable written by many provider entities and read by many requester entities an appropriate language for representing functional descriptions should at least be web friendly based on uris and globally scalable unambiguous capable of expressing any existing or future functionality capable of expressing existing and new vocabularies and relationships between functionalities this is an area that needs further standardization work. one such effort is owl-s. 3.5 web service semantics for computer programs to successfully interact with each other a number of conditions must be established there must be a physical connection between them such that data from one process may reach another there must be agreement in the sense discussed in 3.3 using web services on the form of the data such as whether the data is lines of text xml structures etc. the two or more programs must share agreement in the sense discussed in 3.3 using web services as to the intended meaning of the data. for example whether the data is intended to represent an html page to be rendered or whether the data represents the current status of a bank account the expectations and the processing involved in processing the data is different even if the form of the data is identical. there must be agreement in the sense discussed in 3.3 using web services as to the implied processing of messages exchanged between the programs. for example purchase ordering web service is expected by the agent that places the order to process the document containing the purchase order as a purchase order as opposed to simply recording it for auditing purposes. as we shall see below more may be required but for now this list is sufficient. 3.5.1 message semantics and visibility the extent to which the shared agreement about the form structure and meaning of a message is shared beyond just the agents involved with the message governs the overall visibility of the message semantics. the emphasis on messages rather than on the actions that are caused by messages means that soas have good visibility third parties may inspect the flow of messages and have a some assurance as to the services being invoked and the roles of the various parties. this in turn means that intermediaries such as firewalls are in a better situation for performing their functions. a firewall can look at the message traffic and at the structure of the message and make predictable and reasonable decisions about security. in rest-compliant soas additional visibility comes from the uniform interface semantics essentially those of the http protocol an intermediary can inspect the uri of the resource being manipulated the tcp ip address of the requester and the interface operation requested e.g. get put delete and determine whether the requested operation should be performed. the tcp ip and http protocols have a widely supported set of conventions e.g. known ports to support intermediaries and firewalls proxies caches etc. are almost universal today. visibility however goes beyond firewalls. in this architecture instead of emphasising a rest-style uniform interface we emphasize messages structure in terms of envelopes headers and bodies. we enhance visibility architecturally by fostering agreements on particular forms of headers. for example by having well-known standards that describe the form and interpretation of authentication tokens in headers we can simultaneously reduce the cost of performing authentication and increase the overall visiblity of the message s semantics if the authentication aspect of a message can be specified in a standard way then it is easier for a larger number of interested parties to process the message. furthermore increased visibility can reduce the cost of entry into a marketplace. other potential examples of standardized headers include support for message reliability support for message correlation support for process flow and service composition and support for choreography. this argument can be extended from obvious infrastructure-related processing of messages to more application-related processing of the message. for example by capturing customer identification in a well-understood header then all applications capable of processing that header will be able to extract the customer information of a message independently of the intended final disposition of the message. this in turn suggests an extremely powerful architectural approach to message processing different stakeholders in an organization represented by different applications processing different aspects of messages can collaborate with a minimal pre-ordained design. 3.5.2 semantics of the architectural models the different models in the architecture focus on different aspects of the interoperability issues between web service agents. the message oriented model focuses on how web service agents requester and provider agents may interact with each other using a message oriented communication model. the format of messages as xml infosets and the structuring of messages in terms of envelopes headers and bodies as described in that model acts to lay a foundation for the standard comprehension of messages exchanged between web service agents. the service oriented model builds on the basics of message communication by adding the concept of action and service. essentially the service model allows us to interpret messages as requests for actions and as responses to those requests. furthermore it allows an interpretation of the different aspects of messages to be expressed in terms of different expectations in well understood ways of the different parts of the message in effect an incremental and layered approach to service is possible using well understood headers. the resource oriented model extends this further by adding the concept of resource. resources are important internally to the architecture a web service is best understood as a resource in the context of web service management and in terms of policy management and externally resources are an important metaphor for interpreting the interaction between a requester entity and a provider entity. 3.5.3 the role of metadata an important part of the service oriented architecture approach is the extensive use of metadata. this is important for several reasons it fosters interoperability by requiring increased precision in the documentation of web services and it permits tools to give a higher degree of automation to the development of web services and hence lowers the cost of deploying same the metadata associated with a web service can be regarded as a partial machine-readable description of the semantics of the web service. in particular using technologies such as wsdl a web service can be described in a machine readable document as to the forms of expected messages the datatypes of elements of messages and using a choreography description language the expected flows of messages between web service agents. however current technologies used for describing web services are probably not yet sufficient to meet interoperability requirements on a global scale. we see the following areas where increased and richer meta-data would further enhance interoperability it should be possible to identify the real-world entities referenced by elements of messages. for example when using a credit card to arrange for the purchase of goods or services the element of the message that contains the credit card information is fundamentally a reference to a real-world entity the account of the card holder. the appropriate technology for this is standardized ontology languages such as owl. it should be possible to identify the expected effects of any actions undertaken by web service requester and provider agents. that this cannot be captured by datatyping can be illustrated with the example of a web service for withdrawing money from an account as compared to depositing money more accurately transferring from an account to another account or vice versa the datatypes of messages associated with two such services may be identical but with dramatically different effects instead of being paid for goods and services the risk is that one s account is drained instead. we expect that a richer model of services together with technologies for identifying the effects of actions is required. such a model is likely to incorporate concepts such as contracts both legally binding and technical contracts as well as ontologies of action. finally a web service program may understand what a particular message means in terms of the expected results of the message but unless there is also an understanding of the relationship between the requester entity and the provider entity the provider agent may not be able to accurately determine whether the requested actions are warranted. for example a provider agent may receive a request to transfer money from one account to another. the request may be valid in the sense that the datatypes of the message are correct and that the semantic markers associated with the message lead the provider agent to correctly interpret the message as a transfer request. however the transaction still may not be valid or fully comprehensible unless the provider agent can properly identfy the relationship of the requester agent s owner i.e. the requester entity to the requested action. currently such concerns are often treated simply as security considerations which they are in an ad hoc fashion. however when one considers issues such as delegated authority proxy requests and so on it becomes clear that a simple authentication model cannot accurately capture the requirements. we expect that a model that formalizes concepts such as institutions roles in business terms regulations and regulation formation will be required. with such a model we should be able to capture not only simple notions of authority but more subtle distinctions such as the authority to delegate an action authority by virtue of such delegation authority to authorize and so on. 3.6 web services security threats to web services involve threats to the host system the application and the entire network infrastructure. to secure web services a range of xml-based security mechanisms are needed to solve problems related to authentication role-based access control distributed security policy enforcement message layer security that accommodate the presence of intermediaries. at this time there are no broadly-adopted specifications for web services security. as a result developers can either build up services that do not use these capabilities or can develop ad-hoc solutions that may lead to interoperability problems. web services implementations may require point-to-point and or end-to-end security mechanisms depending upon the degree of threat or risk. traditional connection-oriented point-to-point security mechanisms may not meet the end-to-end security requirements of web services. however security is a balance of assessed risk and cost of countermeasures. depending on implementers risk tolerance point-to-point transport level security can provide enough security countermeasures. 3.6.1 security policies from the perspective of this architecture there are three fundamental concepts related to security the resources that must be secured the mechanisms by which these resources are secured i.e. policy guards and policies which are machine-processable documents describing constraints on these resources. policies can be logically broken down into two main types permission policies and obligatory policies. a permission policy concerns those actions and accesses that entities are permitted to perform and an obligation policy concerns those actions and states that entities are required to perform. these are closely related and dependent it is not consistent to be obliged to perform some action that one does not have permission to perform. a given policy document is likely to contain a mix of obligation and permission policy statements. the two kinds of policies have different enforcement mechanisms a permission guard is a mechanism that can be used to verify that a requested action or access is permitted an audit guard can only verify after the fact that an obligation has not been met. the precise form of these guards is likely to vary both with the resources being controlled and with the implementation technologies deployed. the architecture is principally concerned with the existence of guards and their role in the architecture. in a well engineered system it may be possible to construct guards that are not directly visible to either the requester or provider agents. for example the unauthorized access threat may be countered by a mechanism that validates the identity of potential agents who wish access the controlled resource. that mechanism is in turn controlled by the policy document which expresses what evidence must be offered by which agents before the access is permitted. a permission guard acts as a guard enabling or disabling access to a resource or action. in the context of soap for example one important role of soap intermediaries is that of permission guards the intermediary may not in fact forward a message if some security policy is violated. not all guards are active processes. for example confidentiality of information is encouraged by encryption of messages. as noted above it is potentially necessary to encrypt not only the content of soap messages but also the identities of the sender and receiver agents. the guard here is the encryption itself although this may be further backed up by other active guards that apply policy. 3.6.2 message level security threats traditional network level security mechanisms such as transport layer security ssl tls virtual private networks vpns ipsec internet protocol security and secure multipurpose internet mail exchange s mime are point-to-point technologies. although traditional security technologies are used in web services security however they are not sufficient for providing end-to-end security context as web services require more granularities. in general web services use a message-based approach that enables complex interactions that can include the routing of messages between and across various trust domains. web services face traditional security challenges. a message might travel between various intermediaries before it reaches its destination. therefore message-level security is important as opposed to point-to-point transport-level security. in figure 3-3 below the requester agent is communicating with the ultimate receiver through the use of one or more intermediaries. the security context of the soap message is end-to-end. however there may be a need for the intermediary to have access to some of the information in the message. this is illustrated as a security context between the intermediary and the original requester agent and the intermediary and the ultimate receiver. figure 3-3. end-to-end security the threats listed below addresses message security. 3.6.2.1 message alteration these threats affect message integrity whereby an attacker may modify parts or the whole message. for example an attacker may delete part of a message or modify part of a message or insert extra information into a message. the attacks may affect message header and or body parts. an attacker may also affect message integrity by manipulating its attachments. for example an attacker may delete an attachment or modify an attachment or insert an attachment into a message. 3.6.2.2 confidentiality in this threat unauthorized entities obtain access to information with in a message or message parts. for example an intermediary obtains access to credit card information that was intended for the ultimate recipient. 3.6.2.3 man-in-the-middle man-in-the-middle attacks are also known as bucket-brigade attacks. in this kind of assault it is possible for an attacker to compromise a soap intermediary and then intercepts messages between the web service requester and the ultimate receiver. the original parties will think that they are communicating with each other. the attacker may just have access to the messages or may modify them. mutual authentication techniques can be used to alleviate the threats of this attack. 3.6.2.4 spoofing spoofing is a complex attack that exploits trust relationships. the attacker assumes the identity of a trusted entity in order to sabotage the security of the target entity. as far as the target entity knows it is carrying on a conversation with a trusted entity. usually spoofing is used as a technique to launch other form of attacks such as forged messages. strong authentication techniques are needed to defend against such attacks. 3.6.2.5 denial of service denial of service dos attacks focus on preventing legitimate users of a service from the ability to use the service. dos attacks are easy to implement and can cause significant damage. dos attacks can disrupt the operation of the agent that is under attack and effectively disconnect it from the rest of the world. dos attacks can take various forms and target variety of services. dos attacks exploit weaknesses in the architecture of the system that is under attack. ironically security mechanisms themselves add overhead that can be exploited in dos attacks. distributed denial of service ddos attacks uses the resources of more than one machine to launch synchronized dos attacks on a resource. 3.6.2.6 replay attacks in this attack an intruder intercepts a message and then replays it back to a targeted agent. appropriate authentication techniques coupled with techniques such as time stamp and sequence numbering the messages can defend against replay attacks. 3.6.3 web services security requirements there are many security challenges for adopting web services. at the highest level the objective is to create an environment where message level transactions and business processes can be conducted securely in an end-to-end fashion. there is a need to ensure that messages are secured during transit with or without the presence of intermediaries. there may also be a need to ensure the security of the data in storage. the requirements for providing end-to-end security for web services are summarized in the next sub-sections. 3.6.3.1 authentication mechanisms authentication is needed in order to verify the identities of the requester and provider agents. in some cases the use of mutual authentication may be needed since the participants may not necessarily be directly connected by a single hop. for example the participants might be the initial requester and an intermediary. depending on the security policy it may be possible to authenticate the requester the receiver or to mandate the use of mutual authentication. several methods can be used to authenticate services. techniques include passwords one time pass and certificates. password-based authentication must use strong passwords. password authentication alone may be insufficient. based on vulnerability assessment it may be necessary to combine password authentication with other authentication and authorization process such as certificates lightweight directory access protocol ldap remote authentication dial-in user service radius kerberos and public key infrastructure pki 3.6.3.2 authorization authorization is needed in order to control access to resources. once authenticated authorization mechanisms control the requester access to appropriate system resources. there should be controlled access to systems and their components. policy determines the access rights of a requester. the principle of least privilege access should be used when access rights are given to a requester. 3.6.3.3 data integrity and data confidentiality data integrity techniques ensure that information has not been altered or modified during transmission without detection. data confidentiality ensures that the data is only accessible by the intended parties. data encryption and digital signature techniques can be used for this purpose. 3.6.3.4 integrity of transactions and communications this is needed to ensure that the business process was done properly and the flow of operations was executed in a correct manner. 3.6.3.5 non-repudiation non-repudiation is a security service that protects a party to a transaction against false denial of the occurrence of that transaction by another party. non-repudiation technologies provide evidence about the occurrence of transactions that that may be used by a third party to resolve disagreement. 3.6.3.6 end-to-end integrity and confidentiality of messages the integrity and confidentiality of messages must be ensured even in the presence of intermediaries. 3.6.3.7 audit trails audit trails are needed in order to trace user access and behavior. they are also needed in order to ensure system integrity through verification. audit trails can be performed by agents. such agents can play the role of an audit guard that can monitor watch resources and other agents validating those obligations that have been established are respected and or discharged. it is often not possible to prevent the violation of obligations. instead if an audit guard detects a policy violation some form of retribution or remediation must be enacted. the precise forms of this are of course beyond the scope of this architecture. 3.6.3.8 distributed enforcement of security policies implementers must be able to define a security policy and enforce it across various platforms with varying privileges. 3.6.4 security consideration of this architecture organizations that implement web services must be able to conduct business in a secure fashion. this implies that all aspects of web services including routing management publication and discovery should be performed in a secure manner. web services implementers must be able to utilize security services such as authentication authorization encryption and auditing. web services messages can flow through firewalls and can be tunneled through existing ports and protocols. web services security requires the use of appropriate corporate wide policies that may need to be integrated with external cross-enterprise policy and trust resolution. organizations may need to implement the capabilities that are listed next. 3.6.4.1 cross-domain identities requester and provider agents may communicate with each other using various identity verification schemes from different security domains. many systems define role based access privileges based on identity. it is important for web services to be able to support the mapping of identities across multiple domains and even within a single domain. a provider entity and a requester entity may use their identities to encrypt and sign messages that they exchange. they may exchange identity credentials within a context of initial messages handshake that allows further trusted interactions. service s identity is optional and it is perfectly possible to implement a business service without an identity if it always acts on behalf of a requester entity that is impersonating the requester entity not having a requester entity s identity translates into anonymous access which is rarely allowed for business services. 3.6.4.2 distributed policies security policies that are associated with requester entity service and discovery mechanism can be used to define the access privileges of request and responses between parties. these polices can be validated at run time in the context of interaction. each party in an interaction validates its own policies. 3.6.4.3 trust policies trust policies are distributed policies that apply to the environment of the other side s party in an interaction. a requester entity needs to trust the environment of a service and the provider entity needs to trust the environment of the requester entity. trust policies may be recursive they may be defined against trust policies of involved parties and even whole domains. an example of this is i will trust you if you trust my friend and my friend trusts you. distributed identities policies and trust can be described and processed by a machine. for example an x.509 certificate can be embedded in an message thus asserting the sender s identity. a policy can be described in xml and attached to the service contract. machines could process resolve and adjust security based on the given descriptions. trust mechanisms can be used to form delegation and federation relationships. these mechanisms can be used to facilitate secure interactions between web services across trust boundaries in a distributed fashion. 3.6.4.4 secure discovery mechanism secure discovery mechanism enforces policies that govern publication and discovery of a service. for example developers of soa applications for the procurement department may not be allowed to discover services available in the human resources department if those developers are not entitled to use human resources services. when publishing a service an identity is usually necessary to assert service publication policies except for some cases of peer-to-peer discovery. when a requester entity discovers a service it may or may not provide an identity discovery may well be anonymous. 3.6.4.5 trust and discovery suppose a requester entity discovers a web service being offered by a provider entity that was previously unknown to that requester entity. should the requester entity trust that service if the use of that service requires the requester to divulge sensitive information such as credit card numbers to the service then there may be significant risk involved. this decision whether or not to trust a particular service inherently arises when a requester entity chooses a web service from a previously unknown provider entity. this has ramification in the discovery process and leads to an important difference between manual discovery and autonomous discovery. when manual discovery is used a human makes the judgement perhaps using other independently obtained information of whether to trust and engage a previously unknown service that is discovered. whereas with autonomous discovery a machine makes this decision. since people may not trust a machine to make significant judgement decisions that could put themselves or their organizations at risk agents performing autonomous discovery are often limited to using private discovery services that list only those services that have been pre-screened and deemed trustworthy by the requester entity. this limited form of autonomous discovery would be more precisely called autonomous selection since the available candidates are already known in advance. two other ways to mitigate the trust issue in automated discovery include 1 a agent could autonomously discover candidate web services and then show them to the human user to choose or 2 an agent could autonomously discover candidate services and then check a trusted registery for independent information about them such as a dunn and bradstreet quality rating. 3.6.4.6 secure messaging secure messaging ensures privacy confidentiality and integrity of interactions. digital signatures techniques can be used to help ensure non-repudiation. techniques that ensure channel security can be used for securing messages. however such techniques are applicable in a few limited cases. examples include a static direct connection between a requester agent and a provider agent. for some applications such mechanisms can be appropriate. however in the general case message security techniques such as encryption and signing of the message payload can be used in routing and reliable messaging. figure 3-4. secure discovery 3.6.5 privacy considerations issue privacy_needs_more_work the relationship between privacy and web services technology needs clarification. there is considerably more complexity to privacy than treated in this section. resolution none recorded. privacy as related to behavior habits and actions are expressed in terms of policies that the owners of data typically the users of web services have together with mechanisms necessary to ensure that the owners rights are respected. privacy policies are typically much more of the obligatory form than access control policies. a policy that requires a provider agent to properly propagate p3p tags for example represents an obligation on the provider entity. however it is not possible to prevent a rogue provider agent from leaking private information. thus it should be possible to monitor the public actions of the web service to verify that the p3p tags are propagated appropriately. many privacy-related constraints are concerned with maintaining certain kinds of state. for example a provider entity may have a constraint that any p3p tags associated with a use of one of its web services are appropriately propagated to third parties. such a constraint cannot easily expressed in terms of the allowed actions that the provider agent may perform. it is an obligation to ensure that the publicly observable condition the proper use of p3p tags is always maintained presumably maintained in private also similarly a provider agent may link the possible actions that a requester agent may perform to the requester agent maintaining a particular level of secure access e.g. administrative tasks may only be performed if the request is using secure communications 3.7 peer-to-peer interaction to support web services interacting in a peer to peer style the architecture must support peer to peer message exchange patterns must permit web services to have persistent identity must permit descriptions of the capabilities of peers and must support flexibility in the discovery of peers by each other. in the message exchange pattern concept we allow for web services to communicate with each other using a very general concept of message exchange. furthermore we allow for the fact that a message exchange pattern can itself be identified this permits interacting web service agents to explicitly reference a particular message pattern in their interactions. a web service wishing to use a peer-to-peer style interaction may use for example a publish-subscribe form of message exchange pattern. this kind of message exchange is just one of the possible message exchange patterns possible when the pattern is explicitly identifiable. in the agent concept we note that agents have identifiers. the primary role of an agent identifier is to permit long running interactions spanning multiple messages. much like correlation an agent s identifier can be used to link messages together. for example in a publish and subscribe scenario a publishing web service may include references to the web service that requested the subscription separately from and additionaly to the actual recipient of the service. the agent concept also clarifies that a given agent may adopt the role of a provider agent and or a requester agent. i.e. these are roles of an agent not necessarily intrinsic to the agent itself. such flexibility is a key part of the peer to peer mode of interaction between web services. in the service concept we state that services have a semantics that may be identified in aservice description and that may be expressed in a service description language. this identification of the semantics of a service and for more advanced agents the description of the service contract itself permits agents implementing web services to determine the capabilities of other peer agents. this is turn is a critical success factor in the architecture supporting peer-to-peer interaction of web services. finally the fact that services have descriptions means that these descriptions may be published in discovery agencies and also retrieved from such agencies. in effect the availability of explicit descriptions enables web services and agents to discover each other automatically as well as having these hard-coded. 3.8 web services reliability dealing with errors and glitches is an inescapable fact of life especially in the context of a global network linking services belonging to many different people. while we cannot eliminate errors and glitches our goal is to both reduce the the error frequency for interactions and where errors occur to provide a greater amount of information about either successful or unsuccessful attempts at service. note that our focus on reliability is not really on issues such as syntax errors or even badly written applications. there is sufficient scope for things to go wrong at the level of network connections being broken servers being switched off and on in the middle of transactions and even people entering incorrect information in some description file. in the context of web services we can address the issues of reliability at several distinct levels the reliable and predictable delivery of infrastructure services such as message transport and service discovery of reliable and predictable interactions between services and of the reliable and predictable behavior of individual requester and provider agents. this uow.acc.tab.analysis is generally separate from concerns of fault tolerance availability or security but there may of course be overlapping issues. in the context of security deliberate acts can cause things to go wrong for example denial of service attacks. this is a sufficiently important case that we deal with it in a separate section. 3.8.1 message reliability reliability at the level of messages is often referred to as reliable messaging. in any distributed system there are fundamental limits to the reliability of communication between agents on a public network. however in practice there are techniques that we can use to greatly increase the reliability of messages and in those cases where communication fails then we can gain some feedback as to what went wrong. in more detail we identify two properties of message sending that are important the sender of the message would like to be able to determine whether a given message has been received by its intended receiver and that the message has been received exactly once. knowing if a message has been received correctly allows the sender to take compensating action in the event the message has not been received. at the very least the sender may attempt to resend a message that has not been received. the general goal of reliable messaging is to define mechanisms that make it possible to achieve these objectives with a high probability of success in the face of inevitable but unpredictable network system and software failures. this goal may also be examined with respect to whether one wishes to confirm only the receipt of a message or perhaps also to confirm the validity of that message. three questions may be asked about message validity was the message received the same as the one sent this may be determined by such techniques as byte counts check sums digital signatures. does the message conform to the formats specified by the agreed upon protocol for the message typically determined by automatic systems using syntax constraints e.g. xml well formed and structural constraints validate against one or more xml schemas or wsdl message definitions does the message conform to the business rules expected by the receiver for this purpose additional constraints and validity checks related to the business process are typically checked by application logic and or human process managers. of these the first is considered to be part of reliable messaging the last is partly addressed by web service choreography but is more closely related to the business expectations of the parties. the web services architecture does not itself give specific support for reliable messaging or for reporting in the event of failure. however it does give guidance as to how this may be accomplished. the headers and body structure of messages can be utilized by providing standardized headers to support message auditing then message reliability infrastructures can be deployed in ways that do not need to impact applications and services. in effect we can augment message traffic as necessary with specific headers and intermediaries that implement specific semantics for message reliability and reporting in the case that message communication fails. recall that the architecture does not itself mandate a specific means of message delivery. in fact we envisage many potential modes of communication including http smtp jms based message transports. a given message may even involve multiple kinds of message transport. however since all messages are structured according to soap we can incorporate overall message reliability within the soap message structure. message reliability is most often achieved via an acknoweldgement infrastructure which is a set of rules defining how the parties to a message should communicate with each other concerning the receipt of that message and its validity. ws-reliability and ws-reliablemessaging are examples of specifications for an acknowledgement infrastructure that leverage the soap extensibility model. in cases where the underlying transport layer already provides reliable messaging support e.g. a queue-based infrastructure the same level of reliability can be achieved in soap by defining a binding that relies on the underlying properties of the transport. 3.8.2 service reliability as with message reliability we are not in a position to be able to offer guarantees that service provider agents and service requester agents will always perform flawlessly again especially in the context of a distributed system over a public network where the different agents may be owned by different people and subject to different policies and management it is not possible to engineer complete service reliability. however as with message communication we can deploy techniques that greatly enhance reliability and reduce the cost of failure. the principal technique here is one of transactional context management. transaction management allows conversations between agents to be managed so that all the parties involved have a greater degree of confidence that the transactions between them progress satisfactorily and in the event of failure the failure may be identified and transactions either cancelled rolled back or compensated for. the architecture does not give specific advice on how to implement transactional reliability. however again as with message reliability the combination of the flexible and extensible message structures and the concept of multiple processing of messages via intermediaries implementing service roles gives us guidance. one way to incorporate transactional support would be to use standardized headers containing information such as transactional bracket markers and context information that are added to messages exchanged between service requester agents and service provider agents in such a way that intermediaries can process messages and monitor transactions in a way that only minimally impacts existing applications. specialized transactional intermediaries could process messages transaction-specific headers such as beginning of transaction commitment roll-back and so on and mark messages that they process with the results so that applications can respond appropriately. related to transactional monitoring is the monitoring of service choreographies. a significant aspect of the specification of the interface of a service is the pattern of message traffic that one might see. for simple cases this pattern is often very straightforward however for most realistic cases the choreography of services can be very complex. monitoring that messages are arriving in the order expected is potentially a significant tool in the deployment of reliable services. again as with transactional monitoring one approach would be to deploy specialized intermediary processes whose specific function is to ensure that the choreographic as well as the static i.e. message structure requirements of service usage are being met. this is especially important when the provider agent of a service is not in the same ownership domain as the requester agent. the key architectural property being used here is the potential deployment of third party services that monitor and process messages in specific role-oriented ways that neither the requesters of services nor the providers of serives needs to be unduly concerned with. this is possible because the architecture does not require messages to be consumed by single agents nor conversely to be produced by single agents but allows multiple agents to collaborate in the processing of a given message. each service role establishes a specific functionality often encoded in specific headers of the messages. 3.8.3 reliability and management the reliability of the individual requester and provider agents is out of scope of this architecture as we do not comment on the realization of web services. in some cases reliability at this level can be enhanced by provider entities adopting deployment platforms that have strong management capabilities. note that platform manageability represents a different perspective than the notion of management identified in service management below which focuses on the manageability of services from a peer or business-partner perspective. 3.9 web service management web service management is the management of web services through a set of management capabilities that enable monitoring controlling and reporting of service qualities and service usage. such service qualities include health qualities such as availability presence and number of service instances and performance e.g. access latency and failure rates and also accessibility of endpoints facets of service usage information that may be managed include frequency duration scope functional extent and access authorization. a web service becomes manageable when it exposes a set of management operations that support management capabilities. these management capabilities realize their monitoring controlling and reporting functions with the assistance of a management information model that models various types of service usage and service quality information associated with management of the web service. typical information types include request and response counts begin and end timers lifecycle states entity identifiers e.g. of senders receivers contexts messages etc. although the provision of management capabilities enables a web service to become manageable the extent and degree of permissible management are defined in management policies that are associated with the web service. management policies therefore are used to define the obligations for and permissions to managing the web service. just as the web service being managed needs to have common service semantics that are understood by both the requester and provider entities web service management also requires common management semantics in relation to management policies and management capabilities to be understood by the requester and provider entities. figure 3-5 illustrates how the concepts of service policy and capability defined in this architecture can be applied to management. figure 3-5. management concepts and relationships more detailed information about web services management is available in the management documents that were produced by the management task force of this working group. 3.10 web services and edi transaction tracking one of the basic assumptions that many people make about the role of web services is that they will be used for functions similar to those presently provided by electronic data interchange edi since edi is a well established technology it is useful to examine the expectations that current edi users may have for a technology that is to be used as a replacement. that is what do they do now that they will also expect from a new technology the most basic of these expectations concern security message reliability and a function that we will call tracking since security and message reliability are covered elsewhere in this document this section will focus on tracking. 3.10.1 when something goes wrong what happens when a transaction goes awry for reasons other than the loss of a message or security violations although it is possible and useful to automate safeguards both at the protocol and application level experience indicates that there is a virtually limitless variety of ways that business transactions can fail. informal interviews with current edi practitioners have indicated that in practice the 80-20 of what edi people actually do is involved with the issue of finding out what has actually happened in transactions when something has gone wrong. for example such an interaction may start with a phone call that goes something like why haven t you paid us and continues we think we have paid you in these cases there is often a good faith desire on both sides to figure out what has happened and comply with the requirements of the transaction but the information that people are working with may differ and coming to a common understanding can take some work. 3.10.2 the need for tracking in current edi operations many of the questions that must be answered in these cases can be handled in an automated fashion by the vendor of the proprietary network used in the transactions. for example if company a asks if the invoice to company b was delivered the vendor can access its records probably from a central repository and respond the message was delivered to company b s mailbox on dec 24 but they have not as yet downloaded the message queries of this sort are relatively easy to satisfy in this environment because the vendor is in control of all aspects of the communication. in a web services scenario where the transactions take place in a distributed environment with no central authority some other means must replace the current automated queries to the edi vendor or this important tracking capability will be lost. one possibility would be to provide some kind of uniform tracking interface. the basic requirement here is for companies that are cooperating in a business transaction to find out at any time what is the status and history of the transaction. significant complexity is added by the fact that multiple companies may be involved. that is company a may initiate a transaction by sending a message to b but the process may then involve messages between b and c. in some cases the interactions between b and c may be known to a as opposed to being part of b s internal process that is opaque to a it is not immediately clear whether this should be handled by a querying both b and c or if a responding to a query from a to b should carry with it the obligation to query c and return the results. this is presumably an issue which must be ironed out in the creation of the specification s for the uniform interface. 3.10.3 examples of tracking as illustrations here are some of the typical queries that a might send to b or c. web services usage scenarios wsaus contains additional examples. query to b did you receive and process message m from a query to b please return copies of all messages associated with transaction t. query to b please return copies of all messages between a and b in a given time range. query to c please return all messages associated with transactions involving a during a given time frame including messages between b and c related to transactions in which a is involved query to b please return copies of messages between b and other companies involved with a transaction or all transactions in a date range of course in all cases the party performing the query must be authorized to receive the information. current edi practices may automate some of these queries others may involve manual processing. in general however there are significant cost savings to be realized by automating as much of the process as possible. 3.10.4 requirements for effective tracking in order to help automate the tracking process there are various requirements some of which are probably achievable using current or planned specifications and others of which may require new ones a uniform interoperable interface for tracking queries so that company a can send a standard query to all of its business partners. this interface should be associated with the functional web services interfaces. for example such an interface might be implemented as part of a management interface. standard identifiers for transactions and individual messages that are necessary to define the queries. note that some of these queries involve identifiers of participants in a transaction other than sender and receiver of a particular message. there are clearly aspects of this requirement that are related to the choreography domain. policies controlling whether party a is authorized to make tracking queries to b. there may be several variants of such policies e.g. a can query b about messages directly between a and b but not messages between b and c associated with transactions involving a and so on. it may be possible to establish these policies using mechanisms currently available or under development in the security or policy domain or there may be transactional aspects to these policies that are not currently being considered. a method to establish the trust relationships necessary to implement the policies in 3. 3.10.5 tracking and uris one of the important connections between web services architecture and web architecture as a whole is the common use of uris. although uris are important to many aspects of web services it is particularly worth noting their potential role and benefit in indentifying and tracking transactions in web services. as a simple example to illustrate this benefit suppose uris are used as transaction identifiers. each time a new transaction is initiated a new uri is generated to unambiguously identify that transaction much like a primary key in a database. however while a database key may only be unambiguous within a particular database a uri is globally unambiguous which means that it can be conveniently transmitted to others without loss or confusion of meaning. furthermore a uri may be dereferenceable if the uri also represents the location of a document or a dynamic query into a database it could act as a convenient link for determining the status or history of that transaction provided the user is authorized to access such information. security mechanisms will need to ensure that a tracking uri cannot be dereferenced without proper authority and privacy controls but the use of uris is largely orthogonal to this requirement. the potential value of this dual use of uris both as globally unambiguous identifiers and as universally dereferenceable links is one of the most fundamental and important insights in the architecture of the web. because the web services architecture builds on the web architecture web services can leverage the benefits of clarity simplicity universality and convenience that this use of uri offers. this is not to say that web services tracking must be done using uris in this way. indeed there are other ways tracking can be performed and any engineering design must take many factors into consideration. rather the point is to illuminate the fact that because web services architecture is based on web architecture web services have the possibility of taking advantage of this use of uris. 4 conclusions 4.1 requirements analysis we believe this architecture substantially meets the requirements defined in wsa reqs with the exception of security and privacy. although this architecture contains substantial material that lays the foundation for addressing these more work is needed. the working group wanted to do more to address these but was not able to do so with the available resources. 4.2 value of this work this architecture lays the conceptual foundation for establishing interopable web services. the architecture identifies a number of important abstractions and their interdependencies. contributions of this work include the following provides a coherent framework that allows specific technologies to be considered in a logical context and facilitates the work of specification writers and architects. defines a consistent vocabulary including an authoritative definition of web service that has received widespread acceptance in industry ws glossary defines an owl ontology of web services architecture concepts owlo distinguishes soa from distributed object architecture. clarifies the architectural relationship between the web and web services clarifies the relationship between web services and rest. identifies gaps and inconsistencies in existing web services specifications. identifies the role of semantics and the need for machine-processable semantics and ontologies in web services 4.3 significant unresolved issues see also the issues list previously maintained by the working group. what is the difference between an mep and a choreography see 2.3.1.7 message exchange pattern mep what should be the representation returned by an http get on a web service uri see 2.3.2.10 service should uris be used to identify web services components rather than qnames see 2.3.3.3 identifier the relationship between privacy and web services technology needs clarification. see 3.6.5 privacy considerations soap 1.2 and this architecture introduce the concept of intermediaries but this concept is not represented in wsdl 2.0. what happens if two logical wsdl documents define the same service differently see email thread available at http lists.w3.org archives public www-ws-desc 2003dec 0045.html the relationship between conversations correlations and transactions and choreography is unclear and needs more work. there is a need for consistent tracking mechanisms in web services. see 3.10 web services and edi transaction tracking a overview of web services specifications non-normative an annotated list of web services specifications available at http lists.w3.org archives public www-ws-arch 2004feb 0022.html was produced independently by two members of this working group roger cutler and paul denning. although this working group feels that this is a useful list the opinions expressed therein are the personal opinions of those authors and do not represent the consensus of the working group. b an overview of web services security technologies non-normative this section attempts to provide a non-exhaustive description of current available work around web services security relevant to the requirements and solutions presented in 3.6 web services security. note that although these technologies build on existing security technologies they are relatively new and need to be fully tested in actual deployment scenarios. b.1 xml-signature and xml-encryption xml signatures are designed for use in xml transactions. it is a standard that was jointly developed by w3c and the ietf rfc 2807 rfc 3275 the standard defines a schema for capturing the result of a digital signature operation applied to arbitrary data and its processing. xml signatures add authentication data integrity and support for non-repudiation to the signed data. xml signature has the ability to sign only specific portions of the xml tree rather than the complete document. this is important when a single xml document may need to be signed by multiple times by a single or multiple parties. this flexibility can ensure the integrity of certain portions of an xml document while leaving open the possibility for other portions of the document to change. signature validation mandates that the data object that was signed be accessible to the party that interested in the transaction. the xml signature will generally indicate the location of the original signed object. xml encryption specifies a process for encrypting data and representing the result in xml. the data may be arbitrary data including an xml document an xml element or xml element content. the result of encrypting data is an xml encryption element which contains or references the cipher data. b.2 web services security developed at oasis web services security wss defines a soap extension providing quality of protection through message integrity message confidentiality and message authentication. wss mechanisms can be used to accommodate a wide variety of security models and encryption technologies. the work provides a general mechanism for associating security tokens with messages. the specification does not require a specific type of security token. it is designed to support multiple security token formats. wss describes how to encode binary security tokens. the specification describes how to encode x.509 certificates and kerberos tickets. additionally it also describes how to include opaque encrypted keys. the wss specification defines an end to end security framework that provides support for intermediary security processing. message integrity is provided by using xml signature in conjunction with security tokens to ensure that messages are transmitted without modifications. the integrity mechanisms can support multiple signatures possibly by multiple actors. the techniques are extensible such that they can support additional signature formats. message confidentiality is granted by using xml encryption in conjunction with security tokens to keep portions of soap messages confidential. the encryption mechanisms can support operations by multiple actors. b.3 xml key management specification xkms 2.0 xkms 2.0 is an xml-based way of managing the public key infrastructure pki a system that uses public-key cryptography for encrypting signing authorizing and verifying the authenticity of information in the internet. it specifies protocols for distributing and registering public keys suitable for use in conjunction with the proposed standard for xml signature and xml encryption. xkms allow implementers to outsource the task of key registration and validation to a trust utility. this simplify implementation since the actual work of managing public and private key pairs and other pki details is done by third party. an xkms trust utility works with any pki system passing the information back and forth between it and the web service. since the trust utility does the work the web service itself can be kept simple. xkms is a w3c specification. b.4 security assertion markup language saml saml is an extensible markup language standard xml that supports single sign on. saml allows a user to log on once to a web site and conduct business with affiliated but separate web sites. saml can be used in business-to-business and business-to-consumer transactions. there are threes basic saml components assertions protocol and binding. assertions can be one of three types authentication attribute and authorization. authentication assertion validates the identity of the user. the attribute assertion contains specific information about the user. while the authorization assertion identifies what the user is authorized to do. the protocol defines how saml request and receives assertions. there are several available binding for saml. there are bindings that define how saml message exchanges are mapped to soap http smtp and ftp among others. the organization for the advancement of structured information standards oasis is the body developing saml. b.5 xacml communicating policy information xacml is an extensible markup language standard xml based technology developed by organization for the advancement of structured information standards oasis for writing access control polices for disparate devices and applications. xacml includes an access control language and request response language that let developers write policies that determine what users can access on a network or over the web. xacml can be used to connect disparate access control policy engines. b.6 identity federation the liberty alliance is defining specifications dealing with various aspects of identity. their phase 2 work is grouped into three categories id-ff id-wsf and id-sis. id-ff identity federation framework discusses how businesses or organizations can be affiliated into circles of trust and trust relationships. id-ff includes several normative specifications which in turn make normative references to saml. id-wsf identity web services framework is a set of specifications for creating discovering using and updating various aspects of identities through a particular type of web service known as an identity service. id-wsf builds on id-ff. a user principal may register with several identity services. a prominent part of id-wsf is a discovery service for locating an identity service for a given user principal id-swf also defines a data services template. id-wsf has also defined a draft specification for an approach to negotiating an authentication method using soap messages to identify sasl mechanisms rfc 2222 note that ws-security specifically states that establishing a security context or authentication mechanisms is outside its scope. id-wsf may fill this void. however ws-security also defines a username token profile which could be used as an authentication mechanism. potentially liberty id-wsf could be used to negotiate the use of wss username token profile as the authentication mechanism. currently wss username token profile is not registered in iana s sasl mechanisms collection. id-sis identity service instance specifications defines profiles for particular types of identity services. these profiles conform to the id-wsf data services template. liberty has defined two such profiles. the employee profile id-sis-ep defines how to query and modify information associated with a principal in the context of their employer. the personal profile id-sis-pp defines how to query and modify identity information for principals themselves. c references non-normative dist comp a note on distributed computing s. c. kendall j. waldo a. wollrath g. wyant november 1994 see http research.sun.com techrep 1994 abstract-29.html. fielding architectural styles and the design of network-based software architectures phd. dissertation r. fielding 2000 see http www.ics.uci.edu fielding pubs dissertation top.htm. owlo owl ontology of web service architecture concepts m. paolucci n. srinivasan k. sycara see http www.w3.org 2004 02 wsa rfc 2396 uniform resource identifiers uri generic syntax ietf rfc 2396 t. berners-lee r. fielding l. masinter august 1998 see http ietf.org rfc rfc2396.txt. soap 1.2 part 1 soap version 1.2 part 1 messaging framework w3c recommendation m. gudgin m. hadley n. mendelsohn j-j. moreau h. nielsen 24 june 2003 see http www.w3.org tr 2003 rec-soap12-part1-20030624 soap 1.2 part 2 soap version 1.2 part 2 adjuncts w3c recommendation m. gudgin m. hadley n. mendelsohn j-j. moreau h. nielsen 24 june 2003 see http www.w3.org tr 2003 rec-soap12-part2-20030624 web arch architecture of the world wide web first edition w3c working draft i. jacobs 9 december 2003 see http www.w3.org tr 2003 wd-webarch-20031209 ws glossary web services glossary w3c working group note h. haas a.brown 11 febuary 2004 see http www.w3.org tr 2004 note-ws-gloss-20040211 wsa reqs web services architecture requirements w3c working group note d. austin a. barbir c. ferris s. garg 11 february 2004 see http www.w3.org tr 2004 note-wsa-reqs-20040211. wsaus web services architecture usage scenarios w3c working group note h. he h. haas d. orchard 11 february 2004 see http www.w3.org tr 2004 note-ws-arch-scenarios-20040211 wsdl 2.0 part 1 web services description language wsdl version 2.0 part 1 core language w3c working draft r. chinnici m. gudgin j-j. moreau j. schlimmer s. weerawarana 10 november 2003 see http www.w3.org tr 2003 wd-wsdl20-20031110 xml 1.0 extensible markup language xml 1.0 second edition w3c recommendation t. bray j. paoli c.m. sperberg-mcqueen e. maler. 6 october 2000 see http www.w3.org tr 2000 rec-xml-20001006. xml infoset xml information set w3c recommendation j. cowan r. tobin 24 october 2001 see http www.w3.org tr 2001 rec-xml-infoset-20011024 d acknowledgments non-normative this document has been produced by the web services architecture working group the chairs of this working group were chris ferris until july 2002 michael champion starting july 2002 and dave hollander starting july 2002 the chairs also wish to thank the following listed in alphabetic order for their substantial contributions to the final documents daniel austin mark baker abbie barbir david booth martin chapman ugo corda roger cutler paul denning zulah eckert chris ferris hugo haas hao he yin-leng husband mark jones heather kreger michael mahan frank mccabe eric newcomer david orchard katia sycara. members of the working group are at the time of writing and in alphabetical order geoff arnold sun microsystems inc. mukund balasubramanian infravio inc. mike ballantyne eds abbie barbir nortel networks david booth w3c mike brumbelow apple doug bunting sun microsystems inc. greg carpenter nokia tom carroll w. w. grainger inc. alex cheng ipedo michael champion software ag martin chapman oracle corporation ugo corda seebeyond technology corporation roger cutler chevrontexaco jonathan dale fujitsu suresh damodaran sterling commerce sbc james davenport mitre corporation paul denning mitre corporation gerald edgar the boeing company shishir garg france telecom hugo haas w3c hao he the thomson corporation dave hollander contivo yin-leng husband hewlett-packard company mario jeckle daimlerchrysler research and technology heather kreger ibm sandeep kumar cisco systems inc hal lockhart oasis michael mahan nokia francis mccabe fujitsu michael mealling verisign inc. jeff mischkinsky oracle corporation eric newcomer iona mark nottingham bea systems david orchard bea systems bijan parsia mind lab adinarayana sakala iona waqar sadiq eds igor sedukhin computer associates hans-peter steiert daimlerchrysler research and technology katia sycara carnegie mellon university bryan thompson hicks associates inc. sinisa zimek sap previous members of the working group were assaf arkin intalio inc. daniel austin w. w. grainger inc. mark baker idokorro mobile inc. planetfred inc. tom bradford xqrl inc. allen brown microsoft corporation dipto chakravarty artesia technologies jun chen martsoft corp. alan davies seebeyond technology corporation glen daniels macromedia ayse dilber at&t zulah eckert hewlett-packard company colleen evans sonic software chris ferris ibm daniela florescu xqrl inc. sharad garg intel mark hapner sun microsystems inc. joseph hui exodus digital island michael hui computer associates nigel hutchison software ag marcel jemio disa mark jones at&t timothy jones crossweave inc. tom jordahl macromedia jim knutson ibm steve lind at&t mark little arjuna bob lojek intalio inc. anne thomas manes systinet jens meinkoehn t-nova deutsche telekom innovationsgesellschaft nilo mitra ericsson don mullen tibco software inc. himagiri mukkamala sybase inc. joel munter intel henrik frystyk nielsen microsoft corporation duane nickull xml global technologies david noor rogue wave software srinivas pandrangi ipedo kevin perkins compaq mark potts talking blocks inc. fabio riccardi xqrl inc. don robertson documentum darran rolls waveset technologies inc. krishna sankar cisco systems inc jim shur rogue wave software patrick thompson rogue wave software steve vinoski iona scott vorthmann tibco software inc. jim webber arjuna prasad yendluri webmethods inc. jin yu martsoft corp. the people who have contributed to discussions on the www-ws-arch public mailing list are also gratefully acknowledged. 