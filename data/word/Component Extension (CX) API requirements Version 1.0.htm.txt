component extension cx api requirements version 1.0 component extension cx api requirements version 1.0 w3c note 11 december 2001 this version http www.w3.org tr 2001 note-cx-20011211 latest version http www.w3.org tr cx editors angel diaz ibm jon ferraiolo adobe stein kulseth opera philippe le h garet w3c chris lilley w3c charles mccathienevile w3c tapas roy openwave ray whitmer netscape aol copyright 2001 w3c mit inria keio all rights reserved. w3c liability trademark document use and software licensing rules apply. abstract from the early days of the world wide web web agents had been extended to support more types of contents. the recent developments of xml and the possibility to mix mupltiple xml namespaces in the document reiterated the need to extend implementations and relaying on add-on softwares to accomplish tasks not supported by default in the implementation. in other words we have several xml languages to represent different parts of web pages xhtml svg mathml xforms etc. we now need a well defined mechanism that allow different specialized tools to work together and handled these compound documents. this w3c note contains a non-exhaustive list of requirements to work on a component extension api. the goal of this api is to extend the ability of a web application. note that the web application can be either on the server side or on a client side and does not automatically implies interaction with a user or having a web browser. status of this document this document is an early draft resulting from the hypertext coordination group face to face meeting to discuss standardization of plug-in and active component architecture for the web. it is anticipated that this will be published as a w3c note as soon as it has reached an appropriate state of maturity. this document is a note made available by the w3c for discussion only. publication of this note by w3c indicates no endorsement by w3c or the w3c team or any w3c members. there is no commitment by w3c to invest additional resources in topics addressed by this note. comments on this document are invited and are to be sent to the public mailing list www-component-extension@w3.org. an archive is available at http lists.w3.org archives public www-component-extension w3c technical reports are published online at http www.w3.org tr. table of contents 1 requirements 1.1 formatting 1.1.1 baseline and linehight 1.1.2 linebreak size and rectangle negotiation multiple rectangles 1.1.3 dom views and formatting 1.2 rendering 1.2.1 freeze unfreeze 1.2.2 z-order painting 1.2.2.1 clipping 1.2.3 sharing colormap 1.2.4 sharing fonts 1.2.5 colors accessibility issues 1.2.6 device dependent drawing 1.2.7 forcing redraws invalidate rectangles invalidate region 1.2.8 window-less plug-in 1.3 style 1.3.1 dom css 1.3.1.1 specified values 1.3.1.2 computed values 1.3.2 actual values 1.3.3 generic styler 1.3.4 local styler 1.3.5 mobile profiles 1.4 error handling 1.5 events 1.6 dom core tree 1.7 starting point 1.8 connecting with outside scripting 1.9 nesting reetrance 1.10 abstraction level 1.11 timeline 1.12 network http 1.13 editing 1.13.1 editing mode 1.14 associations registrations negociations 1.15 accessibility 1.16 versioning 1.17 storage persistence 1.18 memory management 1.19 security appendices a glossary b references c contributors 1 requirements this document contains a description of the component extension requirements established during the hypertext cg meeting in august 2001. it classifies the application programming interface api requirements in 3 categories 1 the requirement must be addressed by the component extension api. 2 the requirement may be addressed by the component extension api. 3 the requirement is declared out of the scope of the component extension api. it might become in its scope in future versions. the description of a component extension must be in terms of content that is handled not in terms of a specific piece of software. for example it is appropriate to request a component extension that handles svg svg 1.0 including some set of functionalities for example identified using the smil required functionalities mechanism for the switch element or the svg equivalent the list of requirements provided in this document is not exhaustive and only reflects the requirements from the hypertext cg meeting. 1.1 formatting 1 the host implementation must provide a mechanism for an embedded object to request a region or set of regions for displaying content. the formatting interface should be independent of platform specific constraints. 1.1.1 baseline and linehight 1 the host implementation and component extension need to coordinate the linehight and the baseline. 1.1.2 linebreak size and rectangle negotiation multiple rectangles 1 the host shall provide means to determine the maximum size of the rectangle into which the embedded object may render. conceptually the size of this page may be unconstrained in both dimensions given scrolling. in practice the host must somehow constrain this in at least one dimension. for example the host may indicate that this rectangle is scrollable in the line-stacking direction. it must fix the other dimension. typically it would report the current width of its renderable area. the embedded object must be permitted to negotiate rectangles and break into smaller areas across lines if need be. 1.1.3 dom views and formatting 2 the dom level 3 views and formatting should be considered by the component extension api. 1.2 rendering 1 1.2.1 freeze unfreeze 1 a component extension may wish to suspend rendering momentarily while for example a succession of changes are made to the structure or the structure is made temporarily invalid or for some other reason whereby the intermediate state of the document is no to be displayed. examples of such methods svg dom svgsvgelement unsigned long suspendredraw in unsigned long max_wait_milliseconds void unsuspendredraw in unsigned long suspend_handle_id raises domexception void unsuspendredrawall void forceredraw void pauseanimations void unpauseanimations see also section 5.11 in svg10 openwave plugin api pluginsuspend and pluginresume methods. 1.2.2 z-order painting 1 it should be possible for content which is rendered by component extensions to take its correct place in the z-order of the entire document it can be above other content such as backgrounds which show through transparent areas and other content later in the document or with higher z-order should be able to partially overlap content rendered by the component extension. 1.2.2.1 clipping 1 clipping which addresses removal of parts of display elements that lie outside of a given boundary must be addrssed by the component extension. 1.2.3 sharing colormap 2 implementations which require a colormap will need to allow the component extension to request the allocation of colors in the colormap and to find out what colors are already in the colormap and to be notified if the color associated with a particular color index has changed. 1.2.4 sharing fonts 2 the component extension should have access to system fonts and their properties. the host implementation provide means for querying metrics of the current font. metrics of interest could be a subset of those provided by opentype the host implementation should provide methods for determining glyph bounding boxes baselines and nominal font height. it should also provide an indication whether a given character maps to a glyph in that font. the component extension should be able to find out about downloadable fonts that other content on the same page has made available and itself to make available fonts that it has downloaded. the font properties in use on the parent of the element whose content is being rendered by the component extension should be made available by inheritance over the component extension interface so that the same fonts can be used by the component extension. accessibility information about preferred font sizes should be passed across the component extension interface. 1.2.5 colors accessibility issues 1 1.2.6 device dependent drawing 1 component extension api should provide a platform dependent e.g. xwindow graphic context microsoft device context method for gathering device dependent information for formatting and drawing into each of the rectangles e.g. for optimisation of drawing such as window device context fonts however this must not preclude the ability to use device independent methods and the specification should recommend that these are available as a fallback. 1.2.7 forcing redraws invalidate rectangles invalidate region 1 in the component extension-does-compositing model with direct screen drawing a component extension might damage content rendered by something else. this is like the situation in windowing systems where a window is iconised and portions of other windows that are now uncovered have to be told to redraw. the container-does-compositing model with rendering being an offscreen rgba pixmap does not have this problem and need not tell its parents or other component extensions to redraw. moving or update of a component extension merely requires re-composition of the current stack of offscreens without the need for a forced redraw though this can be limited to a particular invalidated region. issue rectangle-region-1 these descriptions narrowly miss actually listing a requirement. make it simpler. see also netscape plug-ins 1.2.8 window-less plug-in 1 component extension which do not draw at all should be addressed by the component extension api. see also netscape plug-ins 1.3 style 1 1.3.1 dom css 1 this section describes the relation between the component extension api and the document object model dom level 2 css specification dom level 2 style sheets and css 1.3.1.1 specified values 3 unlike the dom level 2 css specification dom level 2 style sheets and css this note does not require access to the specified css values in the style sheets. 1.3.1.2 computed values 1 if the host implementation provides a dom tree to the component extension and a css style engine the component extension api must have access to the computed css values of its nearest dom node ancestor its parentnode using the dom level 2 css dom level 2 style sheets and css viewcss interface. depending on the css style engine the host implementation may also provide a fully decorated dom tree for the content addressed by the component extension. 1.3.2 actual values 3 actual css values as defined in the css specification css level 2 will not be addressed by the component extension api. 1.3.3 generic styler 1 the host implementation should contain a style engine to handle general properties and to provide extension mechanism in order to support other properties. this generic styler engine has the responsibility of decorating the dom tree with the computed values see also 1.3.1.2 computed values languages such as css have mechanism to extend the set of style properties used in the application. as an example svg 1.0 svg 1.0 reused some of the properties listed in the css 2 specification css level 2 and adds new ones. it is expected that the generic styler of the host implementation supports a specific set of properties and some general style properties such as color background or fonts are required to be supported. definition a foreign style property is a style property that is not recognized internally by the generic styler. the generic styler does not know its default value or if the value could be inherited or not. the generic styler is expected to support foreign style properties. the component extension should declare information on style properties it uses that may be foreign to the generic styler such as parse default values inheritance the styler is responsible for maintaining the information and dealing with duplicate declarations between component extensions. a component extension remove style properties or values associated with the style properties. in other words the set of style properties stored by the generic styler is the union of the set of style properties supported by the host implementation and its component extensions. if a computed value is not recognized the generic styler can use a default value like for colors always make the computed value have two parts a value in first set of values a possible extended value have extended value callback issue generic-style-engine-1 what to do about style sheets when it is not known what component extension will be loaded 1.3.4 local styler 2 the component extension can also embedded its own local style engine. in this case the component extension does not need to declare or get the computed values of the style properties in a dom tree. this model has the advantage to not assume a dom api between the host implementation and the component extension and only applies to the root node of component extension svg svg math math the local style engine needs to provide access to style sheets. access to containing dom tree optional access to the parent information item in order to get the computed values of the style properties propname value 1 access to style properties information propname inherit initial value. 1 1.3.5 mobile profiles 1 mobile profiles are always required to be supported by the host implementation and its component extensions. 1.4 error handling 2 an error handling mechanism should be provided by the host implementation to the component extension in a future revision of the component extension api. this mechanism may be based on or inspired from the error handling mechanism provided by the dom level 3 core specification dom level 3 core 1.5 events 1 there must be a way to pass events from the host implementation to the component extension and from the component extension to the host implementation. if the host implementation provides a dom tree to the component extension and contains an event mechanism the component extension api must support the dom level 2 events specification. user interface events such as window events or system events reload uri notify events may be addressed. namespace-bound events are events whose propagation is limited to elements namespace boundaries i.e. it propagates until it reaches an element who does not use its ancestor s namespace name. namespace bound events are out of scope. 1.6 dom core tree 1 the component extension api must provide programmatic read-only access to html and xml content by conforming to the following modules of the w3c document object model level 2 core specification dom level 2 core and exporting the interfaces they define the core module for html the core and xml modules for xml. 1.7 starting point 1 features of the existing netscape plugin api netscape plug-ins should considered as a starting point with implementation experience for features of the component extension api which may be modified replaced or eliminated as required to address problems and requirements. 1.8 connecting with outside scripting 1 the component extension will call a host implementation function to request a connection to one of its features. this feature may be a generic functionality eg. copy paste whether this is selected by button menu item keyboard shortcut drag-drop or or a specific host implementation chrome eg. toolbar button status bar the request can be to output data through the feature eg. status bar title bar alert to subscribe to events generated from a browser control or to add a control to the chrome eg. toolbar menubar menu the host implementation should return a value indicating whether it allows the connection or not. the component extension api should define how the features are selected and specify a minimal list of connections that the browser should allow if it does have the requested feature so that the component extension can reasonably expect such a connection request to be granted. subscribed-to events can be passed to the component extension using the normal event-passing mechanism see 1.5 events if the connection needs to pass large amounts of data the component extension s stream apis should be used. chrome 1 adding new items removing new items right-click drop down menu main menu bar status line copy paste find drag drop focus alert 1 query user agents capabilities cross plug-in streams properties 2 properties dialog system properties hostname ip 1.9 nesting reetrance 1 it must be possible for a component extension to discover where available and integrate the formatting and rendering of externally supported content types inserted into the component extension dom node s subhierarchy that are not internally supported by the component extension. 1.10 abstraction level 1 much like the w3c dom idl descriptions and language bindings the component extension api must be described independent of programming language operating system and platform. 1.11 timeline 2 smil 2.0 smil 2.0 is a specification for synchronized multimedia and smil animation smil animation is a specification for how the timing and animation aspects of smil 2.0 can be integrated into other languages such as svg see chapter 19 in svg10 if the host implementation supports synchronized playing of media such as audio video or animations then the host implementation must support the ability for time-based component extensions to play media on a portion of a host canvas and the host-played media and the component extension-played media must be synchronized. the api for achieving this synchronization must be rich enough to permit accurate implementation of the syncbehavior and synctolerance attributes defined in the section 10.3.1 in smil 2.0 smil 2.0 and smil animation allow content to be started and stopped via interactivity such as user interface events e.g. mouse and keyboard host-supplied event propagation apis must be such that time-based component extensions can implement the interactivity capabilities defined in the section 10.3.1 basic time support in smil 2.0 if the host implementation supports streaming media then the host implementation must supply apis that allow component extensions to receive streaming content. 1.12 network http 1 networking support will include an api to request the data from a uri reference. the component extension will call a host implementation function and pass the uri reference any additional headers for example in the case of http maybe an additional accept type the method in case of http get put post or head and a pointer to a notify data. the component extension may tell the host implementation to use the cache or to override it. when the request is complete the host implementation will call the component extension s notify function and pass the data to the component extension using the component extension s stream apis. example kerror hosturirequest kurimethod method const char uri const char headers const char entity unsigned long entitysize void notifydata boolean usecache void cxurinotify const char uri kstatus status void notifydata issue networking-1 in the netscape model netscape plug-ins the data corresponding to a network request are sent to the component extension by the host implementation by creating a stream it is a callback mechanism. should we reused this mechanism or do we want to tie all asynchronous requests with one probably dom event model 1.13 editing 2 many component extensions will involve editing functions so the api must provide a method for access to editing functionalities character input drawing interfaces etc. these must be available in a device independent manner. this requirement also means that the available rendering space may need to be dynamically re-sized see also 1.1.2 linebreak size and rectangle negotiation multiple rectangles 1.13.1 editing mode 1 the component extension api must provide an interface that allows the notification of the toggle between edit and view modes. this api must be present on both the host implementation and the component extension. 1.14 associations registrations negociations 1 in order for the component extension to be able to extend the host dom implementation there must be a way for the component extension to register its own dom implementation in the host dom implementation. in that case the dom implementation node factories in document must create dom nodes using the registered component extensions node for the corresponding types. only the construction of the dom nodes is affected by the registrations not the building of the dom tree. if the component extension does not provide a dom implementation the host implementation must build the entire dom tree itself including for the content addressed by the component extension. if the host implementation provides support for xml 1.0 xml documents it must also implement the namespaces support defined in the namespaces recommendation xml namespaces namespace conflicts resolution between component extensions must be resolved by the host implementation. there must be a way for the user to choose between component extension implementations in case of conflicts. the set of functionalities provided by the host implementation must be accessible to the component extension. the same applies for the component extension the host implementation must have a way to query the set of functionalities provided by the component extension. there are severals ways to extend the host implementation. technologies such as xbl or ie behaviors must be considered. the group might decide to come up with a modular architecture for an xml parser that will permit some of the xml content to be handled by other component. a general stream api should be addressed by the component extension to gain access to their data. 1.15 accessibility 2 the component extension api must provide for accessibility requirements. substantially this reinforces the need for several of the requirements listed already such as the ability to specify a content-type rather than a plugin the provision and use of device-independent interaction interfaces. the user agent accessibility guidelines uuag require that access is provided for dom interfaces and platform-specific interfaces for example msaa the java accessibility api etc where they exist. 1.16 versioning 1 the component extension api should have an identifiable versioning mechanism. the version information must change each time the functionality is changed. i am not sure it is necessary to discuss techniques here as is done in the following paragraph. one technique for achieving this is to provide the naming for functionalities and use a mechanism like cc pp for identifying the available functionalities. although this seems a little heavy for this purpose and seems to be better suited to using various unstandardized systems rather than for a standardized system. 1.17 storage persistence 2 the host implementation will allow the component extension to save data in persistent storage or a file system. this ability will be governed by the security model associated with the component extension. for example a web page has the ability to store cookies in the file system of the host. but a sandbox model exists there. furthermore the user may block web pages from setting cookies. the storage functionality can be divided into reading and writing data specific to the component extension. private storage example saving high scores in a game. storing cookies is an example in the context of a web page. reading and writing data from the global data. public storage example reading list of addresses or a specific address from an addressbook. 3 for the first item the host implementation may provide the component extension apis to get and set values. for example to set hostsetattribute newscore itoa newscore to read length hostgetdatasize highscores if length 0 scorestring memalloc length hostgetattribute highscores scorestring if the security settings of the component extension do not allow these operations then these operations will fail. or the user maybe prompted for advice. see also wap persistent storage 1.18 memory management 1 memory management would include apis for allocating a block of memory resizing the block of memory releasing the block of memory and flushing memory from the host s space. issue memory-1 how much memory should a plugin be allowed probable answer system dependent. if the allocation function fails an exception will be generated. issue memory-2 what about read write if the allocate apis return a pointer as the netscape apis do what will prevent a plugin to do something like char s memalloc 100 s 2000 a on a system that doesn t have a memory management unit this may freeze the system. 1.19 security security issues must be considered for each of the functionalities of the component extension api. a glossary component extension the term component extension also well-known as plug-ins in web browsers refers to any software in charge of providing the client-side part of the component extension api. it is a program that runs as part of the host implementation and that is not part of content. host implementation the term host implementation refers to any software in charge of providing the server-side part of the component extension api. softwares may include web browsers media players component extensions and other programs including assistive technologies that help in retrieving and processing this includes rendering web content. application programming interface api an application programming interface api defines how communication may take place between applications. it is a set of functions or methods used to access some functionality. b references css level 2 w3c world wide web consortium cascading style sheets level 2 specification may 1998. available at http www.w3.org tr 1998 rec-css2-19980512 dom level 2 core w3c world wide web consortium document object model level 2 core specification november 2000. available at http www.w3.org tr 2000 rec-dom-level-2-core-20001113 dom level 3 core w3c world wide web consortium document object model level 3 core specification september 2001. available at http www.w3.org tr dom-level-3-core dom level 2 style sheets and css w3c world wide web consortium document object model level 3 views and formatting specification november 2000. available at http www.w3.org tr 2000 rec-dom-level-2-style-20001113 dom level 3 views and formatting w3c world wide web consortium document object model level 3 views and formatting november 2000. available at http www.w3.org tr 2000 wd-dom-level-3-views-20001115 netscape plug-ins netscape plug-in guide 1998. available at http developer.netscape.com docs manuals communicator plugin index.htm opentype microsoft opentype specification april 2001. available at http www.microsoft.com typography otspec default.htm rfc2396 ietf internet engineering task force rfc 2396 uniform resource identifiers uri generic syntax eds. t. berners-lee r. fielding l. masinter. august 1998. available at http www.ietf.org rfc rfc2396.txt svg 1.0 w3c world wide web consortium scalable vector graphics svg 1.0 specification september 2001. available at http www.w3.org tr svg smil 2.0 w3c world wide web consortium synchronized multimedia integration language smil 2.0 august 2001. available at http www.w3.org tr smil20 smil animation w3c world wide web consortium smil animation september 2001. available at http www.w3.org tr smil-animation user agent accessibility guidelines 1.0 w3c world wide web consortium user agent accessibility guidelines 1.0 september 2001. available at http www.w3.org tr uaag10 wap persistent storage wap forum wireless application forum wap persistent storage interface may 2001. available at http www1.wapforum.org tech documents wap-227-pstor-20010530-a.pdf xml w3c world wide web consortium extensible markup language xml 1.0 october 2000. available at http www.w3.org tr 2000 rec-xml-20001006 xml information set w3c world wide web consortium xml information set august 2001. available at http www.w3.org tr 2001 pr-xml-infoset-20010810 xml namespaces w3c world wide web consortium namespaces in xml january 1999. available at http www.w3.org tr 1999 rec-xml-names-19990114 c contributors the people who contributed to this document are the members of the hypertext coordination group and the participants of the oslo face-to-face meeting jonny axelsson opera bert bos w3c angel diaz ibm jon ferraiolo adobe max froumentin w3c rick graham bitflash stein kulseth opera dean jackson w3c philippe le h garet w3c h kon lie opera rune lillesveen opera chris lilley w3c charles mccathienevile w3c steven pemberton cwi w3c vincent quint w3c hypertext cg chair tapas roy openwave peter stark ericksson ray whitmer netscape aol steve zilles adobe 