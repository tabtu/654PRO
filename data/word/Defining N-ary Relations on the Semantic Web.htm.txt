defining n-ary relations on the semantic web defining n-ary relations on the semantic web w3c working group note 12 april 2006 this version http www.w3.org tr 2006 note-swbp-n-aryrelations-20060412 latest version http www.w3.org tr swbp-n-aryrelations previous version http www.w3.org tr 2004 wd-swbp-n-aryrelations-20040721 editors natasha noy stanford university alan rector university of manchester contributors pat hayes ihmc chris welty ibm research also see acknowledgements. copyright 2006 w3c mit ercim keio all rights reserved. w3c liability trademark and document use rules apply. abstract in semantic web languages such as rdf and owl a property is a binary relation it is used to link two individuals or an individual and a value. however in some cases the natural and convenient way to represent certain concepts is to use relations to link an individual to more than just one individual or value. these relations are called n-ary relations. for example we may want to represent properties of a relation such as our certainty about it severity or strength of a relation relevance of a relation and so on. another example is representing relations among multiple individuals such as a buyer a seller and an object that was bought when describing a purchase of a book. this document presents ontology patterns for representing n-ary relations in rdf and owl and discusses what users must consider when choosing these patterns. status of this document this section describes the status of this document at the time of its publication. other documents may supersede this document. a list of current w3c publications and the latest revision of this technical report can be found in the w3c technical reports index at http www.w3.org tr this document is a working group note produced by the semantic web best practices and deployment working group part of the w3c semantic web activity. this document is one of a set of documents providing an introduction and overview of ontology design patterns produced by the swbpd working group s ontology engineering and patterns task force. as of the publication of this working group note the swbpd working group has completed work on this document. changes from the previous working draft are summarized in an appendix. comments on this document may be sent to public-swbp-wg@w3.org a mailing list with a public archive. further discussion on this material may also be sent to the semantic web interest group mailing list semantic-web@w3.org also with a public archive. publication as a working group note does not imply endorsement by the w3c membership. this is a draft document and may be updated replaced or obsoleted by other documents at any time. it is inappropriate to cite this document as other than work in progress. this document was produced by a group operating under the 5 february 2004 w3c patent policy. this document is informative only. w3c maintains a public list of any patent disclosures made in connection with the deliverables of the group that page also includes instructions for disclosing a patent. an individual who has actual knowledge of a patent which the individual believes contains essential claim s must disclose the information in accordance with section 6 of the w3c patent policy. table of contents general issues use case examples representation patterns vocabulary for n-ary relations in rdf and owl pattern 1 introducing a new class for a relation use case 1 additional attributes describing a relation use case 2 different aspects of the same relation use case 3 n-ary relation with no distinguished participant considerations when introducing a new class for a relation pattern 2 using lists for arguments in a relation n-ary relations and reification in rdf additional background note on vocabulary relations and instances of relations properties and property instances anonymous vs named instances in these patterns notes references changes acknowledgements general issues in semantic web languages such as rdf and owl a property is a binary relation instances of properties link two individuals. often we refer to the second individual as the value or to both both individuals as arguments see note on vocabulary issue 1 if property instances can link only two individuals how do we deal with cases where we need to describe the instances of relations such as its certainty strength etc issue 2 if instances of properties can link only two individuals how do we represent relations among more than two individuals n-ary relations issue 3 if instances of properties can link only two individuals how do we represent relations in which one of the participants is an ordered list of individuals rather than a single individual the solutions to the first two problems are closely linked the third problem is fundamentally different although it can be adapted to meet issue one in special cases. note that we don t use rdf reification in these patterns the reasons for this decision are discussed in the final section. data descriptions used in this document the data format used in this document is turtle turtle used to show each triple explicitly. turtle allows uris to be abbreviated with prefixes prefix dc http purl.org dc elements 1.1 prefix http example.org book book1 dc title defining n-ary relations on the semantic web use case examples several common use cases fall under the category of n-ary relations. here are some examples christine has breast tumor with high probability. there is a binary relation between the person christine and diagnosis breast_tumor_christine and there is a qualitative probability value describing this relation high steve has temperature which is high but falling. the individual steve has two values for two different aspects of a has_temperature relation its magnitude is high and its trend is falling. john buys a lenny the lion book from books.example.com for 15 as a birthday gift. there is a relation in which individual john entity books.example.com and the book lenny_the_lion participate. this relation has other components as well such as the purpose birthday_gift and the amount 15 united airlines flight 3177 visits the following airports lax dfw and jfk. there is a relation between the individual flight and the three cities that it visits lax dfw jfk. note that the order of the airports is important and indicates the order in which the flight visits these airports. another way to think about the use cases is how they might occur in the evolution of an ontology. we discover that a relation that we thought was binary really needs a further argument a common origin of use case 1. we discover that two binary properties always go together and should be represented as one n-ary relation a common origin for use case 2 from the beginning we realize that the relation is really amongst several things a common origin for use case 3 the nature of the relation is such that one or more of the arguments is fundamentally a sequence rather than a single individual use case 4. representation patterns as we describer earlier in semantic web languages properties are binary relations. each instance of a property links an individual to another individual or a value as shown below. we would like to have another individual or simple value c to be part of this relation instance p now refers to an instance of a relation among a b and c there might be other individuals d e and f however for simplicity we will illustrate most of our use cases assuming a single additional individual. we can handle more individuals in exactly the same way. one common solution to this problem pattern 1 is to represent the relation as a class rather than a property. individual instances of such classes correspond to instances of the relation. additional properties provide binary links to each argument of the relation. we can model examples 1 2 and 3 above using this pattern. for instance in the example 1 the instance of a new class diagnosis_relation would represent the fact that christine has been diagnosed with a breast tumor with high probability. similarly in the example 3 the instance of a class purchase would represent the fact that john bought the book lenny the lion from books.com for 15. the second solution pattern 2 is to represent several individuals participating in the relation as a collection or an ordered list. we use this solution when the order of the arguments of the n-ary relation is important in the model as in the example 4 above. vocabulary for n-ary relations in rdf and owl the task force plans to produce a suggested vocabulary for describing that a class represents an n-ary relation and for defining mappings between n-ary relations in rdf and owl and other languages. a note on this vocabulary is forthcoming. pattern 1 introducing a new class for a relation we present a pattern where we create a new class and n new properties to represent an n-ary relation. an instance of the relation linking the n individuals is then an instance of this class. we consider three use cases for this pattern illustrated by examples 1-3 above. ontologically the classes created in this way are often called reified relations reified relations play important roles in many ontologies3 e.g. ontoclean dolce sowa galen however the rdf and topic map communities have each used the word reify to mean other things see the note below therefore to avoid confusion we do not use the term reification in this document. use case 1 additional attributes describing a relation in the first use case we need to represent an additional attribute describing a relation instance example 1 christine has breast tumor with high probability we create an individual that represents the relation instance itself with links from the subject of the relation to this instance and with links from this instance to all participants that represent additional information about this instance for the example 1 above christine has breast tumor with high probability the individual christine has a property has_diagnosis that has another object diagnosis_relation_1 an instance of the class diagnosis_relation as its value the individual diagnosis_relation_1 here represents a single object encapsulating both the diagnosis breast_tumor_christine a specific instance of disease and the probability of the diagnosis high 3. it contains all the information held in the original 3 arguments who is being diagnosed what the diagnosis is and what the probability is. we use blank nodes in rdf to represent instances of a relation. christine a person has_diagnosis diagnosis_relation_1 diagnosis_relation_1 a diagnosis_relation diagnosis_probability high diagnosis_value breast_tumor_christine each of the 3 arguments in the original n-ary relation who is being diagnosed what the diagnosis is and what the probability is gives rise to a true binary relationship. in this case there are three has_diagnosis diagnosis_value and diagnosis_probability.4 the class definitions for the individuals in this pattern look as follows the additional labels on the links indicate the owl restrictions on the properties. we define both diagnosis_value and diagnosis_probability as functional properties thus requiring that each instance of diagnosis_relation has exactly one value for disease and one value for probability. in rdfs which does not have the owl restrictions or functional properties the links represent rdfs range constraints on the properties. for example the class diagnosis_relation is the range of the property has_diagnosis. here is a definition of the class diagnosis_relation in owl assuming that both properties diagnosis_value and diagnosis_probability are defined as functional we provide full code for the example in owl and rdfs below diagnosis_relation a owl class rdfs subclassof a owl restriction owl somevaluesfrom disease owl onproperty diagnosis_value rdfs subclassof a owl restriction owl allvaluesfrom probability_values owl onproperty diagnosis_probability in the definition of the person class of which the individual christine is an instance we specify a property has_diagnosis with the range restriction going to the diagnosis_relation class of which diagnosis_relation_1 is an instance person a owl class rdfs subclassof a owl restriction owl allvaluesfrom diagnosis_relation owl onproperty has_diagnosis note that in discussing this pattern we are not making any suggestion on the best way to represent probability pf an event. we simply use it as an example here. rdfs code for this example rdfs owl code for this example n3 rdf xml use case 2 different aspects of the same relation we have a different use case in the example 2 above steve has temperature which is high but falling in the example with the diagnosis many will view the relationship we were representing as in a fact still a binary relation between the individual christine and the diagnosis breast_tumor_christine that has a probability associated with it. the relation in this example is between the individual steve and the object representing different aspects of the temperature he has. in most intended interpretations this instance of a relation cannot be viewed as an instance of a binary relation with additional attributes attached to it. rather it is a relation instance relating the individual steve and the complex object representing different facts about his temperature. such cases often come about in the course of evolution of an ontology when we realize that two relations need to be collapsed. for example initially we might have had two properties has_temperature_level and has_temperature_trend both relating to people. we might then have realized that these properties really are inextricably intertwined because we need to talk about temperatures that are elevated but falling. the rdfs and owl patterns that implement this intuition are however the same as in the previous example. a class person of which the individual steve is an instance has a property has_temperature which has as a range the relation class temperature_observation. instances of the class temperature_observation such as temperature_observation_1 in the figure in turn have properties for temperature_value and temperature_trend. rdfs code for this example rdfs owl code for this example n3 rdf xml use case 3 n-ary relation with no distinguished participant in some cases the n-ary relationship links individuals that play different roles in a structure without any single individual standing out as the subject or the owner of the relation such as purchase in the example 3 above john buys a lenny the lion book from books.example.com for 15 as a birthday gift here the relation explicitly has more than one participant and in many contexts none of them can be considered a primary one. in this case we create an individual to represent the relation instance with links to all participants in our specific example the representation will look as follows purchase_15 is an individual instance of the purchase class representing an instance of a relation 6 purchase_1 a purchase has_buyer john has_object lenny_the_lion has_purpose birthday_gift has_amount 15 has_seller books.example.com the following diagram shows the corresponding classes and properties. for the sake of the example we specify that each purchase has exactly one buyer a person exactly one seller a company exactly one amount and at least one object an object the diagram refers to owl restrictions. in rdfs the arrows can be treated as rdfs range links. the class purchase is defined as follows in owl see the rdfs file below for the definition in rdfs purchase a owl class rdfs subclassof a owl restriction owl allvaluesfrom purpose owl onproperty has_purpose rdfs subclassof a owl restriction owl cardinality 1 owl onproperty has_buyer rdfs subclassof a owl restriction owl onproperty has_buyer owl somevaluesfrom person rdfs subclassof a owl restriction owl cardinality 1 owl onproperty has_seller rdfs subclassof a owl restriction owl onproperty has_seller owl somevaluesfrom company rdfs subclassof a owl restriction owl onproperty has_object owl somevaluesfrom object note that representation of owl restrictions themselves follows this pattern an owl restriction is essentially a ternary relation between a class a property and a restriction value. in this case an instance of the restriction class is similar to the instance of purchase. rdfs code for this example rdfs owl code for this example n3 rdf xml considerations when introducing a new class for a relation in our example we did not give meaningful names to instances of properties or to the classes used to represent instances of n-ary relations but merely label them temperature_observation_1 purchase_1 etc. in most cases these individuals do not stand on their own but merely function as auxiliaries to group together other objects. hence a distinguishing name serves no purpose. note that a similar approach is taken when reifying statements in rdf. creating a class to represent an n-ary relation limits the use of many owl constructs and creates a maintenance problem. the problem arises when we want to have local range or cardinality restrictions on some role in the n-ary relation that depend on the class of some other role. for example we might want to say that we buy only instances of a class book from companies in the category bookseller cf. use case 3 expressing this constraint requires a special subclass of the n-ary relation class that represents the combination of restrictions. for instance we will have to create a class book_purchase with the corresponding range restrictions for the property seller allvaluesfrom bookseller and object allvaluesfrom book we end up having to build an explicit lattice of classes to represent all the possible combinations. owl allows definition of inverse properties. defining inverse properties with n-ary relations using any of the patterns above requires more work than with binary relations. in order to specify inverse properties for n-ary relations we must specify an inverse for each of the properties participating in the n-ary relation with the proper constraints consider the example of john buying the lenny_the_lion book. we may want to have an instance of an inverse relation pointing from the lenny_the_lion book to the person who bought it. if we had a simple binary relation john buys lenny_the_lion defining an inverse is simple we simply define a property is_bought_by as an inverse of buys is_bought_by a owl objectproperty owl inverseof buys with the purchase relation represented as an instance however we need to add inverse relations between participants in the relation and the instance relation itself for example the definitions of the inverse relations for buyer and object of a purchase look as follows is_buyer_for a owl objectproperty owl inverseof has_buyer is_object_for a owl objectproperty owl inverseof has_object in the definition of the class person we include an allvaluesfrom restriction on the property is_buyer_for to restrict the values for this property to instances of the class purchase person a owl class rdfs subclassof a owl restriction owl onproperty is_buyer_for owl allvaluesfrom purchase note that the value of the inverse property is_buyer_for for the individual john for example is the individual purchase_1 rather than the object or recipient of the purchase. pattern 2 using lists for arguments in a relation some n-ary relations do not naturally fall into either of the use cases above but are more similar to a list or sequence of arguments. the example 4 above united airlines flight 3177 visits the following airports lax dfw and jfk falls into this category. in this example the relation holds between the flight and the airports it visits in the order of the arrival of the aircraft at each airport in turn. this relation might hold between many different numbers of arguments and there is no natural way to break it up into a set of distinct properties relating the flight to each airport. at the same time the order of the arguments is highly meaningful. in cases where all but one participant in a relation do not have a specific role and essentially form an ordered list it is natural to connect these arguments into a sequence according to some relation and to relate the one participant to this sequence or the first element of the sequence we represent the example below using an ordering relation nextsegment between instances of the flightsegment class. each flight segment has a property for the destination of that segment. note that we add a special subclass of flight segment finalflightsegment with a maximum cardinality of 0 on the nextsegment property to indicate the end of the sequence. rdf supplies a vocabulary for lists the collection vocabulary which can also be used in cases where a group of arguments to the relation have no special role. we do not use the rdf collection vocabulary in this example because it is less practical to use a generic ordering relation when we are representing something more specific. in this example we represent a temporal order among constituents. we can represent the ontology for this example in owl. note that using the rdf list vocabulary in owl would have put the ontology in owl full see the corresponding section of the owl guide for the comparison of owl full and owl dl the following ontology is in owl lite flight a owl class flight_sequence a owl objectproperty owl functionalproperty rdfs domain flight rdfs range flightsegment flightsegment a owl class rdfs subclassof owl thing rdfs subclassof a owl restriction owl cardinality 1 owl onproperty destination rdfs subclassof a owl restriction owl allvaluesfrom airport owl onproperty destination next_segment a owl objectproperty owl functionalproperty rdfs domain flightsegment rdfs range flightsegment finalflightsegment a owl class rdfs comment the last flight segment has no next_segment rdfs subclassof flightsegment rdfs subclassof a owl restriction owl maxcardinality 0 owl onproperty next_segment airport a owl class destination a owl objectproperty owl functionalproperty rdfs domain flightsegment rdfs code for this example rdfs owl code for this example n3 rdf xml n-ary relations and reification in rdf it may be natural to think of rdf reification when representing n-ary relations. we do not want to use the rdf reification vocabulary to represent n-ary relations in general for the following reasons. the rdf reification vocabulary is designed to talk about statements individuals that are instances of rdf statement. a statement is a object predicate subject triple and reification in rdf is used to put additional information about this triple. this information may include the source of the information in the triple for example. in n-ary relations however additional arguments in the relation do not usually characterize the statement but rather provide additional information about the relation instance itself. thus it is more natural to talk about instances of a diagnosis relation or a purchase rather than about a statement. in the use cases that we discussed in the note the intent is to talk about instances of a relation not about statements about such instances. additional background note on vocabulary relations and instances of relations properties and property instances we usually think of semantic web languages as consisting of triples of the form individual1-property-individual2 traditionally these have been termed object-attribute-value triples but we do not use this language here because it conflicts with rdf usage. however formally we interpret properties as representing relations i.e. sets of ordered pairs of individuals. each instance of a relation is just one of those ordered pairs. the property in each triple is fundamentally different from the individuals in the triple. it merely indicates to which relation the ordered pair consisting of the two individuals belongs. we normally name individuals we do not normally name the ordered pairs. anonymous vs named instances in these patterns often in cases such as use case 1 we wish to regard two instances of the relation that have the same argument as equivalent. we can capture this intuition by using rdf blank nodes e.g. diagnosis_relation to represent relation instances. in use case 2 we wish to consider the possibility that there might be two distinct purchases with identical arguments. in that case the node should be named e.g. purchase_1. notes reified relations play an important role or have a special status in a number of ontologies e.g. see sowa j. knowledge representation. morgan kaufmann 1999 welty c. and guarino n. supporting ontological uow.acc.tab.analysis of taxonomic relationships. data and knowledge engineering 39 1 51-74. for simplicity we represent each disease as an individual. this decision may not always be appropriate and we refer the reader to a different note to be written similarly for simplicity in owl we represent probability values as a class that is an enumeration of three individuals high medium and low probability_values a owl class owl equivalentclass a owl class owl oneof high medium low there are other ways to represent partitions of values. please refer to a note on representing specified values in owl specified values in rdf schema version we represent them simply as strings also for simplicity reasons. rdf has a property rdf value that is appropriate in examples such as the diagnosis example here. while rdf value has no meaning on its own the rdf specification encourages its use as a vocabulary element to identify the main component of a structured value of a property. therefore in our example we made diagnosis_value a subproperty of rdf value property instead of making it a direct instance of rdf property to indicate that diagnosis_value is indeed the main component of a diagnosis. note that we used a named individual for an instance of the class purchase purchase_1 rather than an anonymous blank node here. in this example there might be two distinct purchases with exactly the same arguments. for simplicity we will ignore the fact that the amount is expressed in and will use a simple number as the value for the property. for a discussion on how to represent units and quantities in owl please refer to a different note to be written references specified values representing specified values in owl value partitions and value sets alan rector editor w3c working draft 3 august 2004 http www.w3.org tr swbp-specified-values owl overview owl web ontology language overview deborah l. mcguinness and frank van harmelen editors w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-owl-features-20040210 latest version available at http www.w3.org tr owl-features owl guide owl web ontology language guide michael k. smith chris welty and deborah l. mcguinness editors w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-owl-guide-20040210 latest version available at http www.w3.org tr owl-guide owl semantics and abstract syntax owl web ontology language semantics and abstract syntax peter f. patel-schneider patrick hayes and ian horrocks editors w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-owl-semantics-20040210 latest version available at http www.w3.org tr owl-semantics rdf primer rdf primer frank manola and eric miller editors w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-rdf-primer-20040210 latest version available at http www.w3.org tr rdf-primer rdf semantics rdf semantics pat hayes editor w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-rdf-mt-20040210 latest version available at http www.w3.org tr rdf-mt rdf vocabulary rdf vocabulary description language 1.0 rdf schema dan brickley and r. v. guha editors w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-rdf-schema-20040210 latest version available at http www.w3.org tr rdf-schema turtle turtle terse rdf triple language dave beckett. changes merged patterns 1 and 2 into one pattern with different use cases. the same use cases remain but they are described as different use cases for the same pattern. removed consideration bullet talking about logical equivalence of patterns 1 and 2 since they are a single pattern now added more discussion to general issues and use cases added pattern 2 using rdf lists added the flight example changed the wording under representation pattern use blank nodes for relation instances in pattern 1 and pattern 2 added a section on n-ary relations and reification in rdf added a section on additional background added references changed some of references to relation to relation instance or instance of relation removed examples in abstract syntax added acknowledgements acknowledgements the editors would like to thank the following working group members for their contributions to this document pat hayes jeremy carroll chris welty michael uschold bernard vatant. frank manola ivan herman jamie lawrence have also contributed to the document. this document is a product of the ontology engineering and patterns task force of the semantic web best practices and deployment working group. 