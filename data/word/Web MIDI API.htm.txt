web midi api web midi api w3c working draft 26 november 2013 this version http www.w3.org tr 2013 wd-webmidi-20131126 latest published version http www.w3.org tr webmidi previous version http www.w3.org tr 2012 wd-webmidi-20121213 latest editor s draft http webaudio.github.io web-audio-api editors jussi kalliokoski chris wilson google versioning repository https github.com webaudio web-midi-api issues tracker https github.com webaudio web-midi-api issues state open test suite https github.com jussi-kalliokoski web-midi-test-suite unofficial working group audio working group comments public-audio@w3.org archives copyright 2012-2013 w3c mit ercim keio beihang all rights reserved. w3c liability trademark and document use rules apply. abstract some user agents have music devices such as synthesizers keyboard and other controllers and drum machines connected to their host computer or device. the widely adopted musical instrument digital interface midi protocol enables electronic musical instruments controllers and computers to communicate and synchronize with each other. midi does not transmit audio signals instead it sends event messages about musical notes controller signals for parameters such as volume vibrato and panning cues and clock signals to set the tempo and system-specific midi communications e.g. to remotely store synthesizer-specific patch data this same protocol has become a standard for non-musical uses such as show control lighting and special effects control. this specification defines an api supporting the midi protocol enabling web applications to enumerate and select midi input and output devices on the client system and send and receive midi messages. it is intended to enable non-music midi applications as well as music ones by providing low-level access to the midi devices available on the users systems. the web midi api is not intended to describe music or controller inputs semantically it is designed to expose the mechanics of midi input and output interfaces and the practical aspects of sending and receiving midi messages without identifying what those actions might mean semantically e.g. in terms of modulate the vibrato by 20hz or play a g#7 chord other than in terms of changing a controller value or sending a set of note-on messages that happen to represent a g#7 chord to some users midi has become synonymous with standard midi files and general midi. that is not the intent of this api the use case of simply playing back a smf file is not within the purview of this specification it could be considered a different format to be supported by the html5 audio element for example the web midi api is intended to enable direct access to devices that respond to midi external synthesizers or lighting systems for example or even the software synthesizers that are built in to many common operating systems. the web midi api is also explicitly designed to enable a new class of applications on the web that can respond to midi controller inputs using external hardware controllers with physical buttons knobs and sliders as well as musical controllers like keyboard guitar or wind instrument controllers to control web applications. the web midi api is also expected to be used in conjunction with other apis and elements of the web platform notably the web audio api. this api is also intended to be familiar to users of midi apis on other systems such as apple s coremidi and microsoft s windows midi api. status of this document this section describes the status of this document at the time of its publication. other documents may supersede this document. a list of current w3c publications and the latest revision of this technical report can be found in the w3c technical reports index at http www.w3.org tr this document was published by the audio working group as an working draft. if you wish to make comments regarding this document please send them to public-audio@w3.org subscribe archives all comments are welcome. publication as a working draft does not imply endorsement by the w3c membership. this is a draft document and may be updated replaced or obsoleted by other documents at any time. it is inappropriate to cite this document as other than work in progress. this document was produced by a group operating under the 5 february 2004 w3c patent policy. w3c maintains a public list of any patent disclosures made in connection with the deliverables of the group that page also includes instructions for disclosing a patent. an individual who has actual knowledge of a patent which the individual believes contains essential claim s must disclose the information in accordance with section 6 of the w3c patent policy. table of contents 1. introduction 2. conformance 3. terminology 4. obtaining access to midi devices 4.1 requestmidiaccess 4.1.1 methods 4.2 midioptions dictionary 4.2.1 dictionary midioptions members 4.3 midiinputmap interface 4.3.1 attributes 4.3.2 methods 4.4 midioutputmap interface 4.4.1 attributes 4.4.2 methods 4.5 midisuccesscallback 4.5.1 callback midisuccesscallback parameters 4.6 midierrorcallback 4.6.1 callback midierrorcallback parameters 5. midiaccess interface 5.1 attributes 6. midiport interface 6.1 attributes 6.2 midiinput interface 6.2.1 attributes 6.3 midioutput interface 6.3.1 methods 7. midimessageevent interface 7.1 attributes 7.2 midimessageeventinit interface 7.2.1 dictionary midimessageeventinit members 8. midiconnectionevent interface 8.1 attributes 8.2 midiconnectioneventinit interface 8.2.1 dictionary midiconnectioneventinit members 9. examples of web midi api usage in javascript 9.1 getting access to the midi system 9.2 requesting access to the midi system with system exclusive support 9.3 listing inputs and outputs 9.4 handling midi input 9.5 sending midi messages to an output device 9.6 a simple loopback 9.7 a simple monophonic sine wave midi synthesizer 10. security and privacy considerations of midi a. references a.1 normative references 1. introduction this section is non-normative. the web midi api specification defines a means for web developers to enumerate manipulate and access midi devices for example interfaces that may provide hardware midi ports with other devices plugged in to them and usb devices that support the usb-midi specification. having a web api for midi enables web applications that use existing software and hardware synthesizers hardware music controllers and light systems and other mechanical apparatus controlled by midi. this api has been defined with this wide variety of use cases in mind. the approaches taken by this api are similar to those taken in apple s coremidi api and microsoft s windows midi api that is the api is designed to represent the low-level software protocol of midi in order to enable developers to build powerful midi software on top. the api enables the developer to enumerate input and output interfaces and send and receive midi messages but similar to the aforementioned apis it does not attempt to semantically define or interpret midi messages beyond what is necessary to robustly support current devices. the web midi api is not intended to directly implement high-level concepts such as sequencing it does not directly support standard midi files for example although a standard midi file player can be built on top of the web midi api. it is also not intended to semantically capture patches or controller assignments as general midi does such interpretation is outside the scope of the web midi api though again general midi can easily be utilized through the web midi api 2. conformance as well as sections marked as non-normative all authoring guidelines diagrams examples and notes in this specification are non-normative. everything else in this specification is normative. the key words must must not required should should not recommended may and optional in this specification are to be interpreted as described in rfc2119 this specification defines conformance criteria that apply to a single product the user agent that implements the interfaces that it contains. implementations that use ecmascript to implement the apis defined in this specification must implement them in a manner consistent with the ecmascript bindings defined in the web idl specification webidl as this specification uses that specification and terminology. 3. terminology the concepts queue a task and fires a simple event are defined in html5 the terms event handlers and event handler event types and corresponding eventhandler interface are defined in html5 the uint8array interface is defined in typed-arrays the term octet is defined in webidl the web audio api and its associated interfaces and concepts are defined in webaudio the event interface is defined in dom4 the domerror interface is defined in dom-level-3-core the domhighrestimestamp interface is defined in highres-time the terms midi midi device midi input port midi output port midi interface midi message midi system real-time message and system exclusive are defined in midi the promise interface is currently defined in the whatwg dom specification. 4. obtaining access to midi devices 4.1 requestmidiaccess partial interface navigator promise requestmidiaccess optional midioptions options 4.1.1 methods requestmidiaccess when invoked returns a promise object representing a request for access to midi devices on the user s system. requesting midi access should prompt the user for access to midi devices particularly if system exclusive access is requested. in some scenarios this permission may have already been implicitly or explicitly granted in which case this prompt may not appear. if the user gives express permission or the call is otherwise approved the vended promise s resolvecallback is invoked as a midisuccesscallback i.e. with a midiaccess object and a midioptions object as its arguments. the underlying system may choose to allow the user to select specific midi interfaces to expose to this api i.e. pick and choose interfaces on an individual basis although this is not required. the system may also choose to prompt or not based on whether system exclusive support is requested as system exclusive has greater privacy and security implications. if the user declines or the call is denied for any other reason the promise s rejectcallback if any is invoked as a midierrorcallback. when the requestmidiaccess method is called the user agent must run the algorithm to request midi access let promise be a new promise object and resolver be its associated resolver. return promise and run the following steps asynchronously. optionally e.g. based on a previously-established user preference for security reasons or due to platform limitations jump to the step labeled failure below. optionally e.g. based on a previously-established user preference jump to the step labeled success below. prompt the user in a user-agent-specific manner for permission to provide the entry script s origin with a midiaccess object representing control over user s midi devices. this prompt may be contingent upon whether system exclusive support was requested and may allow the user to enable or disable that access. if permission is denied jump to the step labeled failure below. if the user never responds this algorithm will never progress beyond this step. if permission is granted continue the following steps. success let access be a new midiaccess object. it is possible to call requestmidiaccess multiple times this may prompt the user multiple times so it may not be best practice and the same instance of midiaccess will not be returned each time. call resolver s accept value method with access as value argument. terminate these steps. failure let error be a new domerror. this should be of type securityerror if the user or their security settings denied the application from creating a midiaccess instance with the requested options invalidstateerror if the underlying systems raise any errors or otherwise it should be of type notsupportederror call resolver s reject value method with error as value argument. parameter type nullable optional description options midioptions return type promise 4.2 midioptions dictionary this dictionary contains optional settings that may be provided to the requestmidiaccess request. dictionary midioptions boolean sysex 4.2.1 dictionary midioptions members sysex of type boolean this member informs the system whether the ability to send and receive system exclusive messages is requested or allowed on a given midiaccess object. on the option passed to requestmidiaccess if this member is set to true but system exclusive support is denied either by policy or by user action the access request will fail with a securityerror error. if this support is not requested and allowed the system will throw exceptions if the user tries to send system exclusive messages and will silently mask out any system exclusive messages received on the port. in the options parameter passed to the resolvecallback this member indicates whether system exclusive is allowed on the midiaccess. 4.3 midiinputmap interface interface attribute readonly int size function keys void function domstring function entries void function array function values void function midiinput midiinput get domstring key boolean has domstring key 4.3.1 attributes size of type readonly int the number of available midi input ports at the current time. 4.3.2 methods entries iterator for map entries the passed arrays would contain midikeytype midiinput parameter type nullable optional description array void function return type function get getter for a particular input parameter type nullable optional description key domstring return type midiinput has returns true if the keyed port currently exists and is available. parameter type nullable optional description key domstring return type boolean keys iterator for keys parameter type nullable optional description domstring void function return type function values iterator for values parameter type nullable optional description midiinput void function return type function this type is used to represent all the currently available midi input ports as a mapclass-like interface. this enables to tell how many entries there are var numberofmidiinputs inputs.size add each of the ports to a select box inputs.values function port var opt document.createelement option opt.text port.name document.getelementbyid inputportselector add opt or you could express as for input in inputs var opt document.createelement option opt.text input.name document.getelementbyid inputportselector add opt 4.4 midioutputmap interface interface attribute readonly int size function keys void function domstring function entries void function array function values void function midioutput midioutput get domstring key boolean has domstring key 4.4.1 attributes size of type readonly int the number of available midi output ports at the current time. 4.4.2 methods entries iterator for map entries the passed arrays would contain midikeytype midioutput parameter type nullable optional description array void function return type function get getter for a particular input parameter type nullable optional description key domstring return type midioutput has returns true if the keyed port currently exists and is available. parameter type nullable optional description key domstring return type boolean keys iterator for keys parameter type nullable optional description domstring void function return type function values iterator for values parameter type nullable optional description midioutput void function return type function this type is used to represent all the currently available midi output ports as a mapclass-like interface. this enables to tell how many entries there are var numberofmidioutputs inputs.size add each of the ports to a select box outputs.values function port var opt document.createelement option opt.text port.name document.getelementbyid outputportselector add opt or you could express as for output in outputs var opt document.createelement option opt.text input.name document.getelementbyid inputportselector add opt 4.5 midisuccesscallback callback midisuccesscallback void midiaccess access midioptions options 4.5.1 callback midisuccesscallback parameters access of type midiaccess a midiaccess object created to provide script access to the user s midi devices. this object is used to enumerate and obtain access to individual midi devices. note the term midi device in this specification refers to a midi interface available to the host system for example if a hardware midi adapter is connected to the host system it will be enumerated as a single device even if several midi-supporting devices such as synthesizers or drum machines are plugged into hardware midi ports on the adapter. options of type midioptions this parameter describes the options enabled on this midiaccess object. 4.6 midierrorcallback callback midierrorcallback void domerror error 4.6.1 callback midierrorcallback parameters error of type domerror a domerror object representing the reason why creating getting a midiaccess failed. 5. midiaccess interface this interface provides the methods to list midi input and output devices and obtain access to an individual device. interface midiaccess eventtarget readonly attribute midiinputmap inputs readonly attribute midioutputmap outputs attribute eventhandler onconnect attribute eventhandler ondisconnect readonly attribute boolean sysexenabled 5.1 attributes inputs of type midiinputmap readonly the midi input ports available to the system. onconnect of type eventhandler the handler called when a new port is connected. this event handler of type midiconnectionevent must be supported by all objects implementing the midiaccess interface. whenever a previously unavailable midi port becomes available for use the user agent should run the following steps let port be the midiport corresponding to the newly-available port. let event be a newly constructed midiconnectionevent with the port attribute set to the port. fire an event named connectat the midiaccess using the event as the event object. ondisconnect of type eventhandler the handler called when a previously-available port is disconnected. this event handler of type midiconnectionevent must be supported by all objects implementing the midiaccess interface. whenever a previously available midi port becomes unavailable for use the user agent should run the following steps let port be the midiport corresponding to the newly-available port. let event be a newly constructed midiconnectionevent with the port attribute set to the port. fire an event named disconnectat the midiaccess using the event as the event object. outputs of type midioutputmap readonly the midi output ports available to the system. sysexenabled of type boolean readonly this attribute informs the user whether system exclusive support is enabled on this midiaccess. 6. midiport interface this interface represents a midi input or output port. enum midiporttype input output enumeration description input if a midiport is an input port the type member must be this value. output if a midiport is an output port the type member must be this value. interface midiport eventtarget readonly attribute domstring id readonly attribute domstring manufacturer readonly attribute domstring name readonly attribute midiporttype type readonly attribute domstring version attribute eventhandler ondisconnect 6.1 attributes id of type domstring readonly a unique id of the port. this can be used by developers to remember ports the user has chosen for their application. the user agent must ensure that the id is unique to only that port. the user agent should ensure that the id is maintained across instances of the application e.g. when the system is rebooted and when a device is removed from the system. applications may want to cache these ids locally to re-create a midi setup. some systems may not support completely unique persistent identifiers in such cases it will be more challenging to maintain identifiers when another interface is added or removed from the system. this might throw off the index of the requested port. it is expected that the system will do the best it can to match a port across instances of the midi api for example storing the port interface manufacturer name and index in the id and attempting to find any ports with that name to consider as a match. applications may use the comparison of id of midiports to test for equality. manufacturer of type domstring readonly nullable the manufacturer of the port. name of type domstring readonly nullable the system name of the port. ondisconnect of type eventhandler the handler called when a previously-available port is disconnected. this event handler of type disconnect must be supported by all objects implementing midiport interface. type of type midiporttype readonly a descriptor property to distinguish whether the port is an input or an output port. for midioutput this must be output for midiinput this must be input version of type domstring readonly nullable the version of the port. whenever the midi port corresponding to the midiport becomes unavailable for use the user agent should run the following steps let port be the midiport. let event be a newly constructed midiconnectionevent with the port attribute set to the port. fire an event named disconnect at the port using the event as the event object. 6.2 midiinput interface interface midiinput midiport attribute eventhandler onmidimessage 6.2.1 attributes onmidimessage of type eventhandler this event handler of type midimessage must be supported by all objects implementing midiinput interface. whenever the midi port corresponding to the midiinput finishes receiving one or more midi messages the user agent must run the following steps let port be the midiinput. if the midiaccess did not enable system exclusive access and the message is a system exclusive message abort this process. let event be a newly constructed midimessageevent with the timestamp attribute set to the time the message was received by the system and with the data attribute set to a uint8array of midi data bytes representing a single midi message. fire an event named midimessage at the port using the event as the event object. it is specifically noted that midi system real-time messages may actually occur in the middle of system exclusive messages in the input stream in this case the system real-time messages will be dispatched as they occur while the system exclusive message will be buffered until it is complete and then dispatched 6.3 midioutput interface interface midioutput midiport void send sequence octet data optional double timestamp 6.3.1 methods send enqueues the message to be sent to the corresponding midi port. the underlying implementation will if necessary coerce each member of the sequence to an unsigned 8-bit integer. the use of sequence rather than a uint8array enables developers to use the convenience of output.send 0x90 0x45 0x7f rather than having to create a uint8array e.g. output.send new uint8array 0x90 0x45 0x7f while still enabling use of uint8arrays for efficiency in large midi data scenarios e.g. reading standard midi files and sending sysex messages the data contains one or more valid complete midi messages. running status is not allowed in the data as underlying systems may not support it. if the port is disconnected throw an invalidstateerror exception. if data is not a valid sequence or does not contain a valid midi message throw a typeerror exception. if data is a system exclusive message and the midiaccess did not enable system exclusive access throw an invalidaccesserror exception. parameter type nullable optional description data sequence octet the data to be enqueued with each sequence entry representing a single byte of data. timestamp double the time at which to begin sending the data to the port as a domhighrestimestamp a number of milliseconds measured relative to the navigation start of the document if timestamp is not present or is set to zero or another time in the past the data is to be sent as soon as possible. return type void 7. midimessageevent interface an event object implementing this interface is passed to a midiinput s onmidimessage handler when midi messages are received. constructor domstring type optional midimessageeventinit eventinitdict interface midimessageevent event readonly attribute double receivedtime readonly attribute uint8array data 7.1 attributes data of type uint8array readonly a uint8array containing the midi data bytes of a single midi message. receivedtime of type double readonly a domhighrestimestamp specifying when the event occurred. note the dom4 event object has a timestamp member in the event object that will be filled out with the current time but that it is lower precision domtimestamp is defined as an integer number of milliseconds has a different zero reference domtimestamp is the number of milliseconds that has passed since 00 00 00 utc on 1 january 1970 and therefore is less suitable for midi applications. 7.2 midimessageeventinit interface dictionary midimessageeventinit double receivedtime uint8array data 7.2.1 dictionary midimessageeventinit members data of type uint8array a uint8array containing the midi data bytes of a single midi message. receivedtime of type double a domhighrestimestamp specifying when the event occurred. 8. midiconnectionevent interface an event object implementing this interface is passed to a midiaccess ondisconnect handler and if present to any midiports referencing the port when a previously-available port becomes unavailable for example when a midi interface is disconnected and is also passed to a midiaccess onconnect handler when a new port becomes available for example when a midi interface that has been disconnected is plugged in to the computer connection events are not required to be dispatched as some underlying systems do not support them as notification events or such systems may have long time delays as they poll for new devices infrequently. constructor domstring type optional midiconnectioneventinit eventinitdict interface midiconnectionevent event readonly attribute midiport port 8.1 attributes port of type midiport readonly the port that has been connected or disconnected. 8.2 midiconnectioneventinit interface dictionary midiconnectioneventinit midiport port 8.2.1 dictionary midiconnectioneventinit members port of type midiport the port that has been connected or disconnected. 9. examples of web midi api usage in javascript this section is non-normative. the following are some examples of common midi usage in javascript. 9.1 getting access to the midi system this example shows how to request access to the midi system. var midi null global midiaccess object function onmidisuccess midiaccess console.log midi ready midi midiaccess store in the global in real usage would probably keep in an object instance function onmidifailure msg console.log failed to get midi access msg navigator.requestmidiaccess then onmidisuccess onmidifailure 9.2 requesting access to the midi system with system exclusive support this example shows how to request access to the midi system including the ability to send and receive system exclusive messages. var midi null global midiaccess object function onmidisuccess midiaccess console.log midi ready midi midiaccess store in the global in real usage would probably keep in an object instance function onmidifailure msg console.log failed to get midi access msg navigator.requestmidiaccess sysex true then onmidisuccess onmidifailure 9.3 listing inputs and outputs this example gets the list of the input and output ports and prints their information to the console log. function listinputsandoutputs midiaccess for var input in midiaccess.inputs console.log input port type input.type id input.id manufacturer input.manufacturer name input.name version input.version for var output in midiaccess.outputs console.log output port type output.type id output.id manufacturer output.manufacturer name output.name version output.version 9.4 handling midi input this example prints incoming midi messages on a single arbitrary input port to the console log. function onmidimessage event var str midi message received at timestamp event.timestamp event.data.length bytes for var i 0 i event.data.length i++ str 0x event.data i tostring 16 console.log str function startloggingmidiinput midiaccess indexofport midiaccess.inputs.entries indexofport onmidimessage onmidimessage 9.5 sending midi messages to an output device this example sends a middle c note on message immediately on midi channel 1 midi channels are 0-indexed but generally referred to as channels 1-16 and queues a corresponding note off message for 1 second later. function sendmiddlec midiaccess indexofport var noteonmessage 0x90 60 0x7f note on middle c full velocity var output midiaccess.outputs.entries indexofport output.send noteonmessage omitting the timestamp means send immediately. output.send 0x80 60 0x40 window.performance.now 1000.0 inlined array creation- note off middle c release velocity 64 timestamp now 1000ms. 9.6 a simple loopback this example loops all input messages on the first input port to the first output port including system exclusive messages. var midi null global midiaccess object var output null function echomidimessage event if output output.send event.data event.timestamp function onmidisuccess midiaccess console.log midi ready try var input midiaccess.inputs.entries indexofport input.onmidimessage echomidimessage output midiaccess.outputs.entries indexofport catch e console.error exception couldn t get i o ports. e function onmidifailure msg console.log failed to get midi access msg navigator.requestmidiaccess then onmidisuccess onmidifailure 9.7 a simple monophonic sine wave midi synthesizer this example listens to all input messages from all available input ports and uses note messages to drive the envelope and frequency on a monophonic sine wave oscillator creating a very simple synthesizer using the web audio api. note on and note off messages are supported but sustain pedal velocity and pitch bend are not. this sample is also hosted on webaudiodemos.appspot.com. var context null the web audio context object var midiaccess null the midiaccess object. var oscillator null the single oscillator var envelope null the envelope for the single oscillator var attack 0.05 attack speed var release 0.05 release speed var portamento 0.05 portamento glide speed var activenotes the stack of actively-pressed keys window.addeventlistener load function patch up prefixes window.audiocontext window.audiocontext window.webkitaudiocontext context new audiocontext if navigator.requestmidiaccess navigator.requestmidiaccess then onmidiinit onmidireject else alert no midi support present in your browser. you re gonna have a bad time. set up the basic oscillator chain muted to begin with. oscillator context.createoscillator oscillator.frequency.setvalueattime 110 0 envelope context.creategain oscillator.connect envelope envelope.connect context.destination envelope.gain.value 0.0 mute the sound oscillator.start 0 go ahead and start up the oscillator function onmidiinit midi midiaccess midi if midiaccess.inputs.length 0 alert no midi input devices present. you re gonna have a bad time. else hook the message handler for all midi inputs for var input in inputs input.onmidimessage midimessageeventhandler function onmidireject err alert the midi system failed to start. you re gonna have a bad time. function midimessageeventhandler event mask off the lower nibble midi channel which we don t care about switch event.data 0 0xf0 case 0x90 if event.data 2 0 if velocity 0 this is a note-on message noteon event.data 1 return if velocity 0 fall thru it s a note-off. midi s weird y all. case 0x80 noteoff event.data 1 return function frequencyfromnotenumber note return 440 math.pow 2 note-69 12 function noteon notenumber activenotes.push notenumber oscillator.frequency.cancelscheduledvalues 0 oscillator.frequency.settargetattime frequencyfromnotenumber notenumber 0 portamento envelope.gain.cancelscheduledvalues 0 envelope.gain.settargetattime 1.0 0 attack function noteoff notenumber var position activenotes.indexof notenumber if position 1 activenotes.splice position 1 if activenotes.length 0 shut off the envelope envelope.gain.cancelscheduledvalues 0 envelope.gain.settargetattime 0.0 0 release else oscillator.frequency.cancelscheduledvalues 0 oscillator.frequency.settargetattime frequencyfromnotenumber activenotes activenotes.length-1 0 portamento 10. security and privacy considerations of midi there are two primary security and privacy concerns with adding the web midi api to the web platform allowing the enumeration of the user s midi interfaces is a potential target for fingerprinting that is uniquely identifying a user by the specific midi interfaces they have connected note that in this context what can be enumerated is the midi interfaces not for example an individual sampler or synthesizer plugged into a midi interface as these would not be enumerated unless those devices are connected to the host computer with usb usb-midi devices typically have their own midi interface and would be enumerated the interfaces that could be fingerprinted are equivalent to midi ports and for each device the api will expose the name of the device manufacturer and opaque identifier of the midi interface but not any attached devices few systems will have significant numbers of midi devices attached those systems that do will typically use hardware midi interfaces not fanning out a dozen usb-midi connections through usb hubs. in this case of course enumerating the midi devices will only see the hardware midi interface s not the synthesizers samplers etc. plugged into it on the other side. given the few number of devices plugged in the amount of information exposed here is fairly symmetric with the fingerprinting concern exposed by other apis such as the gamepad api. the vast majority of systems have relatively few midi interfaces attached. separate from the fingerprinting concerns of identifying the available ports are concerns around sending and receiving midi messages. those issues are explored in more depth below. in brief the general categories of things you can do with midi ports are sending short messages all messages except sysex receiving short messages all messages except sysex sending sysex messages. sysex messages include both commonly recognized midi time code and midi sample dump standard as well as device-specific messages like patch control data for a roland jupiter-80 synthesizer that do not apply to other devices. receiving sysex messages. the impact of each of these is sending short messages sending note-on note-off controller messages would let you cause sounds to be played by attached devices including on mac and windows any default virtual synthesizers. this by itself does not cause any concerning exposure you can already make sounds without interaction through audio flash or web audio. some attached devices might be professional lighting control systems so it s possible you could control stage lighting however this is extremely rare and no known system has the ability to cause lasting damage or information leakage based solely on short messages at worst a malicious page could flash lights and the user could close the page and reset their lighting controller. receiving short messages receiving note-on note-off controller messages would not cause any information exposure or security issues as there is no identifying data being received just a stream of controller messages all of which must be initiated by the user on that midi device except clock-type messages this is very analogous to receiving keyboard or mouse events. sending and receiving sysex. this is the biggest concern because it would be possible to write code that looked for system-specific responses to sysex messages which could identify the hardware available and then use it to download data e.g. samples stored in a sampler or replace that data erasing sample data or patches in the device although both these scenarios would have to be coded for a particular device. it is also possible that some samplers might enable a system exclusive message to start recording a sample so if the sampler happened to have a dedicated microphone attached uncommon in practice but possible it would be possible to write code specific to a particular device that could record a short sample of sound and then upload it to the network without further user intervention. you could not stream audio from the device and most samplers have fairly limited memory and midi sample dump sysex is a slow way to transfer data it has to transcode into 7-bit so it s unlikely you could listen in for long periods. more explicit fingerprinting is a concern as the patch information stored samples user configuration could uniquely identify the system although again this requires much device-specific code there is not standardized grab all patches and hash it capability. this does suggest that system exclusive messages are in a security category of their own. it s also useful to examine what scenarios are enabled by midi mapped against these features receiving short messages. this is the most attractive scenario for web midi as it enables getting input from keyboards drum pads guitars wind controllers dj controllerist controllers and more and use those messages as input to control instruments and features in the web audio api as well as other control scenarios midi is the protocol of choice for the multi-billion-dollar music production industry for getting physical controllers like knobs and buttons attached to your computer both in pro prosumer audio and media applications as well as consumer applications like garageband. sending short messages it s tempting to say sending is significantly less interesting as the scenario of attached output devices like hardware synthesizers is less common in today s market. the major exception to this is that many of the midi controllers have external host control of their indicator lights and this makes them dramatically more useful. for example the very popular novation launchpad controller uses midi note on off messages sent to it to turn on off and change colors of the buttons. the same is true of nearly all dj controllers. sending and receiving sysex obviously for more advanced communication with high-end hardware devices sysex is required. unfortunately some common midi commands are also sent as system exclusive messages midi machine control for example generic start stop rew ffw commands and many devices use system exclusive to program patches send advanced controller messages download firmware etc. which are much-demanded scenarios for web midi. some devices use sysex as a direct control protocol as they can pack more data into a single message and most devices use sysex as way to save and restore patches and configuration information on less-expensive computer storage. several of the major music hardware producers have expressed strong interest in using web midi to provide web-based configuration and programming interfaces to their hardware. in short disabling sysex altogether does not only disable high-end scenarios. in short the additional fingerprinting exposure of enumerating midi devices is directly analogous to the gamepad api s additional fingerprinting exposure through gamepad enumeration typical users will only have at most a few devices connected their configuration may change and the information exposed is about the interface itself i.e. no user-configured data the additional security concern for receiving short messages is also small it s analogous to listening to keyboard mouse mobile laptop accelerometer touch input or gamepad events there is no additional information exposed and all messages other than clock signals must be initiated by the user. the additional concerns about sending short messages are analogous to any audio output you cannot overwrite user information or expose use information but you can make sounds happen change patches or in rare configurations toggle lights but non-destructively and not persistently. system exclusive on the other hand has a much less bounded potential and it seems that distinguishing requests for sysex separately in the api is a good idea in order to more carefully provide user security hooks. the suggested security model explicitly allows user agents to require the user s approval before giving access to midi devices although it is not currently required to prompt the user for this approval but it also detailed that system exclusive support must be requested as part of that request. a. references a.1 normative references dom-level-3-core arnaud le hors philippe le h garet lauren wood gavin nicol jonathan robie mike champion steven b byrne et al. document object model dom level 3 core specification. 7 april 2004. w3c recommendation. url http www.w3.org tr dom-level-3-core dom4 anne van kesteren aryeh gregor lachlan hunt ms2ger. dom4. 6 december 2012. w3c working draft. url http www.w3.org tr dom highres-time jatinder mann. high resolution time specification. 18 october 2012. w3c editor s draft. url http dvcs.w3.org hg webperf raw-file tip specs highresolutiontime overview.html html5 robin berjon steve faulkner travis leithead erika doyle navara edward o connor silvia pfeiffer. html5. 6 august 2013. w3c candidate recommendation. url http www.w3.org tr html5 midi musical instrument digital interface midi november 2001. midi manufacturers association. complete midi 1.0 detailed specification isbn 0-9728831-0-x url http www.midi.org techspecs index.php rfc2119 s. bradner. key words for use in rfcs to indicate requirement levels. march 1997. internet rfc 2119. url http www.ietf.org rfc rfc2119.txt typed-arrays david herman kenneth russell. typed array specification. 26 june 2013. khronos working draft. url https www.khronos.org registry typedarray specs latest webidl cameron mccormack. web idl. 19 april 2012. w3c candidate recommendation. url http www.w3.org tr webidl webaudio paul adenot chris wilson chris rogers. web audio api. 10 october 2013. w3c working draft. url http www.w3.org tr webaudio 