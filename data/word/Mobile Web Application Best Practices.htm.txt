mobile web application best practices mobile web application best practices w3c recommendation 14 december 2010 this version http www.w3.org tr 2010 rec-mwabp-20101214 latest version http www.w3.org tr mwabp previous version http www.w3.org tr 2010 pr-mwabp-20101021 editors adam connors google bryan sullivan at&t until 2008 please refer to the errata for this document which may include some normative corrections. see also translations. copyright 2010 w3c mit ercim keio all rights reserved. w3c liability trademark and document use rules apply. abstract the goal of this document is to aid the development of rich and dynamic mobile web applications. it collects the most relevant engineering practices promoting those that enable a better user experience and warning against those that are considered harmful. status of this document this section describes the status of this document at the time of its publication. other documents may supersede this document. a list of current w3c publications and the latest revision of this technical report can be found in the w3c technical reports index at http www.w3.org tr this is the w3c recommendation of mobile web application best practices. this document was developed by the mobile web best practices working group as part of the mobile web initiative. since publication as a proposed recommendation on 21 october 2010 the working group clarified that alternative compression formats such as exi referred to in section 3.4.1 use transfer compression may not share some of the impediments of common compression formats. a diff version is available. no substantive change has been made. the document contains statements that may be regarded as forward-looking when this document is published 14 december 2010 examples provided in the how to do it sections sometimes reference on-going works on technologies that the working group expects to become prevalent in the development community soon. these sections should be taken with a grain of salt depending on the actual evolution of these technologies. the best practices statements should remain valid in any case. an implementation report is available. comments on this specification may be sent to public-bpwg-comments@w3.org with public archive this document has been reviewed by w3c members by software developers and by other w3c groups and interested parties and is endorsed by the director as a w3c recommendation. it is a stable document and may be used as reference material or cited from another document. w3c s role in making the recommendation is to draw attention to the specification and to promote its widespread deployment. this enhances the functionality and interoperability of the web. this document was produced by a group operating under the 5 february 2004 w3c patent policy. this document is informative only. w3c maintains a public list of any patent disclosures made in connection with the deliverables of the group that page also includes instructions for disclosing a patent. an individual who has actual knowledge of a patent which the individual believes contains essential claim s must disclose the information in accordance with section 6 of the w3c patent policy. table of contents 1 introduction 1.1 purpose of the document 1.2 audience 1.3 scope 1.3.1 best practices 1.3.2 web application 1.3.3 mobile context 1.3.4 delivery context 1.4 relationship to other best practices and recommendations 1.5 terminology 2 structure of best practice statements 3 best practice statements 3.1 application data 3.1.1 use cookies sparingly 3.1.2 use appropriate client-side storage technologies for local data 3.1.3 replicate local data 3.2 security and privacy 3.2.1 do not execute unescaped or untrusted json data 3.3 user awareness and control 3.3.1 ensure the user is informed about use of personal and device information 3.3.2 enable automatic sign-in 3.4 conservative use of resources 3.4.1 use transfer compression 3.4.2 minimize application and data size 3.4.3 avoid redirects 3.4.4 optimize network requests 3.4.5 minimize external resources 3.4.6 aggregate static images into a single composite resource sprites 3.4.7 include background images inline in css style sheets 3.4.8 cache resources by fingerprinting resource references 3.4.9 cache ajax data 3.4.10 do not send cookie information unnecessarily 3.4.11 keep dom size reasonable 3.5 user experience 3.5.1 optimize for application start-up time 3.5.2 minimize perceived latency 3.5.3 design for multiple interaction methods 3.5.4 preserve focus on dynamic page updates 3.5.5 use fragment ids to drive application view 3.5.6 make telephone numbers click-to-call 3.5.7 ensure paragraph text flows 3.5.8 ensure consistency of state between devices 3.5.9 consider mobile specific technologies for initiating web applications 3.5.10 use meta viewport element to identify desired screen size 3.6 handling variations in the delivery context 3.6.1 prefer server-side detection where possible 3.6.2 use client-side detection when necessary 3.6.3 use device classification to simplify content adaptation 3.6.4 support a non-javascript variant if appropriate 3.6.5 offer users a choice of interfaces 3.7 further considerations 3.7.1 consider use of canvas element or svg for dynamic graphics 3.7.2 inform the user about automatic network access 3.7.3 provide sufficient means to control automatic network access appendices appendix 1 best practice dependent device properties appendix 2 references 2.1 mwi references 2.2 device independence 2.3 web protocols and languages 2.4 other references appendix 3 acknowledgments list of best practices the following best practices are discussed in this document and listed here for convenience. use cookies sparingly use appropriate client-side storage technologies for local data replicate local data do not execute unescaped or untrusted json data ensure the user is informed about use of personal and device information enable automatic sign-in use transfer compression minimize application and data size avoid redirects optimize network requests minimize external resources aggregate static images into a single composite resource sprites include background images inline in css style sheets cache resources by fingerprinting resource references cache ajax data do not send cookie information unnecessarily keep dom size reasonable optimize for application start-up time minimize perceived latency design for multiple interaction methods preserve focus on dynamic page updates use fragment ids to drive application view make telephone numbers click-to-call ensure paragraph text flows ensure consistency of state between devices consider mobile specific technologies for initiating web applications use meta viewport element to identify desired screen size prefer server-side detection where possible use client-side detection when necessary use device classification to simplify content adaptation support a non-javascript variant if appropriate offer users a choice of interfaces the following advisory notes from the mobile web best practices working group are also discussed in this document and listed here for convenience. consider use of canvas element or svg for dynamic graphics inform the user about automatic network access provide sufficient means to control automatic network access 1 introduction 1.1 purpose of the document this document sets out a series of recommendations designed to facilitate development and delivery of web applications on mobile devices. the recommendations are offered to creators maintainers and operators of mobile web sites. 1.2 audience readers of this document are expected to be familiar with the creation of web applications and to have a general familiarity with the technologies involved but are not expected to have a background in mobile technologies or previous experience with mobile web best practices bp1 mwbp the document is not targeted solely at developers others such as interaction and graphic designers site administrators and tool developers are encouraged to read it. 1.3 scope these recommendations expand on the recommendations of bp1. where the focus of bp1 is primarily the extension of web browsing to mobile devices this document considers the development of web applications on mobile devices. 1.3.1 best practices the approach in writing this document has been to collate and present the most relevant engineering practices prevalent in the development community today and identify those that a facilitate the exploitation of device capabilities to enable a better user experience or b are considered harmful and can have non-obvious detrimental effects on the overall quality of an application. the goal of this document is not to invent or endorse future technologies. however there are a number of cases where explicitly omitting a best practice that referred to an emerging technology on the grounds that it was too recent to have received wide adoption would have unnecessarily excluded a valuable recommendation. as such some best practices have been included on the grounds that the working group believes that they will soon become fully qualified best practices e.g. in prevalent use within the development community in building a web application it is not necessary to implement all best practices. instead each best practice should be considered as a possible measure that might be implemented towards the goal of providing as rich and dynamic an experience as possible on a mobile web browser. 1.3.2 web application for the purposes of this document the term web application refers to a web page xhtml or a variant thereof css or collection of web pages delivered over http which use server-side or client-side processing e.g. javascript to provide an application-like experience within a web browser. web applications are distinct from simple web content the focus of bp1 in that they include locally executable elements of interactivity and persistent state. while the focus of this document is the best practices that apply to applications running in a web browser in many cases these recommendations are equally applicable to other kinds of web run-time such as the w3c work on web widgets widgets and also in a number of vendor-specific initiatives. 1.3.3 mobile context in a world where the line between mobile and non-mobile is necessarily blurred and a document that restricts its focus solely to best practices that are uniquely mobile would most likely be very short. with this in mind the focus of this document is to address those aspects of web application development for which there are additional non-trivial concerns associated with the mobile context. this applies equally both to the limitations of the mobile context e.g. small screen intermittent connectivity and also the additional scope and features that should be considered when developing for the mobile context e.g. device context location presence of personal data on the device etc 1.3.4 delivery context this document builds on some of the concepts described by the ubiquitous web applications working group uwa and the device independence principles dip it also discusses device and delivery channel characteristics which the uwa has named delivery context dcodi this document does not make any explicit assumptions about features of the delivery context but most best practices assume devices with support for standard xhtml javascript and css capability. at the time of writing developers of relatively complex web applications targeting mid- to high-end devices are most likely to benefit from these best practices but as the technology evolves it is expected that the range of relevant devices will increase. additionally some best practices are relevant only if the device exposes certain capabilities for example access to device information such as location in these cases the requirements are summarized as a separate sub-heading. saying that applications should be sensitive to the delivery context implies that some level of device knowledge and content adaptation is required. for best practices specifically related to this area see 3.6 handling variations in delivery context. 1.4 relationship to other best practices and recommendations these recommendations are complementary to the recommendations of mobile web best practices 1.0 bp1 though their focus is somewhat orthogonal. whereas bp1 focused on delivering a good experience on a broad range of devices this document s focus is on making use of advanced device capabilities to deliver the best possible experience on those devices that can support it. for this reason while readers of this document are likely to benefit from reading bp1 it is not a pre-requisite. 1.5 terminology note that the term javascript is used in place of the arguably more correct term ecmascript in order to provide consistency with the companion web application technologies json and ajax which are in common use and both implicitly refer to javascript in their names. also the terms ajax and xmlhttprequest xhr are used to refer to any asynchronous browser request. 2 structure of best practice statements the heading a summary of the functional area to be addressed by these statements. what it means an explanation of the intention of the best practice statement. how to do it a discussion of the techniques and device capabilities required to implement this best practice. requires a summary of device capabilities required in order for this best practice to apply. 3 best practice statements 3.1 application data most applications have the need to store data of various forms both intrinsic content e.g. the emails of an email application the calendar events of a calendar application and supplementary personalization settings e.g. preferred theme default view etc these best practices relate to the appropriate technologies and techniques to use for managing a web application s data. 3.1.1 use cookies sparingly 3.1.1.1 what it means cookies are a common and effective means to store small amounts of state on the client. they are appropriate for simple personalization data and are commonly used to store a token representing user identity in order to enable automatic sign-in. information stored in cookies however is sent to the server for every request and so using them for excessive amounts of data can negatively impact performance particularly on a mobile network. also in the mobile context cookie support cannot be relied upon since it may be disabled either in the device configuration or by the mobile network. for this reason applications should endeavor to remain functional even if cookies are unavailable. see bp1 cookies do not rely on cookies being available for more cookie related caveats. 3.1.2 use appropriate client-side storage technologies for local data 3.1.2.1 what it means if supported by the device client-side storage apis provide a mechanism to store more extensive amounts of data than would be appropriate with cookies. at the time of writing work is still undergoing to unify these apis see the w3c webapps working group webapps and device apis working group dap for more information. additionally some examples of existing technologies that support client-side storage apis are bondi bondi html5 html5 and opera widgets opera making use of client-side storage in web applications is a powerful technique that brings web applications into parity with native applications in terms of start-up time and responsiveness. two key advantages are worth noting explicitly application data stored locally can be displayed immediately when the application is started without the need for a server roundtrip allowing start-up latency to be reduced. by making updates locally at first and replicating changes back to the server in the background when connectivity is available web applications can continue to operate responsively even when the network signal is unreliable. 3.1.2.2 how to do it each technology offers a variety of storage facilities that range from simple key value models appropriate for relatively simple unstructured data to full sql database apis appropriate for more extensive and structured content. for a good technical discussion of these facilities in the context of html5 see offline web applications offline client-side storage requires local storage api. 3.1.3 replicate local data to a server if necessary 3.1.3.1 what it means if a client-side storage api is being used the data in it is not visible to the user s other devices. whilst this is appropriate for some forms of data e.g. preferences and state relevant only to a given device it is often necessary to send this data back to a server in order to provide a consistent view across devices e.g. between mobile and desktop instances of an application and make it possible to recover data if the device is lost or damaged. see 3.5.8 ensure consistency of state between devices for further discussion on these topics. as a rule of thumb data that needs to be shared with other devices or recovered in the case of a lost or damaged device should be replicated back to the server as soon as possible. 3.1.3.2 how to do it the technologies that provide client-side storage apis provide facilities to detect the current network connectivity. for example html5 provides a property on the navigator object navigator.online to indicate whether the client is currently online and dispatches two events on the window object to indicate a change of network state online and offline however these apis should be used with caution. even if the browser is reporting an online state on an intermittent network this is no guarantee that a subsequent connection will succeed. the most effective approach is to fail gracefully in the event of a connection failure store unsaved data in a queue of uncommitted changes and set a timer to try again later. client-side storage requires local storage api. 3.2 security and privacy use trusted information and protect all personally identifiable information. mobile web applications are subject to the same security considerations and risks as desktop web applications and as such most desktop related security advice is applicable to mobile. for example see owasp owasp for a good summary of common web security best practices this document does not attempt to provide an exhaustive survey of security issues but the following best practice has been called out on the grounds that it is specifically relevant to mobile. 3.2.1 do not execute unescaped or untrusted json data 3.2.1.1 what it means a common technique is to use json to transfer data to a client and then use javascript s eval function to parse it. this is a powerful technique since on constrained devices eval can execute more quickly than the alternatives. however direct execution of a datafeed that contains unescaped user-generated data represents a significant security risk and should be avoided. inadvertently executing malicious javascript is particularly dangerous on mobile devices where personal information current location contact data etc may be exposed. 3.2.1.2 how to do it where possible instead of parsing json data by executing it with the eval function use a json parser for example a javascript implementation of a json parser json-parse if this is impractical ensure that the data contains no user-generated content e.g. the server is responsible for the content of all fields in the datafeed or that any user-generated content is correctly escaped. see rfc4627 rfc4627 for details on how to ensure a json datafeed is suitably escaped and can be safely passed into javascript s eval function. 3.3 user awareness and control allow the user to control application behaviour that might not otherwise be apparent such as access to the network and access to device data. for example pictures music and video clips contacts calendar pim data call history system data battery coverage roaming location media recording record audio video clip get new picture device context e.g. location connectivity profile setting note that where possible it is preferable to rely on the browser s native functionality to notify the user of these activities however the best practices below provide further advice on appropriate application behaviour in situations where the native functionality of the browser may not be sufficient. 3.3.1 ensure the user is informed about use of personal and device information 3.3.1.1 what it means ensure that the user is informed if the application needs to access personal or device information. the user should be informed of the types of information that will be used by the application and whether how that data will be exchanged with the server. these notices should be provided when the user first accesses the web application or on first access to user information. it should provide the user with enough information to judge whether or not they want to allow the application access to their data. 3.3.1.2 how to do it in many cases use of apis that provide access to personal or device information causes a native confirmation dialog to be presented to the user. in this case the application should not force the user to confirm again at the application level but should make clear in the ui that displayed data has been accessed from the device. if the user declines a prompt to allow application access to personal or device information the application must recover gracefully. for example if a request to a device api fails do not automatically retry if this will lead to the user being presented with repeated native confirmation dialog boxes. device data requires device data apis. 3.3.2 enable automatic sign-in 3.3.2.1 what it means if an application requires user identity it is usual to prompt for user credentials username and password and provide the option to sign-in automatically on next usage session. this is especially important on a mobile device where data input is more difficult than on a desktop. note that if automatic sign-in is enabled a sign-out link should also be provided. 3.3.2.2 how to do it user credentials can be stored in a cookie or in local storage. however it is important not to store unencrypted password information since this is insecure. typically a securely hashed token which if necessary can be revoked on the server is stored locally in order to enable automatic sign-in. 3.4 conservative use of resources the most effective way to ensure that applications run smoothly and with low latency is to minimize use of device memory processor power and network bandwidth which are more limited on mobile devices than on the desktop. 3.4.1 use transfer compression 3.4.1.1 what it means compress content for efficient delivery. 3.4.1.2 how to do it http 1.1 compression which uses the gzip and deflate algorithms is widely supported. web servers should be configured to serve appropriately compressed responses. note however that the cost in time and battery usage of decompressing data should be balanced against the gains in transport efficiency. when configuring http 1.1 compression note that most image formats especially jpegs do not benefit from compression but svg does most other media formats e.g. audio video do not benefit from compression very small files e.g. 1k generally do not benefit from compression. where supported alternative compression formats such as exi exi that do not share some of the above impediments may provide benefit. 3.4.2 minimize application and data size 3.4.2.1 what it means this section elaborates on the best practices of bp1 minimize smaller applications will download and execute more quickly and more reliably than larger ones on constrained devices. 3.4.2.2 how to do it process html javascript and css files to remove whitespace and minify before delivery. minification optimization may take a number of forms from simple removal of white space and comments to the global substitution of tokens variables method names selector names with shorter alternatives. in general minification based upon a lexical grammatical understanding of that source is less fragile and is preferred to simple regular-expression based tools. see the javascript compressorrater jscomp for a comparison of javascript minification tools. 3.4.3 avoid redirects 3.4.3.1 what it means the redirection of requests using http 3xx status or html meta refresh is typically used to exchange information between servers e.g. account authentication the delay incurred by redirects is much higher over mobile networks and so the number of redirects should be kept to a minimum. 3.4.3.2 how to do it try not to use redirects. if more than two redirects are required consider using an interstitial page to communicate to the user that the application is still working. 3.4.4 optimize network requests 3.4.4.1 what it means establishing the necessary connections in order to complete an http request can take significantly longer on a mobile network than on a fixed network. even though bandwidth is typically more restricted on a mobile network it is still preferable to make fewer larger requests. 3.4.4.2 how to do it consider the following possibilities when designing an application batching requests since a single request for more data is likely to provide a better user experience than several smaller requests wherever possible batch up multiple requests at the application level. throttle low-priority requests in some applications certain requests may be less critical than others e.g. logging requests throttle low-priority requests to ensure they don t block the network and prevent more critical requests from being serviced quickly. back off during periods of inactivity if the application polls for updates it should monitor user activity and poll less frequently during inactive periods. device context if supported by the device use awareness of current connectivity e.g. wifi to select an appropriate level of interaction. 3.4.5 minimize external resources 3.4.5.1 what it means a web application typically requires a number of resources style sheets scripts image etc each of which requires an http request. as above http requests are particularly expensive on a mobile network and so fewer larger requests should be favored over a larger number of smaller requests. 3.4.5.2 how to do it as far as makes sense after taking into account 3.5.2 minimize perceived latency combine all style sheets into a single resource and all scripts into a single resource. if multiple scripts and style sheets are required as part of the authoring process then try to arrange that they are merged before the page is served. 3.4.6 aggregate static images into a single composite resource sprites 3.4.6.1 what it means web applications often depend on a number of static images to provide icons buttons etc. if served as a separate image each one incurs an additional http request which is detrimental to performance. 3.4.6.2 how to do it define candidate images as css background images and combine them into a single image for transfer spriting to optimize efficiency combine images of similar sizes and color palettes. also combine images that do not change often since if one of the component images changes the entire combination image will need to be refreshed. to render individual components of a resource use css positioning and clipping. note that this technique should only be applied to decorative images e.g. those that don t require an alt text spriting informational images leads to an undesirable coupling of content and layout and is detrimental to accessibility. css requires css2 clipping and positioning support 3.4.7 include background images inline in css style sheets 3.4.7.1 what it means visual effects e.g. background images and gradients are often used to improve the look and feel of an application. these can be included in css as base64 encoded strings in order to avoid an additional http request note that base64 encoding adds around 10 to the image size after gzip compression and this additional cost should be weighed against the benefits of fewer requests. 3.4.7.2 how to do it background images can be encoded using the data uri scheme url data image png base64 data css requires rfc2397 rfc2397 data uri support. 3.4.8 cache resources by fingerprinting resource references 3.4.8.1. what it means dynamic resources that change occasionally e.g. a user s avatar can still be cached by identifying them with a uri that includes a hash of the resource content. using this technique means that the browser does not need to check the resource headers in order to validate its cache instead any change in the resource will lead naturally to a corresponding change in the resource reference. for example img src http www.example.com userimages joeblogs-67f90da089da where the actual resource at joeblogs- xxx could be either generated in some offline process or served dynamically. 3.4.8.2 how to do it set the resource caching policy to never expire by setting the expires header to a date in the far future. reference the resource using a uri that contains a hash of the content. if the content changes this reference will change and the browser will fetch the updated data. 3.4.9 cache ajax data 3.4.9.1 what it means if possible data designed to be accessed by ajax requests from the client should be cached in the same way as primary content. 3.4.9.2 how to do it the standard caching techniques expires header and cache-control header as well as resource fingerprinting see 3.4.8 can be used on ajax data as readily as primary content pages. 3.4.10 do not send cookie information unnecessarily 3.4.10.1 what it means static resources do not need cookie information and so performance can be improved by serving them from a path or sub-domain for which the application s cookies are out of scope. 3.4.10.2 how to do it use a different domain sub-domain or path name for static resources to the main application and restrict the valid path of cookies such that they will not be exchanged when they are not needed. for example set-cookie somepreferenceinformation purple path myapp application data served from myapp will receive cookie information. static data served from static will not receive unneeded cookie information. 3.4.11 keep dom size reasonable 3.4.11.1 what it means the in-memory size of the document object model dom may be limited on mobile devices. large complex pages may exceed this limit and cause unpredictable errors. 3.4.11.2 how to do it limit the amount of information in the dom at a single time using pagination or other appropriate techniques. 3.5 user experience given the additional complexities of interacting with an application on a mobile device special consideration should be given to the overall user experience. user experience is influenced by a number of factors including latency interaction method and data consistency. 3.5.1 optimize for application start-up time 3.5.1.1 what it means user experience is strongly influenced by the initial start-up time of an application. offline web application technologies like html5 appcache html5-offline bring web applications into parity with native applications in terms of their start-up time and their ability to be used even where network coverage is intermittent. the following steps should be considered to minimize the start time of a web application. 3.5.1.2 how to do it consider the following techniques to help minimize application start time use offline technology offline web technologies for example appcache allow the resources of a web application its html javascript and css files to be specified and stored locally so that the application can start without requiring a round-trip to the server. consider partitioning large scripts in complex web applications javascript parsing can contribute a significant portion of start time. if some functionality is rarely used it should be moved into separate scripts that can be loaded on demand lowering the amount of core code that needs to be parsed at start-up. use local storage where appropriate store a snapshot of the last application state so it can be displayed immediately on start-up without requiring a server roundtrip. minimize number of local storage queries the number of local storage queries required to generate the initial view is a significant contribution to start-up latency. try to minimize the number of local storage queries required before the first view can be displayed. 3.5.2 minimize perceived latency 3.5.2.1 what it means lowering perceived latency is an important factor in improving the overall usability of a web application. 3.5.2.2 how to do it a number of techniques can be used to lower perceived latency enable incremental rendering place javascript at the bottom of the page since browsers rendering halts while parsing javascript and configure the page so that any useful information that might be available is viewable while the main content of the application is still loading. keep the user informed of activity use spinners progress bars to keep the user informed during network and device api accesses so that they do not think the application is halted. avoid page reloads to reflect changes in state or show different views within an application update pages dynamically by manipulating the dom rather than reloading them. preload probable next views preload data for frequently traversed paths in the application so it can be displayed more quickly when the user requests it. 3.5.3 design for multiple interaction methods 3.5.3.1 what it means interaction methods vary across devices. three main interaction methods should be considered when designing the ui focus based the browser focus jumps from element to element pointer based key-based navigation controls a pointer that can cover any part of the screen touch based events are related directly to a finger or stylus touch position on the screen. the optimum configuration of ui elements varies depending on the interaction method used by the device. ideally the ui should be adapted based on a knowledge of the interaction methods supported by the target device. if this is not possible then the ui should be designed to provide a good experience for each of these different interaction methods. additionally note that as always new interaction methods are likely to emerge in the future particularly in the fields of voice and assistive technology. for additional non-mobile specific guidelines on accessibility and designing for assistive technologies see web content accessibility guidelines wcag 2.0 wcag20 3.5.3.2 how to do it particularly where navigation of content requires multiple links i.e. back forward in a carousel the following factors should be considered focus based the current focus of the page is easily determined because the focus element will be highlighted focus area will jump automatically from one selectable element to another e.g. from link to link without affecting usability even when widely spaced. pointer based selectable elements that are associated with each other need to be close as moving the pointer can be slow selectable elements need to be large enough to be easily selected since the pointer often moves in steps of between 5 10 pixels selectable elements should have rollovers to make it clear when the pointer has entered their active area. touch based selectable elements may be but don t have to be widely spaced since the user can select them directly selectable elements must be large enough to be easily selected e.g. list items should have a screen height of at least around 1cm no elements are in focus until they are selected so extra information cannot be passed to the user e.g. rollovers will not work 3.5.4 preserve focus on dynamic page updates 3.5.4.1 what it means the javascript focus method can be used to move the focus to the part of a page that has changed. however if unexpected this can confuse or irritate the user especially if returning to the previous focus is not easy. 3.5.4.2 how to do it use the javascript focus method only if it is essential to the use of the application and does not inhibit user control interaction. 3.5.5 use fragment ids to drive application view 3.5.5.1 what it means web applications can switch views without a full page reload by showing and hiding sections of content. however this means that the browser back button doesn t work by default and it is not possible to link directly to specific views within an application. usability is enhanced by enabling both of these features enabling deep links e.g. to the content of a specific email means the user can bookmark this view and return to it quickly enabling the browser history provides a natural method to navigate application views that is natively supported by the browser. 3.5.5.2 how to do it assign a uri with a distinguishing fragment identifier e.g. http myapp.example.org myapp#view use javascript to interrogate the browser location in order to determine which view to display. for further discussion on this topic see unique urls pattern ajax-unique on the ajax design patterns web site. note that showing and hiding content in this way can have adverse affects on accessibility if not carefully handled. see wai-aria aria for more information on writing accessible rich web applications. 3.5.6 make telephone numbers click-to-call 3.5.6.1 what it means standardized uri schemes have been defined for some common device functions e.g. making phone calls sending an sms and managing address books. these uri schemes if supported can enable users to easily use these functions from web applications. 3.5.6.2 how to do it the most broadly supported scheme is tel as described in rfc3966 rfc3966 code such as the following can be used to enable click-to-call a href tel phone-number phone-number a note that phone-number should always be entered using the full international prefix e.g. 1-201-555-0111 to ensure that it works outside of its home country. similarly rfc5724 rfc5724 can be used to send a gsm sms text message as follows a href sms phone-number body message phone-number a note that at the time of writing support for this rfc is limited and device compatibility should be verified before deployment. 3.5.7 ensure paragraph text flows 3.5.7.1 what it means on small screens it is important that paragraph text flows both so that it doesn t require horizontal scrolling and so that it will re-flow if the view orientation is changed. see bp1 measures for more details. 3.5.7.2 how to do it do not use absolute or pixel measures. use percentage and relative measures for containers so that text can re-flow automatically. 3.5.8 ensure consistency of state between devices 3.5.8.1 what it means this recommendation builds on the recommendation in bp1 5.5.1 thematic consistency and expands it to consider the application preferences personalization data and state that form part of the overall experience on a mobile web application. user credentials valid on one device should be valid on other devices. user preferences captured on one device should be accessible on other devices. data updated on one device should be viewable consistently on other devices. an important example of this is offering a consistent experience where data entered on a desktop is available on a mobile and vice versa. 3.5.8.2 how to do it for any application data that is not exclusively relevant to the current device favor storing it on the server so it can be shared by other devices. see 3.1 application data for more details. 3.5.9 consider mobile specific technologies for initiating web applications 3.5.9.1 what it means network-initiated content delivery push methods allow notifications and updates to be sent to the user even when they are outside of the application context. 3.5.9.2 how to do it push method support may be disclosed through a user agent profile uaprof document if published by the device vendor or through a device classification repository. if supported by the user agent options for push methods include oma push a widely supported enabler providing methods for user-confirmed and automatic content push directed to mobile browsers and other user-agents. see oma push specifications oma-push for more details sms qr codes alternative vendor-specific initiatives. 3.5.10 use meta viewport element to identify desired screen size 3.5.10.1 what it means certain classes of browser attempt to display desktop pages on a small screen by automatically zooming the display. this can be problematic for applications that have already been optimized for a small screen. the viewport meta tag tells the device at what scale to render the page. 3.5.10.2 how to do it a typical viewport setting looks like this meta name viewport content width device-width initial-scale 1.0 and is inserted into the head element of the html document. this setting informs the browser to always render the page at 100 e.g. no browser based scaling and is appropriate for pages specifically designed for the target screen-size. 3.6 handling variation in the delivery context variations in the delivery context such as different device capabilities is a prominent feature of the mobile web. web applications should adapt to known or discoverable properties of the delivery context by adjusting the content navigation or page flow with a view to offering a good user experience on as broad a range of devices as possible. 3.6.1 prefer server-side detection where possible 3.6.1.1 what it means where possible use the evidence available on the server to determine the properties of the delivery context and adapt the responses to the client before transfer thus improving the user experience and avoiding transfer of unnecessary or incompatible data. 3.6.1.2 how to do it in its most basic form the minimum evidence from the requesting device is the http request header fields. typically the following header fields provide evidence of device capabilities accept this list of mime types can aid in the selection or creation of alternative content representations to suit the requesting device. this field is not always reliable however and its value often includes suggesting that clients can accept every mime type. user-agent as a generally unique albeit opaque string it can be used as a key into a device description repository ddr the set of properties recorded in these repositories varies from implementation to implementation. the w3c ddr simple api defines a common interface and a means of expressing the vocabulary of properties for such repositories. x-wap-profile this is a reference to the user agent profile uaprof for the requesting device. in practice the referenced profile is not always guaranteed to be available valid or up-to-date so the value of this field is sometimes used with a ddr where corrections to the profiles are stored. some devices may send an additional field x-wap-profile-diff advertising temporary or permanent variations of a specific device with respect to its standard profile. 3.6.2 use client-side capability detection where necessary 3.6.2.1 what it means where it is not possible to determine certain properties of the delivery context from the server this information may be available at the client. once obtained at the client the information can be used directly to adapt the presentation or it can used to request alternative adapted content from the server. 3.6.2.2 how to do it there are a few client-side solutions available to the developer javascript this is the most common solution. a script determines the device browser properties and manipulates the content and behaviour of the application accordingly. this can be done in two ways by encapsulating the differing behaviors in the control logic of the application e.g. if some_api_exists typically the delivery context information is gathered at the start of the session though dynamic information e.g. current screen orientation should be refreshed during the session. by passing the gathered information back to the server and requesting alternative content e.g. either by dynamically adding a new script element to the dom or by an xhr request css media types css media types allow different stylesheets to be associated with different media types e.g. print screen mobile and are traditionally used to repurpose content for these destinations. since the list of recognized media types is limited however and devices are notoriously idiosyncratic in their interpretation of types it is in general not a helpful technology in this context. see media types cssmt for more details. css media queries media queries are an extension to the media-types paradigm that allow developers to apply specific style rules based on the device display characteristics e.g. screen width orientation or resolution at the time of writing this specification is not fully supported but can provide a useful way to modify the page layout for example to re-flow sections of text in a more maintainable declarative way than is possible with script. see media queries cssmq for more details. 3.6.3 use device classification to simplify content adaptation 3.6.3.1 what it means if a large number of devices are being targeted or if the application is sensitive to the permutations of a large number of configuration properties the number of application variants required might quickly become unmanageable. to combat this classify target devices and build a single application variant for each class. this allows you to exploit device capabilities with a manageable code base. 3.6.3.2 how to do it identify the target devices for the application and assign these to device classes of varying capability. focus on application variants that work in each class rather than building device-specific exceptions for every variation in device configuration. device classes should be defined on an application by application basis so that the variants can be tailored accordingly. example 1 possible definition of application classes based on rendering and device api capabilities class 1 basic xhtml support no or very basic scripting. no xhr support. even if these kind of devices are not being explicitly supported it is often advisable to support a non-xhr version in case javascript has been disabled on the device class 2 full ajax and javascript support. class 3 advanced device apis for example access to location api device pim data or application cache. example 2 possible definition of application classes based on supported user-interaction modes class 1 pointer based. class 2 touch based. 3.6.4 support a non-javascript variant if appropriate 3.6.4.1 what it means scripted and xhr based applications are not supported on all browsers. if broadest reach is a primary concern then consider providing a variant of the application that uses synchronous form posts in place of xhr requests. this best practice is related albeit with a differing focus to bp 1 objects_or_script 3.6.4.2 how to do it essentially this bp states that it is favorable to support class 1 devices as defined in the first example above if appropriate. doing this will ensure that the application can be used across as broad a range of devices as possible. furthermore in some cases a non-javascript version can be useful for simple operations in low-bandwidth situations. in some cases however a particular application simply has no non-javascript counterpart e.g. a web based game an instant messaging client in which case the server should return a response with human readable content explaining the situation in more detail. ideally content should be adapted before transfer by checking whether or not the device supports javascript using a ddr or local index. however in some cases e.g. if the device has disabled javascript javascript may still be sent to a device that can t process it. to cover this case a noscript element should always be included and contain a suitably informative message. 3.6.5 offer users a choice of interfaces 3.6.5.1 what it means not only is device characteristic detection imperfect it cannot always account for the differing use cases of an application. therefore automatic detection is not sufficient as the only mechanism for determining which version is appropriate. 3.6.5.2 how to do it where multiple versions of an application exist e.g. to support the various device classifications always offer the user the opportunity to change the selection. always attempt to default to the most appropriate ui on first use. always remember the user s preference for future visits in a cookie or local data store. 3.7 further considerations the mobile web best practices working group would like to draw the attention of web application developers on the following considerations. these considerations should not be viewed as best practices because they are not prevalent in the development community at the time of writing. they are published as advisory notes. 3.7.1 consider use of canvas element or svg for dynamic graphics 3.7.1.1 what it means canvas and svg provide alternative options for incorporating graphics in a web application. support for these technologies varies across devices so in many cases the choice of which technology to use will depend on the target devices for a given application. the canvas element specifies a display region where javascript can be used to draw simple graphics. in contrast svg is an xml language for defining vector graphic elements that are added to a dom which can be modified using javascript. svg is well-suited for graphics that must be scalable and whose components need to be modified e.g. panning and zooming a map whereas canvas is better suited where a static bitmap is sufficient e.g. drawing a scatter-chart or creating visual effects if speed is important canvas may be more effective. however since canvas generates a flat bitmap it is not inherently accessible and so should not be used as the sole means of conveying information. 3.7.1.2 how to do it see the canvas element in the html5 specification html5 section 4.8.10 for information on how to use the canvas element. see w3c scalable vector graphics svg home page svg for information on how to use svg. 3.7.2 inform the user about automatic network access 3.7.2.1 what it means network traffic on a mobile device depletes the battery and may incur expense so it is important to inform the user when accessing the network. whenever an application makes asynchronous xhr data requests whether in response to a user action or automatically this should be indicated in an appropriate manner so that the user remains informed and in control. 3.7.2.2 how to do it applications should disclose how they use network resources. a simple icon indicating background activity is usually sufficient and does not interrupt the flow of the application. if extensive background network activity is required the user should be informed when they first visit the site when they first sign-in or in associated help pages. the kinds of detailed information that could be disclosed in associated help pages or terms of service are how often the application will interact with the internet e.g. every 5 minutes hourly daily for how long the automatic behavior will continue how heavy the overall usage is expected to be or the type of service plan recommended. 3.7.3 provide sufficient means to control automatic network access 3.7.3.1 what it means if an application makes automatic network requests e.g. to poll the server for updates or to automatically store an updated client state a means to control this activity should be provided. 3.7.3.2 how to do it all applications that access the network automatically should provide a means for the user to disable that activity. when automatic network activity is disabled periodically prompt the user to make network requests. consider allowing the user to adjust the polling schedule and to control which activities are allowed to initiate network requests. appendix 1 best practice dependent device properties the following device properties included in the ddr core vocabulary ddr-vocab are of particular value in supporting best practices recommended in this document. they should be available in any ddr supporting the w3c s ddr core vocabulary display width display height display color depth input devices markup support stylesheet support image format support input mode support cookie support script support appendix 2 references 2.1 mwi references mwbp mobile web best practices 1.0 jo rabin editor w3c recommendation 29 july 2008 see http www.w3.org tr mobile-bp 2.2 device independence dcodi delivery context overview for device independence r. gimson r. lewis s. sathish editors w3c working group note 20 march 2006 see http www.w3.org tr di-dco digloss glossary of terms for device independence r. lewis editor w3c working draft work in progress 18 january 2005 see http www.w3.org tr 2005 wd-di-gloss-20050118 dip device independence principles r. gimson editor w3c working group note 1 september 2003 see http www.w3.org tr 2003 note-di-princ-20030901 2.3 web protocols and languages css cascading style sheets css1 level 1 specification h kon wium lie bert bos editors w3c recommendation 11 january 1999 revised 11 april 2008 see http www.w3.org tr 2008 rec-css1-20080411 css2 cascading style sheets level 2 css2 specification bert bos h kon wium lie chris lilley ian jacobs editors w3c recommendation 12 may 1998 revised 11 april 2008 see http www.w3.org tr 2008 rec-css2-20080411 http1.0 hypertext transfer protocol http 1.0 request for comments 1945 t. berners-lee r. fielding h. frystyk may 1996 see http www.w3.org protocols rfc1945 rfc1945 http1.1 hypertext transfer protocol http 1.1 request for comments 2616 r. fielding j. gettys j. mogul h. frystyk l. masinter p. leach t. berners-lee june 1999 see http www.w3.org protocols rfc2616 rfc2616.html xml extensible markup language xml 1.0 fifth edition tim bray jean paoli c. m. sperberg-mcqueen eve maler fran ois yergeau editors w3c recommendation 26 november 2008 see http www.w3.org tr 2008 rec-xml-20081126 2.4 other references ajax-unique unique urls pattern on ajax design patterns web site see http ajaxpatterns.org unique_urls aria accessible rich internet applications wai-aria 1.0 james craig et al w3c working draft 16 september 2010 see http www.w3.org tr wai-aria bondi omtp reference implementation see http bondi.omtp.org cssmq media queries h kon wium lie tantek elik daniel glazman anne van kesteren w3c candidate recommendation 27 july 2010 see http www.w3.org tr css3-mediaqueries cssmt cascading style sheets level 2 revision 1 css 2.1 specification bert bos et al w3c candidate recommendation 08 september 2009 see http www.w3.org tr css21 media.html dap w3c device apis working group see http www.w3.org 2009 dap ddr device description repository simple api jo rabin et al w3c recommendation 05 december 2008 see http www.w3.org tr ddr-simple-api ddr-vocab device description repository core vocabulary jo rabin et al w3c working group note 14 april 2008 see http www.w3.org tr ddr-core-vocabulary exi efficient xml interchange w3c candidate recommendation john schneider and takuki kamiya 08 december 2009 see http www.w3.org tr exi html5 html5 ian hickson and david hyatt w3c working draft 19 october 2010 see http www.w3.org tr html5 html5-offline html5 ian hickson and david hyatt w3c working draft 19 october 2010 see http www.w3.org tr html5 offline.html#offline jscomp the javascript compressorrater see http compressorrater.thruhere.net json-parse implementation of a secure json parser in javascript see https github.com douglascrockford json-js raw master json_parse.js offline offline web applications anne van kesteren and ian hickson w3c working group note 30 may 2008 see http www.w3.org tr offline-webapps oma-push oma push see http www.openmobilealliance.org technical wapindex.aspx opera opera web widget api see http dev.opera.com libraries widgetobject owasp open web application security project see http www.owasp.org index.php main_page rfc2397 the data url scheme l.masinter. ietf august 1998 see http www.ietf.org rfc rfc2397.txt rfc3966 the tel uri for telephone numbers h. schulzrinne. ietf december 2004 see http www.ietf.org rfc rfc3966.txt rfc4627 the application json media type for javascript object notation json d. crockford july 2006 see http www.ietf.org rfc rfc4627 rfc5724 uri scheme for global system for mobile communications gsm short message service sms e. wilde and a. vaha-sipila. ietf january 2010 see http www.ietf.org rfc rfc5724.txt svg w3c scalable vector graphics svg home page see http www.w3.org graphics svg uaprof open mobile alliance oma-ts-uaprof-v2_0-20060206-a user agent profile approved version 2.0 06 feb 2006 see http www.openmobilealliance.org technical release_program docs uaprof v2_0-20060206-a oma-ts-uaprof-v2_0-20060206-a.pdf wcag20 web content accessibility guidelines 2.0 b. caldwell m. cooper l. guarino reid g. vanderheiden et al w3c recommendation 11 december 2008 see http www.w3.org tr wcag20 webapps w3c webapps working group see http www.w3.org 2008 webapps widgets widget packaging and configuration marcos c ceres w3c working draft 5 october 2010 see http www.w3.org tr widgets wtai wap forum wap-268-wtai-20010908-a wireless telephony application interface specification see http www.openmobilealliance.org tech affiliates licenseagreement.asp docname wap wap-268-wtai-20010908-a.pdf xhtml-basic xhtml basic 1.1 second edition shane mccarron masayasu ishikawa editors w3c recommendation 23 november 2010 see http www.w3.org tr 2010 rec-xhtml-basic-20101123 appendix 3 acknowledgments the editors would like to thank members of the bpwg for contributions of various kinds. the editors would also like to thank contributors to the public list and contributors of last call comments whose comments have been taken into account in the creation of this document. the editors acknowledge significant written contributions from daniel appelquist vodafone jo rabin mtld mobile top level domain dotmobi phil archer w3c jeff sonstein rochester institute of technology fran ois daoust w3c scott hughes vodafone 