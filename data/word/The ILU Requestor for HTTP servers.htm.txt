the ilu requestor for http servers wd-ilu-requestor-960307 the ilu requester object services in http servers w3c informational draft 07-mar-96 this version http www.w3.org pub www tr wd-ilu-requestor-960307 latest version http www.w3.org pub www tr wd-ilu-requestor authors paul everitt digital creations paul@digicool.com status of this document this document provides information for the w3c members and other interested community. this document does not specify a w3c standard of any kind. feedback should be directed to the author. a list of current w3c documents can be found at http www.w3.org pub www tr abstract the common gateway interface cgi is not scaling to meet the requirements of today s dynamic interactive webs. for this reason multiple vendors have proposed c callable apis. these apis allow authors to alleviate the performance penalty of cgi and allow tighter integration of add-in modules. unfortunately this comes at the price of complexity and portability. this document describes a new model for extending www servers. first http is captured using an interface specification which eliminates the ambiguities of interpretating a standards-track document. this interface is then implemented atop a particular httpd s api. finally all of this is done using a standard distributed object model called ilu. digital creations work on our ilu requester reflects this design and shows its advantages. this paper describes the ilu requester. table of contents introduction requirements for a requester architecture detailed description current status of implementation examples of interfaces performance analysis outstanding issues future plans alternatives references appendices author s info introduction applications deployed over the world-wide web often involve an http server integrated with a legacy information system or a custom information system. the common gateway interface or cgi is the most widely deployed mechanism for integrating http servers with other information systems but studies have shown that its design does not scale to the performance demands of contemporary applications. microsoft states that applications for their api are five times faster than cgi applications. moreover cgi applications do not run in the httpd process. in addition to the performance penalty this means that cgi applications cannot modifiy the behavior of the httpd s internal operations such as logging and authorization. finally cgi is viewed as a security issue by some server operators due to its connection to a user-level shell. a current solution is to use an httpd with an api such as apache 1.x or netscape. by using the api you have a performance increase and a load decrease by running your application in the httpd process rather than starting a new process for every request. also the api exposes some of the httpd s own behavior allowing you to modify its operation. in fact servers like apache implement large portions of their functionality such as ismap handling and logging as modules. unfortunately the api benefits come at a price. running a user-written module inside the httpd process leads to possible reliability concerns. for instance when developing our requesters early code would regularly lead to core dumps from unhandled errors as well as memory leaks. also most current servers use either multiple pre-forked subprocesses or separate threads for each new request. thus applications which change state such as a simple counter script have data concurrency issues that are the burden of the programmer to solve. most importantly the api route eliminates the casual cgi programmer. in a recent survey perl beat c 4 to 1 with 46 of the total votes. it appears that the possibilities for language-choice in a c-based api mechanism are restrictive. finally the portability of cgi applications from one httpd implementation to another would be lost with an api strategy. since each api has a different syntax authors would be forced to know each api beforehand. thus apis could become instruments used by vendors to ensure market retention. the elimination of scripting by an api strategy is a serious issue. web services are usually built using scripting languages such as perl python tcl visual basic rexx etc. this seems to be the case because web apps are frequently quick and dirty complex in their data relationships short-lived written by casual programmers in essence the genre of cgi applications are usually complex enough to use tools good for rapid prototyping but which rarely get past the prototype stage and into c. to address this next generation of server-extending we developed a mechanism based on a uniform interface specification for http. this is the http.isl. by basing our extension mechanism on a distributed object protocol like ilu we get the performance and features of an api strategy as shown below with the portability and simplicity of cgi. moreover it permits the httpd to be extended not only out of its address space but off its machine and thus into capabilities available only on a remote node. this is in the true client-server fashion. we call this extension mechanism the ilu requester. ilu requester in a nutshell performance of api features of api portability of cgi simplicity of cgi bridge into distributed objects requirements for a requester strategy we have listed the problems with the current cgi api situation. and we have described an ilu requester architecture. what are its requirements and what are some preferred possibilities requirements portable across platforms and vendors based on well-understood industry standards infrastructure uses freely-available high-quality code base active and sustainable development wide choice of language i.e. not language-based significant performance win scaleable to n clients and n servers non-blocking on threaded servers preferences configurable servers e.g. adding methods to http and implementing them yourself to erase bugs designed for an eventual absorption into the server s code base as a common encapsulation designed also for an eventually-encapsulated browser which has an object runtime available for messaging some standard interfaces such as a site catalogue authorizer logger gatherer broker detailed description we have implemented the ilu requester for several platforms and have extended development to include other interested parties. first we will give some background and then a description. background in december of 1994 we were tasked with developing a complex www service. this service necessitated a dynamic language and had state. yet we were forced to use cgi. thus we made a first implementation using a long-running process that managed the state using a dynamic language python and a small controller script that would message it on each hit. over time we found that we were inventing our own client server protocol. for this and other reasons we started looking at using ilu to manage interactions between processes. thus the cgi script got a surrogate reference to an encapsulation of the stateful system. still we had the performance penalty of cgi. in april of 1995 we wrote a patch for apache 0.6.5 that embedded the ilu runtime. with this we had access to objects via registered url constructs. this served several production systems into the fall. at this point we started to refer to this embedded ilu module as the requester. in august a version of apache was released that had an api so we started reworking the requester to use it. by october we had a related requester for netsite working on unix and partially on nt. in december based on a new draft of the http spec we consolidated the two feature sets and wrote an http isl that was comprehensive with respect to the new specification. also we started work with ilu 2.0. in january of this year we started standardizing on a python framework module for creating our online services. for this we developed an isl for installing object-based authorizers and loggers into the httpd. case study broadcast also in january we released our first major product based on this architecture called broadcast. this is a web-based chat application that had one primary goal it should be very fast under very highly-loaded conditions. some design choices were perl-based cgi the product that ours was replacing started in life as a perl-based chat. it became very popular or at least popular enough that many simultaneous users would load the system up too much. this suffered from the startup cost of an interpreter the cost of reading the state in from disk and from design issues for multiple processes changing the state. c-based cgi same as the above but moved to c. still faced with the problems of state and concurrency. cgi-based requester-daemon service one choice for solving the problem of state would be to have a long-running server process that managed the state of the chat and have skinny requesters that message the chat server from cgi over a socket. this design solves the problem of reincarnating state for each request. also it provides a dbms-like function for modifying the state since everything goes through one process. however there is still the cost of starting up a cgi requester on each hit and the socket create teardown issue. also you have invented a nice little client-server system that speaks your protocol but no other. plus this protocol has to be interpreted on the wire using your custom parser. finally the chat daemon must be equipped with concurrency or else it becomes a bottleneck. rpc service a more elegant version of the chat daemon strategy might be to use rpc to the chat server either from a cgi requester or an api-based requester. this would replace your custom protocol and would allow an api-based requester to keep connections open. on the other hand you have produced a system that is procedure-oriented rather than object-oriented. we chose to use an ilu requester that would make generic calls on published objects that represented the chat site s components. this allowed us to have very low latency by avoiding startup costs and expose the oo design of the chat implementation. it appears that the design choice was valid. performance is fantastic and load is low. also using the requester strategy we now have many new possibilites for application partitioning. finally using our api scripting infrastructure we are able to add new features in a very coherent fashion. description as alluded to above the entire system is based around ilu. from this we get language-independence cross-process communication and platform-independence. the goal is to add an abstract object interface to an httpd in a uniform way. for this we wrote an interface for http that encapsulates the behavior of the http transaction. we then implement this interface in c by mapping it to the semantics of a particular httpd s api. this implementation is called the requester and gives an httpd a mechanism for passing certain incoming requests to an ilu published object. this architecture mimics the interaction between the browser and the httpd using the same concepts as http. for instance the information contained in the request is mapped into a request type in the interface specification. the requested object is a resource and the result of the operation on the resource is a response. both of the request and response are types defined in the interface. fortunately because of the uniform abstract isl the services you write do not have to know anything about the semantics of the server or its api. in fact it would be possible to skip the httpd altogether and communicate directly with the published object. the objects could do this they can have multiple representations and can communicate via http requests ilu requests or some other request structure. when writing a service therefore all you have to do is publish an object that is based on the skeleton code generated from the interface. pretty standard stuff here. then if the published object is listed in the httpd s configuration file incoming requests matching a certain uri form will be sent to the requester which will make an ilu call to the published object. also it is possible to map the requester to remotely-published objects using ilu s string binding handle mechanism. this makes it possible to bridge the httpd into services available on other platforms. future ilu mechanisms will make this process easier. current status of implementation as of this writing we have solid requesters based on ilu 1.8 and 2.0 for netsite unix and apache. they have been tested by others reviewed for optimizations passed through simple memory leak testers and documented. we are making distributions freely available in source and some in binary form. currently the requesters are known to work fine on solaris digital unix linux aix and bsdi. additionally we have preliminary support for nt. full support is waiting for us to finish up our work on threading with ilu. finally ilu has been reported to work on os 2 and there is work on and apache implementation for that platform. the threading issue will become increasingly important as we build more sophisticated systems especially when we might want to have a common orb. however for systems such as netsite and microsoft s iis on nt as well as spyglass server it is required in the requester. this is because these platforms service each incoming request as a thread rather than passing the request to an isolated process. thread-safeing the requester is thus becoming a requirement. we have just added support for aliasing multiply-published objects inside the requester. for instance you could make a request to info@system and have system map to one of several published objects. this is mainly for a performance increase in read-only situations. note that this may be subsumed by the ilu work on multicast. another area we are working on is making the object systems easier to use. we have just added an http header that gets returned stating the ilu version and requester version. we are adding support for a discoverable interface using a standard info@root that is built in to every requester. this object will return catalogue information from config file directives and will attempt to contact the ilu servers listed in the config file and get their info@root information if implemented. api scripting making an httpd able to call distributed objects is only half of the system you must have objects that can be called. we have intended for this system to replace cgi as a server-extension mechanism. to do this it must be nearly as easy to create services as cgi is currently. for this we have been working on an infrastructure for publishing requester-capable objects called api scripting. for creating services we are focusing on python and building up a toolset to of components. we have made parts of this toolset available and have released our demonstration programs and load testing modules. based on this python toolset and the requester we are fielding high-performance internet services for commercial use. for instance here is a very simple script in python that publishes an object which echoes the contents of a request usr local bin python every good module deserves docstrings. this is a very simple script that subclasses a resource fills in the blanks and echoes incoming requests. it then publishes the object and goes into a main loop. import ilu import wwworb our toolset class ilufordummies wwworb.resource def get self request connect request wwworb.request request response wwworb.response request return response post get create an ilu server ilu.createserver paul.demos now create an instance of your class passing it a parameter for the name of the published object. nitwit ilufordummies dumb print nitwit.ilusbh ilu.runmainloop note that there are really only nine necessary lines in the above. this should put it into the realm of cgi for ease of use. our next step is to make highly-concurrent systems available in python. to do this we are working with the ilu team to thread the iluprmodule. this work is related to the work on threading the ilu kernel. for all of these we have an emerging development group and an infrastructure for documentation tutorials bug reports etc. examples of interfaces currently we have stabilized our http interface and feel that it accurately represents the interaction between a browser and a client in a way useful for published objects behind an httpd. therefore we are now focusing on problem-specific interfaces. first we would like to have a discoverable interface for online services. for instance one should be able to go to any requester-enabled site send a request to an info@root published object and get an inventory of that site. the contents of this inventory might vary might support a set of minimum operations might extend and might change. all the things that an interface allows you to do over time. this discoverable interface is being worked on. there are other interfaces that have already rolled out. the authorizer isl most of our api scripting services involve persistent python objects that receive requests from the ilu main loop. some of these services need some type of access control list acl mechanism on them. however we really don t want to interface into some external httpd-controlled single-filesystem-based password file. the api-based servers have modules already that allow you store user authentication information in a sql table. yet we already have users defined in our object system. moreover we might want to have some instance-based authorization mechanism. to extend the acl-capabilities of the httpd we wrote an authorizer interface and implemented it into the apis we support. thus accesses to protected uris are mapped to an object call which determines if that operation is allowed by that identity. the logger isl another area we wanted to standardize on was an intelligent logging mechanism. currently there is the common log file format for writing to disk. however we wanted something more structured and more dynamic. thus we wrote an interface for logging mapped it into the httpd s api functions and created an installable logging facility. a smart implementation could publish an object which is registered for successful or unsuccessful requests to document or ilu-based requests. if there is an error you could decide whether send a page to someone s beeper. for all requests you can take the incoming data structure and write parts of it into a minisql table. we wanted to extend the httpd s logging facilities in new and interesting ways. for instance we wanted to do processing and take special actions if an error was raised. also we wanted to investigate logging from a unix httpd into a windows-based personal dbms like microsoft access. to do this we made an interface for loggging and implemented it on the apis we support. this mapping forces the httpd to run our object call during logging events. the interface is very simple it just sends the request object to loggerobject via an asynchronous method. one could then subtype from there to do more interesting platform-specific things. the stanford digital library common object services the stanford digital library team has produced interfaces and implementations for corba-type common object services cos common object services are objects or groups of objects that provide the basic requirements which most objects need in order to function in a distributed environment. these services are designed to be generic they do not depend on the type of client object or type of data passed. note this is hard to do in ilu since there is no concept of the object or any type. other interfaces there are other good candidates for interfaces. for instance the harvest system has its own protocol for collecting indexing information and doing searches. if an interface was written it could perhaps be moved into this architecture. we have started on some other standard interfaces such as a data access interface and a an ole interface via python these though are not necessarily related to the ilu requester and are thus outside the scope of this paper. performance analysis it should be apparent that the architecture lends itself to good performance. however we felt that some performance numbers were important so we came up with a performance-testing program and a regimen to exercise it. to test i used a sparc 5 running solaris 2.4 with 32 mb as the testing client and an alpha with 64 mb running digital unix as the testing server. the test program was written in python and used the httplib and thread modules to make concurrent requests. the server was running netsite using our requester and ilu 2.0. we had netsite configured to use up to 32 processes. we then ran through a series or urls listed below in a series of two tests a latency test and a throughput test. the latency test sent a series of requests on one thread to test the response time. the throughput test dispatched the same number of requests on several simultaneous threads to test concurrent use. thus the throughput test attempted to detail the affects of load concurrency and aggregate response time for a batch of requests. for the uris the index.html test merely retrieved a very short html file. the others were simple.sh bin sh echo content-type text html n n echo hello. simple.pl usr local bin perl print content-type text html n n print hello. simple.py usr users paul cgipython simple script to echo the dictionary back. print content-type text html n n print hello. simple1.py usr users paul cgipython simple script to echo the dictionary back. print content-type text html n n import simple_lib simple_lib.py usr users paul cgipython simple script to echo the dictionary back. import cgi f cgi.svformcontentdict print f.items dumb.py note echo is equivalent to simple.py and dumb is equivalent to simple1.py the simplest dumbest api script around. this python program has one goal fewest lines for an interactive script. the script reads the form variables and sends them back without very much formatting. note that we have embedded the html into the class which has added some characters. normally this class would be even shorter as we would use the pyhtml external representation. but that would be smart and this one is well dumb. import sys sys.path.append wwworb sys.path.append interfaces import string ilu wwworb print ilu.version make a class derived from the resource class in wwworb. remember that the base class wwworb.resource requires a parameter to be passed to its init__ startup call. this parameter is the name of the published object. class echofordummies wwworb.resource def get self request connect return wwworb.response hello. post get class ilufordummies wwworb.resource def get self request connect request wwworb.request request response wwworb.response request return response post get create an ilu server ilu.createserver paul.demos now create an instance of your class passing it a parameter for the name of the published object. nitwit ilufordummies dumb echo echofordummies echo print nitwit.ilusbh print echo.ilusbh ilu.runmainloop these scripts were chosen to reflect both the least that could be done with a cgi script echo back a string vs. very little that could be done parse the incoming request into data structures and echo it back the bourne shell script and the perl script are thrown in as reference points. it is the comparison of python scripts that is relevant. the python interpreter used for the cgi scripts was very small. i removed nearly everything from the modules setup and did not link with threads a source of startup time problems on digital unix i used python 1.3 for all of these and ilu 2.0a3. thus the comparison is between python cgi and python api scripting the two tests are a simple echo of a string and a slightly-computational parsing of the incoming information. obviously a real-world application where files have to read or marshals loaded or databases connected-to would tilt the scales towards api scripting since the state is always in memory. in the following hps refers to hits per second sph refers to seconds per hit and sd refers to standard deviation. latency test this test used 10 runs of 1 thread 20 requests on the thread uri min max avg hps sd hps avg sph sd sph index.html 0.142 0.580 4.774 0.1394 0.2097 0.0066 cgi-bin simple.sh 0.171 0.221 4.814 0.0074 0.2077 0.0003 cgi-bin simple.pl 0.182 0.224 4.821 0.0349 0.2074 0.0015 cgi-bin simple.py 0.176 0.222 4.825 0.0133 0.2073 0.0006 cgi-bin simple1.py x 1&y 2&z 3&z 4&z 5 0.382 0.566 2.315 0.0436 0.4321 0.0083 echo@paul.demos 0.111 0.847 4.687 0.4048 0.2152 0.0235 dumb@paul.demos 0.182 0.351 4.824 0.0703 0.2073 0.0031 throughput test this test used 10 runs of 10 threads 20 requests apiece. in this case the min and max refer to the thread completion times uri min max avg hps sd hps avg sph sd sph index.html 0.060 1.402 20.853 0.4736 0.0480 0.0011 cgi-bin simple.sh 0.106 1.279 15.128 0.4986 0.0662 0.0022 cgi-bin simple.pl 0.119 1.354 13.626 0.3116 0.0734 0.0017 cgi-bin simple.py 0.143 1.926 9.155 0.1296 0.1093 0.0015 cgi-bin simple1.py x 1&y 2&z 3&z 4&z 5 0.738 4.817 2.597 0.0092 0.3850 0.0014 echo@paul.demos 0.093 1.221 20.362 0.6996 0.0492 0.0017 dumb@paul.demos 0.109 1.597 19.862 0.6895 0.0504 0.0017 understand that the hps and sph numbers on the throughput test reflect the ability of the server to service multiple requests simultaneously. thus each hit effectively is done faster. analysis looking at the latency tests you see that html and the simple cgi scripts are about the same hps. these simple scripts don t parse the environment and thus do no calculation. the simple1.py script which does parse the environment and imports a module suffers a 50 rise in latency. yet the api scripting apps stay at the same level as the html and simple cgi even though one is parsing the environment. in the throughput test the reference point the index.html file shows that a 10-thread request gets just over a five-fold bump in throughput. certainly not a ten-fold but a enough to show that it is handling simultaneous requests well. however the cgi scripts start to show less benefit. yet the api scripting applications stay at the uri percent of single-threaded hps index.html 437 simple.sh 314 simple.pl 282 simple.py 190 simple1.py x 1&y 2&z 3&z 4&z 5 112 echo@paul 434 dumb@paul 411 if we consider getting an html file both in single-threaded and ten-threaded batches to be a baseline we see the relation of these tests. again we see that getting an html file gets a four-fold bump from a ten-thread batch. a simple bash cgi script yields a three-fold improvement 317 percent over single-thread html batches. a simple cgi script that parses the environment run in ten-threaded batches achieves only half the aggregate throughput of a single-threaded html request. thus concurrent cgi is slower than single-request html. again the api scripting applications keep pace with the baseline. uri 1-thread of 1-thread html 10-thread of 1-thread html 10-thread of 10-thread html index.html 100 437 100 simple.sh 101 317 73 simple.pl 101 285 65 simple.py 101 192 44 simple1.py x 1&y 2&z 3&z 4&z 5 49 54 12 echo@paul 98 427 98 dumb@paul 101 416 95 in the rightmost column above which is a throughput measurement an api scripting application is over eight times faster than an equivalent cgi application. a conclusion is that even for simple state applications of reading in the form data cgi loses to api scripting in latency and loses significantly in concurrent use. it would appear that the performance win would increase even more for complex applications especially those that have to initialize some state or make a connection to a sql database. getting the state setup for these is more complicated and the increase in latency and load mean pileups for service. a caveat in the testing must be noted. a more representative sample of api scripting vs. html would be to use an ilu c program and an api c program. this would also allow the testing of html vs. cgi vs. straight api c apps vs. ilu requester with objects written in c. outstanding issues at this time movement to ilu 2.0 is the biggest issue. first there are some minor bugs with the current prerelease. the real issue is embracing some new capabilities poor ilu support for bulk data e.g. rpc limit missing data types soon to be alleviated in python investigation of stanford digital library s cos mentioned above distributed concurrency and threading performance of surrogate object references true object inside httpd process for more on this see future plans we have a number of directions we intend to pursue internally and a suggested direction for industry adoption. internal some of our plans are discoverable interface for debugging and cataloging better performance numbers better story on concurrency industry some requirements use of ilu integration of the ilu runtime into their product support of a basic http isl use of standard resource request and response mechanism mapping the http spec s error codes into http exceptions ensure the safety of concurrent requesters running across threads or forked daemons some optional support extensions of the base http isl to expose advanced functionality within the ilu type system support for discoverable objects connections through native ilu protocol publishing true objects inside the httpd for high-performance apps agreement on reference implementation suite for compliance testing and performance testing alternatives many ideas have floated around. press releases have discussed for instance embedding java inside of web servers as a better fit than apis. while this does get many of the benefits of this architecture it is language-based and thus does not have language-independent interfaces. some though view this as a benefit. another option is horb which is a java-based remote object operation environment. from the horb faq i wanted to have a good language for parallel and distributed computing. for those purposes however the classic java has very poor functionality. i like java because it s simple and easy. but the basic idea of java is not far from c++. c++ can also make objects threads and sockets. java has no direct support for distributed object processing as c++ does not. so i decided to make a new framework for parallel and distributed computing. also in the faq a comparison of horb to corba corba and corba2 are desinged for interoperability between different languages and different systems. you have to write interface definitions in corba idl language in addition to real code. it must be annoying for casual use. corba cannot pass instances. it limits programming. corba orb tends to huge to comply the corba standard. since horb orb for clients is only 20kbytes modem users can wait for dynamic loading. current corba systems are very expensive. horb is free of charge. as stated on a demo page horb aims to replace cgi or socket programming with smart remote object operations of horb for windows-based platforms microsoft s server-extension solution in their iis www server is an sdk. one of the sample applications for their api is an ole interface. references cgi spec ilu python dan s web api thread in www-talk archives our releases and http.isl appendices the http isl the interface for http is used to extend the www server by mapping the browser-server interaction to an object request. we used the latest http specification as mentioned in the comment. id wd-ilu-requestor-960307.html v 1.6 1996 12 09 03 45 26 jigsaw exp proposed http interface digital creations info@digicool.com reference http www.w3.org pub www protocols http1.0 draft-ietf-http-spec.html the following is a list of headers guaranteed to be included with the request regardless of the requester used. this list is probably incomplete and will grow as i become more familiar with requesters other than netsite in request.headers none in connection remote-ip the ip address of the remote client remote-name the name of the remote clinet or the ip address if the name cannot be determined interface http type field-name ilu.cstring type field-value ilu.cstring type optional-field-value optional field-value type requesturi ilu.cstring should we handle uri parsing type requesturi record scheme ilu.cstring net_loc ilu.cstring path ilu.cstring params ilu.cstring query ilu.cstring fragment ilu.cstring end type header record name field-name value optional-field-value end type httpheader header type httpheaders sequence of httpheader type entitybody sequence of byte type optionalentitybody optional entitybody type request record uri requesturi headers httpheaders body optionalentitybody end type statuscode enumeration ok 200 created 201 accepted 202 nocontent 204 movedpermanently 301 movedtemporarily 302 notmodified 304 badrequest 400 unauthorized 401 forbidden 403 notfound 404 internalerror 500 notimplemented 501 badgateway 502 serviceunavailable 503 end type response record status statuscode headers httpheaders body optionalentitybody end type connectionparameter header type connection sequence of connectionparameter type resource object methods get request request connection connection response head request request connection connection response post request request connection connection response end type optionalresource optional resource the logger isl id wd-ilu-requestor-960307.html v 1.6 1996 12 09 03 45 26 jigsaw exp i ve thought about just eliminating this isl and using http to do logging but i m sticking with this right now to allow logging to be asynchronous. comments the following list is are the name-value pairs that must be contained in the headers the separate requesters may include their own unique headers and various clients might send different headers which should be passed along here content-length the length in bytes of the returned data content-type the mime type of the returned data method the method of the request remote-ip the ip address of the remote client remote-name the name of the remote client or the ip address if the name cannot be determined status the status code of the response uri the uri of the request interface logger imports ilu http end type loggerobject object methods asynchronous logrequest params http.httpheaders end the authorizer isl id wd-ilu-requestor-960307.html v 1.6 1996 12 09 03 45 26 jigsaw exp interface authorize imports http end type nametype ilu.cstring type grouplist sequence of ilu.cstring exception authenticationfailed exception forbidden exception authorizationrequired ilu.cstring type authorizationrecord record name ilu.cstring groups grouplist end type optionalauthorizationrecord optional authorizationrecord type authenticator object methods authenticateuser name nametype password ilu.cstring authorizationrecord raises authenticationfailed end end type authorizer object methods authorizeuser authorization-record optionalauthorizationrecord raises forbidden authorizationrequired end end author info paul everitt is vice president of digital creations. his email address is paul@digicool.com. 