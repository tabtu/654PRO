cross-origin resource sharing cross-origin resource sharing w3c recommendation 16 january 2014 this version http www.w3.org tr 2014 rec-cors-20140116 latest version http www.w3.org tr cors previous versions http www.w3.org tr 2013 pr-cors-20131205 http www.w3.org tr 2013 cr-cors-20130129 http www.w3.org tr 2012 wd-cors-20120403 http www.w3.org tr 2010 wd-cors-20100727 http www.w3.org tr 2009 wd-cors-20090317 http www.w3.org tr 2008 wd-access-control-20080912 http www.w3.org tr 2008 wd-access-control-20080214 http www.w3.org tr 2007 wd-access-control-20071126 http www.w3.org tr 2007 wd-access-control-20071001 http www.w3.org tr 2007 wd-access-control-20070618 http www.w3.org tr 2007 wd-access-control-20070215 http www.w3.org tr 2006 wd-access-control-20060517 http www.w3.org tr 2005 note-access-control-20050613 editor anne van kesteren formerly of opera software asa annevk@annevk.nl please note there may be errata for this document. the english version of this specification is the only normative version. non-normative translations may also be available. copyright 2014 w3c mit ercim keio beihang all rights reserved. w3c liability trademark and document use rules apply. abstract this document defines a mechanism to enable client-side cross-origin requests. specifications that enable an api to make cross-origin requests to resources can use the algorithms defined by this specification. if such an api is used on http example.org resources a resource on http hello-world.example can opt in using the mechanism described by this specification e.g. specifying access-control-allow-origin http example.org as response header which would allow that resource to be fetched cross-origin from http example.org. status of this document this section describes the status of this document at the time of its publication. other documents may supersede this document. a list of current w3c publications and the latest revision of this technical report can be found in the w3c technical reports index at http www.w3.org tr this document has been reviewed by w3c members by software developers and by other w3c groups and interested parties and is endorsed by the director as a w3c recommendation. it is a stable document and may be used as reference material or cited from another document. w3c s role in making the recommendation is to draw attention to the specification and to promote its widespread deployment. this enhances the functionality and interoperability of the web. this w3c recommendation of cors was produced jointly by the web applications webapps and web application security webappsec working groups and published by the webappsec working group. no changes were made since the previous publication as proposed recommendation. if you wish to make comments regarding this document please send them to public-webappsec@w3.org subscribe archives this document was produced by groups operating under the 5 february 2004 w3c patent policy. w3c maintains a public list of any patent disclosures for the webappsec wg and the webapps wg made in connection with the deliverables of the group that page also includes instructions for disclosing a patent. an individual who has actual knowledge of a patent which the individual believes contains essential claim s must disclose the information in accordance with section 6 of the w3c patent policy. by publishing this recommendation w3c expects that the functionality specified in this cross-origin resource sharing recommendation will not be affected by changes to html5 or to http status code 308 as those specifications proceed to recommendation and rfc status respectively. an initial implementation report is available with a supplement for changes since candidate recommendation. table of contents 1 introduction 2 conformance 3 terminology 4 security considerations 5 syntax 5.1 access-control-allow-origin response header 5.2 access-control-allow-credentials response header 5.3 access-control-expose-headers response header 5.4 access-control-max-age response header 5.5 access-control-allow-methods response header 5.6 access-control-allow-headers response header 5.7 origin request header 5.8 access-control-request-method request header 5.9 access-control-request-headers request header 6 resource processing model 6.1 simple cross-origin request actual request and redirects 6.2 preflight request 6.3 security 6.4 implementation considerations 7 user agent processing model 7.1 cross-origin request 7.1.1 handling a response to a cross-origin request 7.1.2 cross-origin request status 7.1.3 source origin 7.1.4 simple cross-origin request 7.1.5 cross-origin request with preflight 7.1.6 preflight result cache 7.1.7 generic cross-origin request algorithms 7.2 resource sharing check 7.3 security 8 cors api specification advice 8.1 constructing a cross-origin request 8.2 dealing with same origin to cross-origin redirects 8.3 dealing with the cross-origin request status 8.4 security references acknowledgments 1 introduction this section is non-normative. user agents commonly apply same-origin restrictions to network requests. these restrictions prevent a client-side web application running from one origin from obtaining data retrieved from another origin and also limit unsafe http requests that can be automatically launched toward destinations that differ from the running application s origin. in user agents that follow this pattern network requests typically include user credentials with cross-origin requests including http authentication and cookie information. this specification extends this model in several ways a response can include an access-control-allow-origin header with the origin of where the request originated from as the value to allow access to the resource s contents. the user agent validates that the value and origin of where the request originated match. user agents can discover via a preflight request whether a cross-origin resource is prepared to accept requests using a non-simple method from a given origin. this is again validated by the user agent. server-side applications are enabled to discover that an http request was deemed a cross-origin request by the user agent through the origin header. this extension enables server-side applications to enforce limitations e.g. returning nothing on the cross-origin requests that they are willing to service. this specification is a building block for other specifications so-called cors api specifications which define how this specification is used. examples are server-sent events and xmlhttprequest. eventsource xhr the cors wiki page provides more background information about this document. if a resource author has a simple text resource residing at http example.com hello which contains the string hello world and would like http hello-world.example to be able to access it the response combined with a header introduced by this specification could look as follows access-control-allow-origin http hello-world.example hello world using xmlhttprequest a client-side web application on http hello-world.example can access this resource as follows var client new xmlhttprequest client.open get http example.com hello client.onreadystatechange function do something client.send it gets slightly more complicated if the resource author wants to be able to handle cross-origin requests using methods other than simple methods. in that case the author needs to reply to a preflight request that uses the options method and then needs to handle the actual request that uses the desired method delete in this example and give an appropriate response. the response to the preflight request could have the following headers specified access-control-allow-origin http hello-world.example access-control-max-age 3628800 access-control-allow-methods put delete the access-control-max-age header indicates how long the response can be cached so that for subsequent requests within the specified time no preflight request has to be made. the access-control-allow-methods header indicates the methods that can be used in the actual request. the response to the actual request can simply contain this header access-control-allow-origin http hello-world.example the complexity of invoking the additional preflight request is the task of the user agent. using xmlhttprequest again and assuming the application were hosted at http calendar.example app the author could use the following ecmascript snippet function deleteitem itemid updateui var client new xmlhttprequest client.open delete http calendar.example app client.onload updateui client.onerror updateui client.onabort updateui client.send id itemid 2 conformance this specification is written for resource authors and user agents. it includes advice for specifications that define apis that use the cross-origin request algorithm defined in this specification cors api specifications and the general security considerations section includes some advice for client-side web application authors. as well as sections and appendices marked as non-normative all diagrams examples and notes in this specification are non-normative. everything else in this specification is normative. in this specification the words must and may are to be interpreted as described in rfc 2119. rfc2119 requirements phrased in the imperative as part of algorithms e.g. terminate the algorithm are to be interpreted with the meaning of the key word e.g. must used in introducing the algorithm. a conformant resource is one that implements all the requirements listed in this specification that are applicable to resources. a conformant user agent is one that implements all the requirements listed in this specification that are applicable to user agents. user agents and resource authors may employ any algorithm to implement this specification so long as the end result is indistinguishable from the result that would be obtained by the specification s algorithms. 3 terminology some terminology in this specification is from the web origin concept html http and uri. origin html http uri terminology is generally defined throughout the specification. however the few definitions that did not really fit anywhere else are defined here instead. comparing two strings in a case-sensitive manner means comparing them exactly codepoint for codepoint. comparing two strings in an ascii case-insensitive manner means comparing them exactly codepoint for codepoint except that the characters in the range u+0041 latin capital letter a to u+005a latin capital letter z and the corresponding characters in the range u+0061 latin small letter a to u+007a latin small letter z are considered to also match. converting a string to ascii lowercase means replacing all characters in the range u+0041 latin capital letter a to u+005a latin capital letter z with the corresponding characters in the range u+0061 latin small letter a to u+007a latin small letter z the term user credentials for the purposes of this specification means cookies http authentication and client-side ssl certificates that would be sent based on the user agent s previous interactions with the origin. specifically it does not refer to proxy authentication or the origin header. cookies the term cross-origin is used to mean non same origin. a method is said to be a simple method if it is a case-sensitive match for one of the following get head post a header is said to be a simple header if the header field name is an ascii case-insensitive match for accept accept-language or content-language or if it is an ascii case-insensitive match for content-type and the header field value media type excluding parameters is an ascii case-insensitive match for application x-www-form-urlencoded multipart form-data or text plain. a header is said to be a simple response header if the header field name is an ascii case-insensitive match for one of the following cache-control content-language content-type expires last-modified pragma when parsing a header the header must be parsed per the corresponding abnf production in the syntax section. if the header does not match the production it is said that header parsing failed. 4 security considerations this section is non-normative. security requirements and considerations are listed throughout this specification. this section lists advice that did not fit anywhere else. a simple cross-origin request has been defined as congruent with those which may be generated by currently deployed user agents that do not conform to this specification. simple cross-origin requests generated outside this specification such as cross-origin form submissions using get or post or cross-origin get requests resulting from script elements typically include user credentials so resources conforming to this specification must always be prepared to expect simple cross-origin requests with credentials. because of this resources for which simple requests have significance other than retrieval must protect themselves from cross-site request forgery csrf by requiring the inclusion of an unguessable token in the explicitly provided content of the request. csrf this specification defines how to authorize an instance of an application from a foreign origin executing in the user agent to access the representation of the resource in an http response. certain types of resources should not attempt to specify particular authorized origins but instead either deny or allow all origins. a resource that is not useful to applications from other origins such as a login page ought not to return an access-control-allow-origin header. the resource still must protect itself against csrf attacks such as by requiring the inclusion of an unguessable token in the explicitly provided content of the request. the security properties of such resources are unaffected by user-agents conformant to this specification. a resource that is publicly accessible with no access control checks can always safely return an access-control-allow-origin header whose value is a get response whose entity body happens to parse as ecmascript can return an access-control-allow-origin header whose value is provided there are no sensitive comments as it can be accessed cross-origin using an html script element. if needed such resources can implement access control and csrf protections as described above. requests made with user credentials or the origin header require special consideration. when requests have significance other than retrieval and when relying on the origin header resources must be careful to distinguish between authorizing a request including its side-effects and authorizing access to the representation of that resource in the response. authorization for a request should be performed using only the intersection of the authority of the user and the requesting origin s it is often appropriate for resources to require an authorization ceremony which explicitly asks for a user to consent that cross-origin requests with credentials be honored from a given origin. in such cases passing security tokens explicitly as part of the cross-origin request can remove any ambiguity as to the scope of authorization. oauth is an example of this pattern. oauth use of user credentials in a cross-origin request is appropriate when a cross-origin request with credentials as defined in this specification is used to substitute for alternate methods of authenticated resource sharing such as server-to-server back channels jsonp or cross-document messaging. jsonp html this substitution can expose additional attack surface in some cases as a cross-site scripting vulnerability in the requesting origin can allow elevation of privileges against the requested resource when compared to a server-to-server back channel. as a substitute for jsonp-style cross-origin credentialed requests use of this specification significantly improves the security posture of the requesting application as it provides cross-origin data access whereas jsonp operates via cross-origin code-injection. as a substitute for cross-origin communication techniques relying on loading a resource with credentials into an html iframe element and subsequently employing cross-document messaging or other cross-origin side channels this specification provides a roughly equivalent security posture. again data received from origins that are not completely trusted has to be validated to conform to expected formats and authorized values. for requests to resources that have no significance other than retrieval and where the credentials are used only to provide user-specific customization for otherwise publicly accessible information. in this case restricting access to certain origins may protect user privacy by preventing customizations from being used to identify a user except at authorized origins. when this specification is used for requests which have significance other than retrieval and which involve coordination between or data originating from more than two origins e.g. between resources enabling editing printing and storage each at distinct origins requests ought to set the omit credentials flag and resources ought to perform authorization using security tokens explicitly provided in the content of the request especially if the origins are not all mutually and completely trusted. in such multi-origin scenarios a malicious resource at one of the origins may be able to enlist the user-agent as a confused deputy and elevate its privileges by abusing user credentials sent with cross-origin requests. avoiding such attacks requires that the coordinating applications have explicit knowledge of the scope of privilege for each origin and that all parameters and instructions received are carefully validated at each step in the coordination to ensure that effects implied do not exceed the authority of the originating principal. confused given the difficulty of avoiding such vulnerabilities in multi-origin interactions it is recommended that instead of using user credentials automatically attached to the request by the user agent security tokens which specify the particular capabilities and resources authorized be passed as part of the explicit content of a request. oauth again provides an example of such a pattern. authors of client-side web applications are strongly encouraged to validate content retrieved from a cross-origin resource as it might be harmful. web applications that are not uniquely identified by specific host names and or mapped to specific ports do not necessarily have a unique origin and thus will not be able to securely utilize the mechanism defined in this specification. this is because an origin is composed of only the scheme hostname and port. for example a web application whose url is of the type example.org app-name and the app-name portion is necessary to distinguish the web application from other web applications also running at example.org will be unable to securely employ the mechanism defined in this specification. mapping web applications to distinct origins is vital for secure web applications. 5 syntax this section defines the syntax of the new headers this specification introduces. it also provides a short description of the function of each header. the resource processing model section details how resources are to use these headers in a response. likewise the user agent processing model section details how user agents are to use these headers. the abnf syntax used in this section is from http 1.1. http http 1.1 is used as abnf basis to ensure that the new headers have equivalent parsing rules to those introduced in that specification. http 1.1 currently does not make leading ows implied in header value definitions but that form is assumed here. 5.1 access-control-allow-origin response header the access-control-allow-origin header indicates whether a resource can be shared based by returning the value of the origin request header or null in the response. abnf access-control-allow-origin access-control-allow-origin origin-list-or-null in practice the origin-list-or-null production is more constrained. rather than allowing a space-separated list of origins it is either a single origin or the string null 5.2 access-control-allow-credentials response header the access-control-allow-credentials header indicates whether the response to request can be exposed when the omit credentials flag is unset. when part of the response to a preflight request it indicates that the actual request can include user credentials. abnf access-control-allow-credentials access-control-allow-credentials true true x74.72.75.65 true case-sensitive 5.3 access-control-expose-headers response header the access-control-expose-headers header indicates which headers are safe to expose to the api of a cors api specification. abnf access-control-expose-headers access-control-expose-headers field-name 5.4 access-control-max-age response header the access-control-max-age header indicates how long the results of a preflight request can be cached in a preflight result cache. abnf access-control-max-age access-control-max-age delta-seconds 5.5 access-control-allow-methods response header the access-control-allow-methods header indicates as part of the response to a preflight request which methods can be used during the actual request. the allow header is not relevant for the purposes of the cors protocol. abnf access-control-allow-methods access-control-allow-methods method 5.6 access-control-allow-headers response header the access-control-allow-headers header indicates as part of the response to a preflight request which header field names can be used during the actual request. abnf access-control-allow-headers access-control-allow-headers field-name 5.7 origin request header the origin header indicates where the cross-origin request or preflight request originates from. origin 5.8 access-control-request-method request header the access-control-request-method header indicates which method will be used in the actual request as part of the preflight request. abnf access-control-request-method access-control-request-method method 5.9 access-control-request-headers request header the access-control-request-headers header indicates which headers will be used in the actual request as part of the preflight request. abnf access-control-request-headers access-control-request-headers field-name 6 resource processing model this section describes the processing models that resources have to implement. each type of request a resource might have to deal with is described in its own subsection. the resource sharing policy described by this specification is bound to a particular resource. for the purposes of this section each resource is bound to the following a list of origins consisting of zero or more origins that are allowed access to the resource. this can include the origin of the resource itself though be aware that requests to cross-origin resources can be redirected back to the resource. a list of methods consisting of zero or more methods that are supported by the resource. a list of headers consisting of zero or more header field names that are supported by the resource. a list of exposed headers consisting of zero or more header field names of headers other than the simple response headers that the resource might use and can be exposed. a supports credentials flag that indicates whether the resource supports user credentials in the request. it is true when the resource does and false otherwise. 6.1 simple cross-origin request actual request and redirects in response to a simple cross-origin request or actual request the resource indicates whether or not to share the response. if the resource has been relocated it indicates whether to share its new url. resources must use the following set of steps to determine which additional headers to use in the response if the origin header is not present terminate this set of steps. the request is outside the scope of this specification. if the value of the origin header is not a case-sensitive match for any of the values in list of origins do not set any additional headers and terminate this set of steps. always matching is acceptable since the list of origins can be unbounded. if the resource supports credentials add a single access-control-allow-origin header with the value of the origin header as value and add a single access-control-allow-credentials header with the case-sensitive string true as value. otherwise add a single access-control-allow-origin header with either the value of the origin header or the string as value. the string cannot be used for a resource that supports credentials. if the list of exposed headers is not empty add one or more access-control-expose-headers headers with as values the header field names given in the list of exposed headers. by not adding the appropriate headers resource can also clear the preflight result cache of all entries where origin is a case-sensitive match for the value of the origin header and url is a case-sensitive match for the url of the resource. 6.2 preflight request in response to a preflight request the resource indicates which methods and headers other than simple methods and simple headers it is willing to handle and whether it supports credentials. resources must use the following set of steps to determine which additional headers to use in the response if the origin header is not present terminate this set of steps. the request is outside the scope of this specification. if the value of the origin header is not a case-sensitive match for any of the values in list of origins do not set any additional headers and terminate this set of steps. always matching is acceptable since the list of origins can be unbounded. the origin header can only contain a single origin as the user agent will not follow redirects. let method be the value as result of parsing the access-control-request-method header. if there is no access-control-request-method header or if parsing failed do not set any additional headers and terminate this set of steps. the request is outside the scope of this specification. let header field-names be the values as result of parsing the access-control-request-headers headers. if there are no access-control-request-headers headers let header field-names be the empty list. if parsing failed do not set any additional headers and terminate this set of steps. the request is outside the scope of this specification. if method is not a case-sensitive match for any of the values in list of methods do not set any additional headers and terminate this set of steps. always matching is acceptable since the list of methods can be unbounded. if any of the header field-names is not a ascii case-insensitive match for any of the values in list of headers do not set any additional headers and terminate this set of steps. always matching is acceptable since the list of headers can be unbounded. if the resource supports credentials add a single access-control-allow-origin header with the value of the origin header as value and add a single access-control-allow-credentials header with the case-sensitive string true as value. otherwise add a single access-control-allow-origin header with either the value of the origin header or the string as value. the string cannot be used for a resource that supports credentials. optionally add a single access-control-max-age header with as value the amount of seconds the user agent is allowed to cache the result of the request. if method is a simple method this step may be skipped. add one or more access-control-allow-methods headers consisting of a subset of the list of methods. if a method is a simple method it does not need to be listed but this is not prohibited. since the list of methods can be unbounded simply returning the method indicated by access-control-request-method if supported can be enough. if each of the header field-names is a simple header and none is content-type this step may be skipped. add one or more access-control-allow-headers headers consisting of a subset of the list of headers. if a header field name is a simple header and is not content-type it is not required to be listed. content-type is to be listed as only a subset of its values makes it qualify as simple header. since the list of headers can be unbounded simply returning supported headers from access-control-allow-headers can be enough. 6.3 security this section is non-normative. resource authors are strongly encouraged to ensure that requests using safe methods e.g. get or options have no side effects so potential attackers cannot modify the user s data easily. if resources are set up like this attackers would effectively have to be on the list of origins to do harm. in addition to checking the origin header resource authors are strongly encouraged to also check the host header. that is make sure that the host name provided by that header matches the host name of the server on which the resource resides. this will provide protection against dns rebinding attacks. to provide integrity protection of resource sharing policy statements usage of ssl tls is encouraged. 6.4 implementation considerations this section is non-normative. resources that wish to enable themselves to be shared with multiple origins but do not respond uniformly with must in practice generate the access-control-allow-origin header dynamically in response to every request they wish to allow. as a consequence authors of such resources should send a vary origin http header or provide other appropriate control directives to prevent caching of such responses which may be inaccurate if re-used across-origins. 7 user agent processing model this section describes the processing models that user agents have to implement. the processing models in this sections need to be referenced by a cors api specification that defines when the algorithm is invoked and how the return values are to be handled. the processing models are not suitable for standalone use. 7.1 cross-origin request the cross-origin request algorithm takes the following parameters request url the url to be fetched. the request url is modified in face of redirects. request method the method for the request. get unless explicitly set. author request headers a list of headers set by authors for the request. empty unless explicitly set. request entity body the entity body for the request. missing unless explicitly set. source origin the origin of the request. due to the specifics of some apis this cannot be defined in a generic way and therefore it has to be provided as argument. referrer source either a document or url. used to determine the referer header. manual redirect flag set when redirects are not to be automatically followed. omit credentials flag set when user credentials are to be excluded in the request and when cookies are to be ignored in its response. force preflight flag set when a preflight request is required. the cross-origin request algorithm can be used by cors api specifications who wish to allow cross-origin requests for the network apis they define. cors api specifications are free to limit the abilities of a cross-origin request. e.g. the omit credentials flag could always be set. when the cross-origin request algorithm is invoked these steps must be followed if for some reason the user agent does not want to make the request terminate this algorithm and set the cross-origin request status to network error. the request url could have been blacklisted by the user in some fashion. if the following conditions are true follow the simple cross-origin request algorithm the request method is a simple method and the force preflight flag is unset. each of the author request headers is a simple header or author request headers is empty. otherwise follow the cross-origin request with preflight algorithm. cross-origin requests using a method that is simple with author request headers that are not simple will have a preflight request to ensure that the resource can handle those headers. similarly to requests using a method that is not a simple method. 7.1.1 handling a response to a cross-origin request user agents must filter out all response headers other than those that are a simple response header or of which the field name is an ascii case-insensitive match for one of the values of the access-control-expose-headers headers if any before exposing response headers to apis defined in cors api specifications. the getresponseheader method of xmlhttprequest will therefore not expose any header not indicated above. 7.1.2 cross-origin request status each cross-origin request has an associated cross-origin request status that cors api specifications that enable an api to make cross-origin requests can hook into. it can take at most two distinct values over the course of a cross-origin request. the values are preflight complete the user agent is about to make the actual request. success the resource can be shared. abort error the user aborted the request. network error the resource cannot be shared. also used when a dns error tls negotiation failure or other type of network error occurs. this does not include http responses that indicate some type of error such as http status code 410. 7.1.3 source origin the source origin is the initial origin that user agents must use for the origin header. it can be modified during the redirect steps. 7.1.4 simple cross-origin request the steps below describe what user agents must do for a simple cross-origin request apply the make a request steps and observe the request rules below while making the request. if the manual redirect flag is unset and the response has an http status code of 301 302 303 307 or 308 apply the redirect steps. if the end user cancels the request apply the abort steps. if there is a network error in case of dns errors tls negotiation failure or other type of network errors apply the network error steps. do not request any kind of end user interaction. this does not include http responses that indicate some type of error such as http status code 410. otherwise perform a resource sharing check. if it returns fail apply the network error steps. otherwise if it returns pass terminate this algorithm and set the cross-origin request status to success. do not actually terminate the request. 7.1.5 cross-origin request with preflight to protect resources against cross-origin requests that could not originate from certain user agents before this specification existed a preflight request is made to ensure that the resource is aware of this specification. the result of this request is stored in a preflight result cache. the steps below describe what user agents must do for a cross-origin request with preflight. this is a request to a non same-origin url that first needs to be authorized using either a preflight result cache entry or a preflight request. go to the next step if the following conditions are true for request method there either is a method cache match or it is a simple method and the force preflight flag is unset. for every header of author request headers there either is a header cache match for the field name or it is a simple header. otherwise make a preflight request. fetch the request url from origin source origin using referrer source as override referrer source with the manual redirect flag and the block cookies flag set using the method options and with the following additional constraints include an access-control-request-method header with as header field value the request method even when that is a simple method if author request headers is not empty include an access-control-request-headers header with as header field value a comma-separated list of the header field names from author request headers in lexicographical order each converted to ascii lowercase even when one or more are a simple header exclude the author request headers. exclude user credentials. exclude the request entity body. the following request rules are to be observed while making the preflight request if the end user cancels the request apply the abort steps. if the response has an http status code that is not in the 2xx range apply the network error steps. the cache and network error steps are not used here as this is about an actual network error. if there is a network error in case of dns errors tls negotiation failure or other type of network errors apply the network error steps. do not request any kind of end user interaction. this does not include http responses that indicate some type of error such as http status code 410. the cache and network error steps are not used here as this is about an actual network error. otherwise the http status code is in the 2xx range if the resource sharing check returns fail apply the cache and network error steps. let methods be the empty list. if there are one or more access-control-allow-methods headers let methods be the values as result of parsing the headers. if parsing failed apply the cache and network error steps. if methods is still the empty list and the force preflight flag is set append the request method to methods. this ensures that preflight requests that happened solely because of the force preflight flag are cached too. let headers be the empty list. if there are one or more access-control-allow-headers headers let headers be the values as result of parsing the headers. if parsing failed apply the cache and network error steps. if request method is not a case-sensitive match for any method in methods and is not a simple method apply the cache and network error steps. if the field name of each header in author request headers is not an ascii case-insensitive match for one of the header field names in headers and the header is not a simple header apply the cache and network error steps. if for some reason the user agent is unable to provide a preflight result cache e.g. because of limited disk space go to the next step in the overall set of steps i.e. the actual request if there is a single access-control-max-age header parse it and let max-age be the resulting value. if there is no such header there is more than one such header or parsing failed let max-age be a value at the discretion of the user agent zero is allowed if the user agent imposes a limit on the max-age field value and max-age is greater than that limit let max-age be the limit. for each method in methods for which there is a method cache match set the max-age field value of the matching entry to max-age. for each method in methods for which there is no method cache match create a new entry in the preflight result cache with the various fields set as follows origin the source origin. url the request url. max-age the max-age. credentials false if the omit credentials flag is set or true otherwise. method the given method. header empty. for each header in headers for which there is a header cache match set the max-age field value of the matching entry to max-age. for each header in headers for which there is no header cache match create a new entry in the preflight result cache with the various fields set as follows origin the source origin. url the request url. max-age the max-age. credentials false if the omit credentials flag is set or true otherwise. method empty. header the given header. set the cross-origin request status to preflight complete. this is the actual request. apply the make a request steps and observe the request rules below while making the request. if the response has an http status code of 301 302 303 307 or 308 apply the cache and network error steps. if the end user cancels the request apply the abort steps. if there is a network error in case of dns errors tls negotiation failure or other type of network errors apply the network error steps. do not request any kind of end user interaction. this does not include http responses that indicate some type of error such as http status code 410. otherwise perform a resource sharing check. if it returns fail apply the cache and network error steps. otherwise if it returns pass terminate this algorithm and set the cross-origin request status to success. do not actually terminate the request. consider the following scenario the user agent gets the request from an api such as xmlhttprequest to perform a cross-origin request using the custom xmodify method from source origin http example.org to http blog.example entries hello-world. the user agent performs a preflight request using the options method to http blog.example entries hello-world and includes the origin and access-control-request-method headers with the appropriate values. the response to that request includes the following headers access-control-allow-origin http example.org access-control-max-age 2520 access-control-allow-methods put delete xmodify the user agent then performs the desired request using the xmodify method to http blog.example entries hello-world as this was allowed by the resource. in addition for the coming forty-two minutes no preflight request will be needed. 7.1.6 preflight result cache as mentioned a cross-origin request with preflight uses a preflight result cache. this cache consists of a set of entries. each entry consists of the following fields origin holds the source origin. url holds the request url. max-age holds the access-control-max-age header value. credentials false if the omit credentials flag is set or true otherwise. method empty if header is not empty otherwise one of the values from the access-control-allow-methods headers. header empty if method is not empty otherwise one of the values from the access-control-allow-headers headers. to be clear the method and header fields are mutually exclusive. when one of them is empty the other is non-empty. the primary key of an entry consists of all fields excluding the max-age field. entries must be removed when the time specified in the max-age field has passed since storing the entry. entries can also be added and removed per the algorithms below. they are added and removed in such a way that there can never be duplicate items in the cache. user agents may clear cache entries before the time specified in the max-age field has passed. although this effectively makes the preflight result cache optional user agents are strongly encouraged to support it. 7.1.7 generic cross-origin request algorithms the variables used in the generic set of steps are part of the algorithms that invoke these set of steps. whenever the make a request steps are applied fetch the request url from origin source origin using referrer source as override referrer source with the manual redirect flag set and the block cookies flag set if the omit credentials flag is set. use method request method entity body request entity body including the author request headers and include user credentials if the omit credentials flag is unset. whenever the redirect steps are applied follow this set of steps let original url be the request url. let request url be the url conveyed by the location header in the redirect response. if the request url scheme is not supported infinite loop precautions are violated or the user agent does not wish to make the new request for some other reason apply the network error steps. if the request url contains the userinfo production apply the network error steps. if the resource sharing check for the current resource returns fail apply the network error steps. if the request url origin is not same origin with the original url origin set source origin to a globally unique identifier becomes null when transmitted transparently follow the redirect while observing the set of request rules. whenever the abort steps are applied terminate the algorithm that invoked this set of steps and set the cross-origin request status to abort error. whenever the network error steps are applied terminate the algorithm that invoked this set of steps and set the cross-origin request status to network error. this has no effect on setting of user credentials. i.e. if the block cookies flag is unset cookies will be set by the response. whenever the cache and network error steps are applied follow these steps remove the entries in the preflight result cache where origin field value is a case-sensitive match for source origin and url field value is a case-sensitive match for request url. apply the network error steps acting as if the algorithm that invoked the cache and network error steps invoked the network error steps instead. there is a cache match when there is a cache entry in the preflight result cache for which the following is true the origin field value is a case-sensitive match for source origin. the url field value is a case-sensitive match for request url. the credentials field value is true and the omit credentials flag is unset or it is false and the omit credentials flag is set. there is a method cache match when there is a cache entry for which there is a cache match and the method field value is a case-sensitive match for the given method. there is a header cache match when there is a cache entry for which there is a cache match and the header field value is an ascii case-insensitive match for the given header field name. 7.2 resource sharing check the resource sharing check algorithm for a given resource is as follows if the response includes zero or more than one access-control-allow-origin header values return fail and terminate this algorithm. if the access-control-allow-origin header value is the character and the omit credentials flag is set return pass and terminate this algorithm. if the value of access-control-allow-origin is not a case-sensitive match for the value of the origin header as defined by its specification return fail and terminate this algorithm. if the omit credentials flag is unset and the response includes zero or more than one access-control-allow-credentials header values return fail and terminate this algorithm. if the omit credentials flag is unset and the access-control-allow-credentials header value is not a case-sensitive match for true return fail and terminate this algorithm. return pass. the above algorithm also functions when the ascii serialization of an origin is the string null 7.3 security this section is non-normative. at various places user agents are allowed to take additional precautions. e.g. user agents are allowed to not store cache items remove cache items before they reached their max-age and not connect to certain urls. user agents are encouraged to impose a limit on max-age so items cannot stay in the preflight result cache for unreasonable amounts of time. as indicated as the first step of the cross-origin request algorithm and in the redirect steps algorithm user agents are allowed to terminate the algorithm and not make a request. this could be done because e.g. the origin of the resource blacklisted. the origin of the resource is known to be part of an intranet. the url scheme is not supported. https to http is not allowed. https is not allowed because of certificate errors user agents are encouraged to apply security decisions on a generic level and not just to the resource sharing policy. e.g. if a user agent disallows requests from the https to the http scheme for a cross-origin request it is encouraged to do the same for the html img element. 8 cors api specification advice this section is non-normative. this specification defines a resource sharing policy that cannot be implemented without an api that utilizes it. the specification that defines the api that uses the policy is a cors api specification. in case a cors api specification defines multiple apis that utilize the policy the advice is to be considered separately for each api. 8.1 constructing a cross-origin request for all cross-origin requests that apis can make for which the resource sharing policy in this specification is supposed to apply the cors api specification needs to reference the cross-origin request algorithm and set the following input variables appropriately request url request method author request headers request entity body source origin manual redirect flag omit credentials flag and the force preflight flag. cors api specifications are allowed to let these input variables be controlled by the api but can also set fixed values. a cors api specification for an api that only allows requests using the get method might set request method to get request entity body to empty and source origin to some appropriate value and let the other variables be controlled by the api. 8.2 dealing with same origin to cross-origin redirects since browsers are based on a same origin security model and the policy outlined in this specification is intended for apis used in browsers it is expected that apis that will utilize this policy will have to handle a same origin request that results in a redirect that is cross-origin in a special way. for apis that transparently handle redirects cors api specifications are encouraged to handle this scenario transparently as well by catching the redirect and invoking the cross-origin request algorithm on the cross-origin redirect url. the xmlhttprequest specification does this. xhr 8.3 dealing with the cross-origin request status while a cross-origin request is progressing its associated cross-origin request status is updated. depending on the value of the cross-origin request status the api is to react in a different way preflight complete features that can only be safely exposed after a preflight request can now be enabled. e.g. upload progress events for xmlhttprequest. success the contents of the response can be shared with the api including headers that have not been filtered out. the request itself can still be progressing. i.e. the cross-origin request status value does not indicate that the request has completed. abort error handle analogous to requests where the user aborted the request. this can be handled equivalently to how network error is handled. ensure not to reveal any further information about the request. network error handle analogous to requests where some kind of error occurred. ensure not the reveal any further information about the request. 8.4 security similarly to same origin requests cors api specifications are encouraged to properly limit headers methods and user credentials the author can set and get for requests that are cross-origin. reviewing the xmlhttprequest specification provides a good start for the kind of limitations that are to be imposed. xhr cors api specifications also need to ensure not to reveal anything until the cross-origin request status is set to preflight complete or success to prevent e.g. port scanning. in xmlhttprequest progress events are dispatched only after the cross-origin request status is set to success. upload progress events are only dispatched once the cross-origin request status is preflight complete. references confused non-normative the confused deputy norm hardy. cookies http state management mechanism adam barth. ietf. csrf non-normative cross-site request forgeries peter watkins. eventsource non-normative server-sent events ian hickson. w3c. html html5 berjon leithead navara o connor pfeiffer and hickson. w3c. http hypertext transfer protocol http 1.1 roy fielding james gettys jeffrey mogul et al.. ietf. 308 the hypertext transfer protocol http status code 308 permanent redirect julian reschke. ietf. jsonp non-normative jsonp bob ippolito. oauth non-normative the oauth 1.0 protocol eran hammer-lahav. ietf. origin the web origin concept adam barth. ietf. rfc2119 key words for use in rfcs to indicate requirement levels scott bradner. ietf. uri uniform resource identifier uri generic syntax tim berners-lee roy fielding and larry masinter. ietf. xhr non-normative xmlhttprequest anne van kesteren. w3c. acknowledgments this appendix is non-normative. the editor would like to thank adam barth alexey proskuryakov arne johannessen arthur barstow benjamin hawkes-lewis bert bos bj rn h hrmann boris zbarsky brad hill cameron mccormack collin jackson david h s ther david orchard dean jackson eric lawrence frank ellerman frederick hirsch graham klyne hal lockhart henri sivonen ian hickson jesse m. heines jonas sicking julian reschke lachlan hunt    kang-hao lu maciej stachowiak marc silbey marcos caceres mark nottingham mark s. miller martin d rst matt womer mhano harkness michael smith mohamed zergaoui nikunj mehta odin h rthe omdal philip j genstedt sharath udupa simon pieters sunava dutta surya ismail thomas roessler tyler close jeff hodges vladimir dzhuvinov wayne carr and zhenbin xu for their contributions to this specification. special thanks to brad porter matt oshry and r. auburn who all helped editing earlier versions of this document. 