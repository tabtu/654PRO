owl 2 web ontology language rdf-based semantics second edition owl 2 web ontology language rdf-based semantics second edition w3c recommendation 11 december 2012 this version http www.w3.org tr 2012 rec-owl2-rdf-based-semantics-20121211 latest version series 2 http www.w3.org tr owl2-rdf-based-semantics latest recommendation http www.w3.org tr owl-rdf-based-semantics previous version http www.w3.org tr 2012 per-owl2-rdf-based-semantics-20121018 editors michael schneider fzi research center for information technology contributors in alphabetical order jeremy carroll hp now at topquadrant ivan herman w3c ercim peter f. patel-schneider nuance communications please refer to the errata for this document which may include some normative corrections. a color-coded version of this document showing changes made since the previous version is also available. this document is also available in these non-normative formats pdf version. see also translations. copyright 2012 w3c mit ercim keio all rights reserved. w3c liability trademark and document use rules apply. abstract the owl 2 web ontology language informally owl 2 is an ontology language for the semantic web with formally defined meaning. owl 2 ontologies provide classes properties individuals and data values and are stored as semantic web documents. owl 2 ontologies can be used along with information written in rdf and owl 2 ontologies themselves are primarily exchanged as rdf documents. the owl 2 document overview describes the overall state of owl 2 and should be read before other owl 2 documents. this document defines the rdf-compatible model-theoretic semantics of owl 2. status of this document may be superseded this section describes the status of this document at the time of its publication. other documents may supersede this document. a list of current w3c publications and the latest revision of this technical report can be found in the w3c technical reports index at http www.w3.org tr summary of changes there have been no substantive changes since the previous version. for details on the minor changes see the change log and color-coded diff. please send comments please send any comments to public-owl-comments@w3.org public archive although work on this document by the owl working group is complete comments may be addressed in the errata or in future revisions. open discussion among developers is welcome at public-owl-dev@w3.org public archive endorsed by w3c this document has been reviewed by w3c members by software developers and by other w3c groups and interested parties and is endorsed by the director as a w3c recommendation. it is a stable document and may be used as reference material or cited from another document. w3c s role in making the recommendation is to draw attention to the specification and to promote its widespread deployment. this enhances the functionality and interoperability of the web. patents this document was produced by a group operating under the 5 february 2004 w3c patent policy. w3c maintains a public list of any patent disclosures made in connection with the deliverables of the group that page also includes instructions for disclosing a patent. table of contents 1 introduction informative 2 ontologies 2.1 syntax 2.2 content of ontologies informative 3 vocabulary 3.1 standard prefixes 3.2 vocabulary terms 3.3 datatype names 3.4 facet names 4 interpretations 4.1 datatype maps 4.2 vocabulary interpretations 4.3 satisfaction consistency and entailment 4.4 parts of the universe 4.5 class extensions 5 semantic conditions 5.1 semantic conditions for the parts of the universe 5.2 semantic conditions for the vocabulary classes 5.3 semantic conditions for the vocabulary properties 5.4 semantic conditions for boolean connectives 5.5 semantic conditions for enumerations 5.6 semantic conditions for property restrictions 5.7 semantic conditions for datatype restrictions 5.8 semantic conditions for the rdfs vocabulary 5.9 semantic conditions for equivalence and disjointness 5.10 semantic conditions for n-ary disjointness 5.11 semantic conditions for sub property chains 5.12 semantic conditions for inverse properties 5.13 semantic conditions for property characteristics 5.14 semantic conditions for keys 5.15 semantic conditions for negative property assertions 6 appendix axiomatic triples informative 6.1 axiomatic triples in rdf 6.2 axiomatic triples for the vocabulary classes 6.3 axiomatic triples for the vocabulary properties 6.4 a set of axiomatic triples 7 appendix relationship to the direct semantics informative 7.1 example on semantic differences 7.2 correspondence theorem 7.3 proof for the correspondence theorem 8 appendix comprehension conditions informative 8.1 comprehension conditions for sequences 8.2 comprehension conditions for boolean connectives 8.3 comprehension conditions for enumerations 8.4 comprehension conditions for property restrictions 8.5 comprehension conditions for datatype restrictions 8.6 comprehension conditions for inverse properties 9 appendix changes from owl 1 informative 10 appendix change log informative 10.1 changes since recommendation 10.2 changes since proposed recommendation 10.3 changes since candidate recommendation 10.4 changes since last call 11 acknowledgments 12 references 12.1 normative references 12.2 nonnormative references 1 introduction informative this document defines the rdf-compatible model-theoretic semantics of owl 2 referred to as the owl 2 rdf-based semantics the owl 2 rdf-based semantics gives a formal meaning to every rdf graph rdf concepts and is fully compatible with the rdf semantics specification rdf semantics the specification provided here is the successor to the original owl 1 rdf-compatible semantics specification owl 1 rdf-compatible semantics technically the owl 2 rdf-based semantics is defined as a semantic extension of d-entailment rdfs with datatype support as specified in the rdf semantics rdf semantics in other words the meaning given to an rdf graph by the owl 2 rdf-based semantics includes the meaning provided by the semantics of rdfs with datatypes and additional meaning is specified for all the language constructs of owl 2 such as boolean connectives sub property chains and qualified cardinality restrictions see the owl 2 structural specification owl 2 specification for further information on all the language constructs of owl 2 the definition of the semantics for the extra constructs follows the design principles as applied to the rdf semantics. the content of this document is not meant to be self-contained but builds on top of the rdf semantics document rdf semantics by adding those aspects that are specific to owl 2. hence the complete definition of the owl 2 rdf-based semantics is given by the combination of both the rdf semantics document and the document at hand. in particular the terminology used in the rdf semantics is reused here except for cases where a conflict exists with the rest of the owl 2 specification. the remainder of this section provides an overview of some of the distinguishing features of the owl 2 rdf-based semantics and outlines the document s structure and content. in section 2 the syntax over which the owl 2 rdf-based semantics is defined is the set of all rdf graphs rdf concepts the owl 2 rdf-based semantics provides a precise formal meaning for every rdf graph. the language that is determined by rdf graphs being interpreted using the owl 2 rdf-based semantics is called owl 2 full in this document rdf graphs are also called owl 2 full ontologies or simply ontologies unless there is risk of confusion. the owl 2 rdf-based semantics interprets the rdf and rdfs vocabularies rdf semantics and the owl 2 rdf-based vocabulary together with an extended set of datatypes and their constraining facets see section 3 owl 2 rdf-based interpretations section 4 are defined on a universe see section 1.3 of the rdf semantics specification rdf semantics for an overview of the basic intuition of model-theoretic semantics the universe is divided into parts namely individuals classes and properties which are identified with their rdf counterparts see figure 1 the part of individuals equals the whole universe. this means that all classes and properties are also individuals in their own right. further every name interpreted by an owl 2 rdf-based interpretation denotes an individual. the three basic parts are divided into further parts as follows. the part of individuals subsumes the part of data values which comprises the denotations of all literals. also subsumed by the individuals is the part of ontologies. the part of classes subsumes the part of datatypes which are classes consisting entirely of data values. finally the part of properties subsumes the parts of object properties data properties ontology properties and annotation properties. the part of object properties equals the whole part of properties and therefore all other kinds of properties are also object properties. for annotations properties note that annotations are not semantic-free under the owl 2 rdf-based semantics. just like every other triple or set of triples occurring in an rdf graph an annotation is assigned a truth value by any given owl 2 rdf-based interpretation. hence although annotations are meant to be semantically weak i.e. their formal meaning does not significantly exceed that originating from the rdf semantics specification adding an annotation may still change the meaning of an ontology. a similar discussion holds for statements that are built from ontology properties such as owl imports which are used to define relationships between two ontologies. every class represents a specific set of individuals called the class extension of the class an individual a is an instance of a class c if a is a member of the class extension icext c since a class is itself an individual under the owl 2 rdf-based semantics classes are distinguished from their respective class extensions. this distinction allows for example that a class may be an instance of itself by being a member of its own class extension. also two classes may be equivalent by sharing the same class extension although being different individuals e.g. they do not need to share the same properties. similarly every property has an associated property extension that consists of pairs of individuals an individual a1 has a relationship to an individual a2 with respect to a property p if the pair a1 a2 is a member of the property extension iext p again properties are distinguished from their property extensions. in general if there are no further constraints an arbitrary extension may be associated with a given class or property and two interpretations may associate distinct extensions with the same class or property. individuals may play different roles for example an individual can be both a data property and an annotation property since the different parts of the universe of an owl 2 rdf-based interpretation are not required to be mutually disjoint or an individual can be both a class and a property by associating both a class extension and a property extension with it. in the latter case there will be no specific relationship between the class extension and the property extension of such an individual without further constraints. for example the same individual can have an empty class extension while having a nonempty property extension. the main part of the owl 2 rdf-based semantics is section 5 which specifies a formal meaning for all the owl 2 language constructs by means of the owl 2 rdf-based semantic conditions. these semantic conditions extend all the semantic conditions given in the rdf semantics rdf semantics the owl 2 rdf-based semantic conditions effectively determine which sets of rdf triples are assigned a specific meaning and what this meaning is. for example semantic conditions exist that allow one to interpret the triple c owl disjointwith d to mean that the denotations of the iris c and d have disjoint class extensions. there is usually no need to provide localizing information e.g. by means of typing triples for the iris occurring in an ontology. as for the rdf semantics the owl 2 rdf-based semantic conditions have been designed to ensure that the denotation of any iri will be in the appropriate part of the universe. for example the rdf triple c owl disjointwith d is sufficient to deduce that the denotations of the iris c and d are actually classes. it is not necessary to explicitly add additional typing triples c rdf type rdfs class and d rdf type rdfs class to the ontology. in the rdf semantics this kind of automatic localization was to some extent achieved by so called axiomatic triples rdf semantics such as rdf type rdf type rdf property or rdf type rdfs domain rdfs resource however there is no explicit normative collection of additional axiomatic triples for the owl 2 rdf-based semantics instead the specific axiomatic aspects of the owl 2 rdf-based semantics are determined by a subset of the owl 2 rdf-based semantic conditions. section 6 discusses axiomatic triples in general and provides an example set of axiomatic triples that is compatible with the owl 2 rdf-based semantics. section 7 compares the owl 2 rdf-based semantics with the owl 2 direct semantics owl 2 direct semantics while the owl 2 rdf-based semantics is based on the rdf semantics specification rdf semantics the owl 2 direct semantics is a description logic style semantics. several fundamental differences exist between the two semantics but there is also a strong relationship basically stating that the owl 2 rdf-based semantics is able to reflect all logical conclusions of the owl 2 direct semantics. this means that the owl 2 direct semantics can in a sense be regarded as a semantics subset of the owl 2 rdf-based semantics. the precise relationship is given by the owl 2 correspondence theorem. significant effort has been spent in keeping the design of the owl 2 rdf-based semantics as close as possible to that of the original specification of the owl 1 rdf-compatible semantics owl 1 rdf-compatible semantics while this aim was achieved to a large degree the owl 2 rdf-based semantics actually deviates from its predecessor in several aspects. in most cases this is because of serious technical problems that would have arisen from a conservative semantic extension. one important change is that while so called comprehension conditions for the owl 2 rdf-based semantics see section 8 still exist these are not part of the normative set of semantic conditions anymore. the owl 2 rdf-based semantics also corrects several errors of owl 1. a list of differences between the two languages is given in section 9. the italicized keywords must must not should should not and may are used to specify normative features of owl 2 documents and tools and are interpreted as specified in rfc 2119 rfc 2119 figure 1 parts hierarchy of the owl 2 rdf-based semantics each node is labeled with a class iri that represents a part of the universe of an owl 2 rdf-based interpretation. arrows point from parts to their super parts. 2 ontologies this section determines the syntax for the owl 2 rdf-based semantics and gives an overview on typical content of ontologies for ontology management tasks. 2.1 syntax following sections 0.2 and 0.3 of the rdf semantics specification rdf semantics the owl 2 rdf-based semantics is defined on every rdf graph section 6.2 of rdf concepts rdf concepts i.e. on every set of rdf triples section 6.1 of rdf concepts rdf concepts in accordance with the rest of the owl 2 specification see section 2.4 of the owl 2 structural specification owl 2 specification this document uses an extended notion of an rdf graph by allowing the rdf triples in an rdf graph to contain arbitrary iris internationalized resource identifiers according to rfc 3987 rfc 3987 in contrast the rdf semantics specification rdf semantics is defined on rdf graphs containing uris rfc 2396 this change is backward compatible with the rdf specification since uris are also iris. terminological note the document at hand uses the term iri in accordance with the rest of the owl 2 specification see section 2.4 of the owl 2 structural specification owl 2 specification whereas the rdf semantics specification rdf semantics uses the term uri reference according to rfc 3987 rfc 3987 the term iri stands for an absolute resource identifier with optional fragment which is what is being used throughout this document. in contrast the term iri reference additionally covers relative references which are never used in this document. convention in this document iris are abbreviated in the way defined by section 2.4 of the owl 2 structural specification owl 2 specification i.e. the abbreviations consist of a prefix name and a local part such as prefix localpart the definition of an rdf triple according to section 6.1 of rdf concepts rdf concepts is restricted to cases where the subject of an rdf triple is an iri or a blank node section 6.6 of rdf concepts rdf concepts and where the predicate of an rdf triple is an iri. as a consequence the definition does not treat cases where for example the subject of a triple is a literal section 6.5 of rdf concepts rdf concepts as in s ex p ex o or where the predicate of a triple is a blank node as in ex s p ex o. in order to allow for interoperability with other existing and future technologies and tools the document at hand does not explicitly forbid the use of generalized rdf graphs consisting of generalized rdf triples which are defined to allow for iris literals and blank nodes to occur in the subject predicate and object position. thus an rdf graph may contain generalized rdf triples but an implementation is not required to support generalized rdf graphs. note that every rdf graph consisting entirely of rdf triples according to section 6.1 of rdf concepts rdf concepts is also a generalized rdf graph. terminological notes the term owl 2 full refers to the language that is determined by the set of all rdf graphs being interpreted using the owl 2 rdf-based semantics. further in this document the term owl 2 full ontology or simply ontology unless there is any risk of confusion will be used interchangeably with the term rdf graph 2.2 content of ontologies informative while there do not exist any syntactic restrictions on the set of rdf graphs that can be interpreted by the owl 2 rdf-based semantics in practice an ontology will often contain certain kinds of constructs that are aimed to support ontology management tasks. examples are ontology headers and ontology iris as well as constructs that are about versioning importing and annotating of ontologies including the concept of incompatibility between ontologies. these topics are outside the scope of this semantics specification. section 3 of the owl 2 structural specification owl 2 specification deals with these topics in detail and can therefore be used as a guide on how to apply these constructs in owl 2 full ontologies accordingly. the mappings of all these constructs to their respective rdf encoding are defined in the owl 2 rdf mapping owl 2 rdf mapping 3 vocabulary this section specifies the owl 2 rdf-based vocabulary and lists the names of the datatypes and facets used under the owl 2 rdf-based semantics. 3.1 standard prefixes table 3.1 lists the standard prefix names and their prefix iris used in this document. table 3.1 standard prefixes prefix name prefix iri owl owl http www.w3.org 2002 07 owl# rdf rdf http www.w3.org 1999 02 22-rdf-syntax-ns# rdfs rdfs http www.w3.org 2000 01 rdf-schema# xml schema xsd http www.w3.org 2001 xmlschema# 3.2 vocabulary terms table 3.2 lists the iris of the owl 2 rdf-based vocabulary which is the set of vocabulary terms that are specific for the owl 2 rdf-based semantics. this vocabulary extends the rdf and rdfs vocabularies as specified in sections 3.1 and 4.1 of the rdf semantics rdf semantics respectively. table 3.2 does not mention those iris that will be listed in section 3.3 on datatype names or section 3.4 on facet names. implementations are not required to support the iri owl onproperties but may support it in order to realize n-ary dataranges with arity 2 see sections 7 and 8.4 of the owl 2 structural specification owl 2 specification for further information note the use of the iri owl datarange has been deprecated as of owl 2. the iri rdfs datatype should be used instead. table 3.2 owl 2 rdf-based vocabulary owl alldifferent owl alldisjointclasses owl alldisjointproperties owl allvaluesfrom owl annotatedproperty owl annotatedsource owl annotatedtarget owl annotation owl annotationproperty owl assertionproperty owl asymmetricproperty owl axiom owl backwardcompatiblewith owl bottomdataproperty owl bottomobjectproperty owl cardinality owl class owl complementof owl datarange owl datatypecomplementof owl datatypeproperty owl deprecated owl deprecatedclass owl deprecatedproperty owl differentfrom owl disjointunionof owl disjointwith owl distinctmembers owl equivalentclass owl equivalentproperty owl functionalproperty owl haskey owl hasself owl hasvalue owl imports owl incompatiblewith owl intersectionof owl inversefunctionalproperty owl inverseof owl irreflexiveproperty owl maxcardinality owl maxqualifiedcardinality owl members owl mincardinality owl minqualifiedcardinality owl namedindividual owl negativepropertyassertion owl nothing owl objectproperty owl onclass owl ondatarange owl ondatatype owl oneof owl onproperty owl onproperties owl ontology owl ontologyproperty owl priorversion owl propertychainaxiom owl propertydisjointwith owl qualifiedcardinality owl reflexiveproperty owl restriction owl sameas owl somevaluesfrom owl sourceindividual owl symmetricproperty owl targetindividual owl targetvalue owl thing owl topdataproperty owl topobjectproperty owl transitiveproperty owl unionof owl versioninfo owl versioniri owl withrestrictions 3.3 datatype names table 3.3 lists the iris of the datatypes used in the owl 2 rdf-based semantics. the datatype rdf xmlliteral is described in section 3.1 of the rdf semantics rdf semantics all other datatypes are described in section 4 of the owl 2 structural specification owl 2 specification the normative set of datatypes of the owl 2 rdf-based semantics equals the set of datatypes described in section 4 of the owl 2 structural specification owl 2 specification table 3.3 datatypes of the owl 2 rdf-based semantics xsd anyuri xsd base64binary xsd boolean xsd byte xsd datetime xsd datetimestamp xsd decimal xsd double xsd float xsd hexbinary xsd int xsd integer xsd language xsd long xsd name xsd ncname xsd negativeinteger xsd nmtoken xsd nonnegativeinteger xsd nonpositiveinteger xsd normalizedstring rdf plainliteral xsd positiveinteger owl rational owl real xsd short xsd string xsd token xsd unsignedbyte xsd unsignedint xsd unsignedlong xsd unsignedshort rdf xmlliteral 3.4 facet names table 3.4 lists the iris of the facets used in the owl 2 rdf-based semantics. each datatype listed in section 3.3 has a possibly empty set of constraining facets. all facets are described in section 4 of the owl 2 structural specification owl 2 specification in the context of their respective datatypes. the normative set of facets of the owl 2 rdf-based semantics equals the set of facets described in section 4 of the owl 2 structural specification owl 2 specification in this specification facets are used for defining datatype restrictions see section 5.7 for example to refer to the set of all strings of length 5 one can restrict the datatype xsd string section 3.3 by the facet xsd length and the value 5. table 3.4 facets of the owl 2 rdf-based semantics rdf langrange xsd length xsd maxexclusive xsd maxinclusive xsd maxlength xsd minexclusive xsd mininclusive xsd minlength xsd pattern 4 interpretations the owl 2 rdf-based semantics provides vocabulary interpretations and vocabulary entailment see section 2.1 of the rdf semantics rdf semantics for the rdf and rdfs vocabularies and for the owl 2 rdf-based vocabulary. this section defines owl 2 rdf-based datatype maps and owl 2 rdf-based interpretations and specifies what satisfaction of ontologies consistency and entailment means under the owl 2 rdf-based semantics. in addition the so called parts of the universe of an owl 2 rdf-based interpretation are defined. 4.1 datatype maps according to section 5.1 of the rdf semantics specification rdf semantics a datatype d has the following components ls d the lexical space of d which is a set of lexical forms vs d the value space of d which is a set of data values l2v d the lexical-to-value mapping of d which maps lexical forms in ls d to data values in vs d terminological notes the document at hand uses the term data value in accordance with the rest of the owl 2 specification see section 4 of the owl 2 structural specification owl 2 specification whereas the rdf semantics specification rdf semantics uses the term datatype value instead. further the names ls and vs which stand for the lexical space and the value space of a datatype respectively are not used in the rdf semantics specification but have been introduced here for easier reference. in this document the basic definition of a datatype is extended to take facets into account. see section 3.4 for information and an example on facets. note that section 5.1 of the rdf semantics specification rdf semantics explicitly permits that semantic extensions may impose more elaborate datatyping conditions than those listed above. a datatype with facets d is a datatype that has the following additional components fs d the facet space of d which is a set of pairs of the form f v where f is an iri called the constraining facet and v is an arbitrary data value called the constraining value f2v d the facet-to-value mapping of d which maps each facet-value pair f v in fs d to a subset of vs d note that it is not further specified what the nature of the denotation of a facet iri is i.e. it is only known that a facet iri denotes some individual. semantic extensions may impose further restrictions on the denotations of facets. in fact section 5.3 will define additional restrictions on facets. also note that for a datatype d and a facet-value pair f v in fs d the value v is not required to be included in the value space vs d of d itself. for example the datatype xsd string section 3.3 has the facet xsd length section 3.4 which takes nonnegative integers as its constraining values rather than strings. in this document it will always be assumed from now on that any datatype d is a datatype with facets. if the facet space fs d of a datatype d has not been explicitly defined or if it is not derived from another datatype s facet space according to some well defined condition then fs d is the empty set. unless there is any risk of confusion the term datatype will always refer to a datatype with facets. section 5.1 of the rdf semantics specification rdf semantics further defines a datatype map d to be a set of name-datatype pairs u d consisting of an iri u and a datatype d such that no iri appears twice in the set. as a consequence of what has been said before in this document every datatype map d will entirely consist of datatypes with facets. the following definition specifies what an owl 2 rdf-based datatype map is. definition 4.1 owl 2 rdf-based datatype map a datatype map d is an owl 2 rdf-based datatype map if and only if for every datatype name u listed in section 3.3 and its respective set of constraining facets section 3.4 there is a name-datatype pair u d in d with the specified lexical space ls d value space vs d lexical-to-value mapping l2v d facet space fs d and facet-to-value mapping f2v d note that definition 4.1 does not prevent additional datatypes to be in an owl 2 rdf-based datatype map. for the special case of an owl 2 rdf-based datatype map d that exclusively contains the datatypes listed in section 3.3 it is ensured that there are datatypes available for all the facet values i.e. for every name-datatype pair u d in d and for every facet-value pair f v in fs d there exists a name-datatype pair u d in d such that v is in vs d 4.2 vocabulary interpretations from the rdf semantics specification rdf semantics let v be a set of literals and iris containing the rdf and rdfs vocabularies and let d be a datatype map according to section 5.1 of the rdf semantics rdf semantics and accordingly section 4.1 a d-interpretation i of v with respect to d is a tuple i ir ip iext is il lv ir is the universe of i i.e. a nonempty set that contains at least the denotations of literals and iris in v. ip is a subset of ir the properties of i. lv the data values of i is a subset of ir that contains at least the set of plain literals see section 6.5 of rdf concepts rdf concepts in v and the value spaces of each datatype of d. iext is used to associate properties with their property extension and is a mapping from ip to the powerset of ir ir. is is a mapping from iris in v to their denotations in ir. in particular is u d for any name-datatype pair u d in d. il is a mapping from typed literals s u in v to their denotations in ir where il s u l2v d s provided that d is a datatype of d is u d and s is in the lexical space ls d otherwise il s u is not in lv. convention following the practice introduced in section 1.4 of the rdf semantics rdf semantics for a given interpretation i of a vocabulary v the notation i x will be used instead of il x and is x for the typed literals and iris x in v respectively. as detailed in the rdf semantics rdf semantics a d-interpretation has to meet all the semantic conditions for ground graphs and blank nodes those for rdf interpretations and rdfs interpretations and the general semantic conditions for datatypes in this document the basic definition of a d-interpretation is extended to take facets into account. a d-interpretation with facets i is a d-interpretation for a datatype map d consisting entirely of datatypes with facets section 4.1 where i meets the following additional semantic conditions for each name-datatype pair u d in d and each facet-value pair f v in the facet space fs d f is in the vocabulary v of i a name-datatype pair u d exists in d such that v is in the value space vs d in this document it will always be assumed from now on that any d-interpretation i is a d-interpretation with facets. unless there is any risk of confusion the term d-interpretation will always refer to a d-interpretation with facets. the following definition specifies what an owl 2 rdf-based interpretation is. definition 4.2 owl 2 rdf-based interpretation let d be an owl 2 rdf-based datatype map and let v be a vocabulary that includes the rdf and rdfs vocabularies and the owl 2 rdf-based vocabulary together with all the datatype and facet names listed in section 3. an owl 2 rdf-based interpretation i ir ip iext is il lv of v with respect to d is a d-interpretation of v with respect to d that meets all the extra semantic conditions given in section 5. 4.3 satisfaction consistency and entailment the following definitions specify what it means for an rdf graph to be satisfied by a given owl 2 rdf-based interpretation to be consistent under the owl 2 rdf-based semantics and to entail another rdf graph. the notion of satisfaction under the owl 2 rdf-based semantics is based on the notion of satisfaction for d-interpretations and simple interpretations as defined in the rdf semantics rdf semantics in essence in order to satisfy an rdf graph an interpretation i has to satisfy all the triples in the graph i.e. for a triple s p o it is necessary that the relationship i s i o iext i p holds special treatment exists for blank nodes as detailed in section 1.5 of the rdf semantics rdf semantics in other words the given graph has to be compatible with the specific form of the iext mapping of i. the distinguishing aspect of owl 2 rdf-based satisfaction is that an interpretation i needs to meet all the owl 2 rdf-based semantic conditions see section 5 which have a constraining effect on the possible forms an iext mapping can have. definition 4.3 owl 2 rdf-based satisfaction let g be an rdf graph let d be an owl 2 rdf-based datatype map let v be a vocabulary that includes the rdf and rdfs vocabularies and the owl 2 rdf-based vocabulary together with all the datatype and facet names listed in section 3 and let i be a d-interpretation of v with respect to d. i owl 2 rdf-based satisfies g with respect to v and d if and only if i is an owl 2 rdf-based interpretation of v with respect to d that satisfies g as a d-interpretation of v with respect to d according to the rdf semantics rdf semantics definition 4.4 owl 2 rdf-based consistency let s be a collection of rdf graphs and let d be an owl 2 rdf-based datatype map. s is owl 2 rdf-based consistent with respect to d if and only if there is some owl 2 rdf-based interpretation i with respect to d of some vocabulary v that includes the rdf and rdfs vocabularies and the owl 2 rdf-based vocabulary together with all the datatype and facet names listed in section 3 such that i owl 2 rdf-based satisfies all the rdf graphs in s with respect to v and d. definition 4.5 owl 2 rdf-based entailment let s1 and s2 be collections of rdf graphs and let d be an owl 2 rdf-based datatype map. s1 owl 2 rdf-based entails s2 with respect to d if and only if for every owl 2 rdf-based interpretation i with respect to d of any vocabulary v that includes the rdf and rdfs vocabularies and the owl 2 rdf-based vocabulary together with all the datatype and facet names listed in section 3 the following holds if i owl 2 rdf-based satisfies all the rdf graphs in s1 with respect to v and d then i owl 2 rdf-based satisfies all the rdf graphs in s2 with respect to v and d. 4.4 parts of the universe table 4.1 defines the parts of the universe of a given owl 2 rdf-based interpretation i. the second column tells the name of the part. the third column gives a definition of the part in terms of the mapping iext of i and by referring to a particular term of the rdf rdfs or owl 2 rdf-based vocabulary. as an example the part of all datatypes is named idc and it is defined as the set of all individuals x for which the relationship x i rdfs datatype iext i rdf type holds. according to the semantics of rdf type as defined in section 4.1 of the rdf semantics rdf semantics this means that the name idc denotes the class extension see section 4.5 of i rdfs datatype table 4.1 parts of the universe name of part s definition of s as x ir x i e iext i rdf type where iri e is individuals ir rdfs resource data values lv rdfs literal ontologies ix owl ontology classes ic rdfs class datatypes idc rdfs datatype properties ip rdf property data properties iodp owl datatypeproperty ontology properties ioxp owl ontologyproperty annotation properties ioap owl annotationproperty 4.5 class extensions the mapping icext from ic to the powerset of ir which associates classes with their class extension is defined for every c ic as icext c x ir x c iext i rdf type 5 semantic conditions this section defines the semantic conditions of the owl 2 rdf-based semantics. the semantic conditions presented here are basically only those for the specific constructs of owl 2. the complete set of semantic conditions for the owl 2 rdf-based semantics is the combination of the semantic conditions presented here and the semantic conditions for simple entailment rdf rdfs and d-entailment as specified in the rdf semantics specification rdf semantics all semantic conditions in this section are defined with respect to an interpretation i. section 5.1 specifies semantic conditions for the different parts of the universe of the interpretation being considered compare section 4.4 section 5.2 and section 5.3 list semantic conditions for the classes and the properties of the owl 2 rdf-based vocabulary. in the rest of this section the owl 2 rdf-based semantic conditions for the different language constructs of owl 2 are specified. conventions used in this section iff throughout this section the term iff is used as a shortform for if and only if conjunctive commas a comma separating two assertions in a semantic condition as in c ic p ip is read as a logical and further a comma separating two variables as in c d ic is used for abbreviating two comma separated assertions c ic d ic in this example. unscoped variables if no explicit scope is given for a variable x as in x or x then x is unconstrained which means x ir i.e. x denotes an arbitrary individual in the universe. set cardinality for a set s an expression of the form s means the number of elements in s. sequence expressions an expression of the form s sequence of a1 an s means that s represents an rdf list of n 0 individuals a1 an all of them being members of the set s. precisely s i rdf nil for n 0 and for n 0 there exist z1 ir zn ir such that s z1 a1 s z1 a1 iext i rdf first z1 z2 iext i rdf rest an s zn an iext i rdf first zn i rdf nil iext i rdf rest note as mentioned in section 3.3.3 of the rdf semantics rdf semantics there are no semantic constraints that enforce well-formed sequence structures. so for example it is possible for a sequence head s to refer to more than one sequence. set names the following names are used as convenient abbreviations for certain sets iseq the set of all sequences. this set equals the class extension of rdf list i.e. iseq icext i rdf list inni the set of all nonnegative integers. this set equals the value space of the datatype xsd nonnegativeinteger i.e. inni icext i xsd nonnegativeinteger but is also subsumed by the value spaces of other numerical datatypes such as xsd integer. notes on the form of semantic conditions informative one design goal of owl 2 was to ensure an appropriate degree of alignment between the owl 2 rdf-based semantics and the owl 2 direct semantics owl 2 direct semantics under the different constraints the two semantics have to meet. the way this semantic alignment is described is via the owl 2 correspondence theorem in section 7.2. for this theorem to hold the semantic conditions that treat the rdf encoding of owl 2 axioms compare section 3.2.5 of the owl 2 rdf mapping owl 2 rdf mapping and section 9 of the owl 2 structural specification owl 2 specification such as inverse property axioms must have the form of iff if-and-only-if conditions. this means that these semantic conditions completely determine the semantics of the encoding of these constructs. on the other hand the rdf encoding of owl 2 expressions compare section 3.2.4 of the owl 2 rdf mapping owl 2 rdf mapping and sections 6 8 of the owl 2 structural specification owl 2 specification such as property restrictions are treated by if-then conditions. these weaker semantic conditions for expressions are sufficient for the correspondence theorem to hold so there is no necessity to define stronger iff conditions under the owl 2 rdf-based semantics for these language constructs. special cases are the semantic conditions for boolean connectives of classes and for enumerations. these language constructs build owl 2 expressions. but for backward compatibility reasons there is also rdf encoding of axioms based on the vocabulary for these language constructs see table 18 in section 3.2.5 of the owl 2 rdf mapping owl 2 rdf mapping for example an rdf expression of the form ex c1 owl unionof ex c2 ex c3 is mapped by the reverse rdf mapping to an owl 2 axiom that states the equivalence of the class denoted by ex c1 with the union of the classes denoted by ex c2 and ex c3. in order to ensure that the correspondence theorem holds and in accordance with the original owl 1 rdf-compatible semantics specification owl 1 rdf-compatible semantics the semantic conditions for the mentioned language constructs are therefore iff conditions. further special treatment exists for owl 2 axioms that have a multi-triple representation in rdf where the different triples share a common root node such as the blank node x in the following example x rdf type owl alldisjointclasses x owl members ex c1 ex c2 in essence the semantic conditions for the encoding of these language constructs are iff conditions as usual for axioms. however in order to cope with the specific syntactic aspect of a root node the iff conditions of these language constructs have been split into two if-then conditions where the if-then condition representing the right-to-left direction contains an additional premise having the form z ir the purpose of this premise is to ensure the existence of an individual that is needed to satisfy the root node under the owl 2 rdf-based semantics. the language constructs in question are n-ary disjointness axioms in section 5.10 and negative property assertions in section 5.15. the if-then semantic conditions in this section sometimes do not explicitly list all typing statements in their consequent that one might expect. for example the semantic condition for owl somevaluesfrom restrictions in section 5.6 does not list the statement x icext i owl restriction on its right hand side. consequences are generally not mentioned if they can already be deduced by other means. often these redundant consequences follow from the semantic conditions for vocabulary classes and vocabulary properties in section 5.2 and section 5.3 respectively occasionally in connection with the semantic conditions for the parts of the universe in section 5.1. in the example above the omitted consequence can be obtained from the third column of the entry for owl somevaluesfrom in the table in section 5.3 which determines that iext i owl somevaluesfrom icext i owl restriction ic. 5.1 semantic conditions for the parts of the universe table 5.1 lists the semantic conditions for the parts of the universe of the owl 2 rdf-based interpretation being considered. additional semantic conditions affecting these parts are given in section 5.2. the first column tells the name of the part as defined in section 4.4. the second column defines certain conditions on the part. in most cases the column specifies for the part by which other part it is subsumed and thus the position of the part in the parts hierarchy of the universe is narrowed down. the third column provides further information about the instances of those parts that consist of classes or properties. in general if the part consists of classes then for the class extensions of the member classes is specified by which part of the universe they are subsumed. if the part consists of properties then the domains and ranges of the member properties are determined. table 5.1 semantic conditions for the parts of the universe name of part s conditions on s conditions on instances x of s ir s lv s ir ix s ir ic s ir icext x ir idc s ic icext x lv ip s ir iext x ir ir iodp s ip iext x ir lv ioxp s ip iext x ix ix ioap s ip iext x ir ir 5.2 semantic conditions for the vocabulary classes table 5.2 lists the semantic conditions for the classes that have iris in the owl 2 rdf-based vocabulary. in addition the table contains all those classes with iris in the rdf and rdfs vocabularies that represent parts of the universe of the owl 2 rdf-based interpretation being considered section 4.4 the semantic conditions for the remaining classes with names in the rdf and rdfs vocabularies can be found in the rdf semantics specification rdf semantics the first column tells the iri of the class. the second column defines of what particular kind a class is i.e. whether it is a general class a member of the part ic or a datatype a member of idc the third column specifies for the class extension of the class by which part of the universe section 4.4 it is subsumed from an entry of the form icext i c s for a class iri c and a set s and given an rdf triple of the form u rdf type c one can deduce that the relationship i u s holds. note that some entries are of the form icext i c s which means that the class extension is exactly specified to be that set. see section 5.1 for further semantic conditions on those classes that represent parts. not included in this table are the datatypes of the owl 2 rdf-based semantics with iris listed in section 3.3. for each such datatype iri e the following semantic conditions hold as a consequence of the fact that e is a member of the datatype map of every owl 2 rdf-based interpretation according to definition 4.2 and by the general semantic conditions for datatypes listed in section 5.1 of the rdf semantics rdf semantics i e idc icext i e lv table 5.2 semantic conditions for the vocabulary classes iri e i e icext i e owl alldifferent ic ir owl alldisjointclasses ic ir owl alldisjointproperties ic ir owl annotation ic ir owl annotationproperty ic ioap owl asymmetricproperty ic ip owl axiom ic ir rdfs class ic ic owl class ic ic owl datarange ic idc rdfs datatype ic idc owl datatypeproperty ic iodp owl deprecatedclass ic ic owl deprecatedproperty ic ip owl functionalproperty ic ip owl inversefunctionalproperty ic ip owl irreflexiveproperty ic ip rdfs literal idc lv owl namedindividual ic ir owl negativepropertyassertion ic ir owl nothing ic owl objectproperty ic ip owl ontology ic ix owl ontologyproperty ic ioxp rdf property ic ip owl reflexiveproperty ic ip rdfs resource ic ir owl restriction ic ic owl symmetricproperty ic ip owl thing ic ir owl transitiveproperty ic ip 5.3 semantic conditions for the vocabulary properties table 5.3 lists the semantic conditions for the properties that have iris in the owl 2 rdf-based vocabulary. in addition the table contains all those properties with iris in the rdfs vocabulary that are specified to be annotation properties under the owl 2 rdf-based semantics. the semantic conditions for the remaining properties with names in the rdf and rdfs vocabularies can be found in the rdf semantics specification rdf semantics the first column tells the iri of the property. the second column defines of what particular kind a property is i.e. whether it is a general property a member of the part ip a datatype property a member of iodp an ontology property a member of ioxp or an annotation property a member of ioap the third column specifies the domain and range of the property from an entry of the form iext i p s1 s2 for a property iri p and sets s1 and s2 and given an rdf triple s p o one can deduce the relationships i s s1 and i o s2 note that some entries are of the form iext i p s1 s2 which means that the property extension is exactly specified to be the cartesian product of the two sets. not included in this table are the facets of the owl 2 rdf-based semantics with iris listed in section 3.4 which are used to specify datatype restrictions see section 5.7 for each such facet iri e the following semantic conditions extend the basic semantics specification that has been given for datatypes with facets in section 4.1 i e iodp iext i e ir lv implementations are not required to support the semantic condition for owl onproperties but may support it in order to realize n-ary dataranges with arity 2 see sections 7 and 8.4 of the owl 2 structural specification owl 2 specification for further information informative notes owl topobjectproperty relates every two individuals in the universe with each other. likewise owl topdataproperty relates every individual with every data value. further owl bottomobjectproperty and owl bottomdataproperty stand both for the empty relationship. the ranges of the properties owl deprecated and owl hasself are not restricted in any form and in particular they are not restricted to boolean values. the actual object values of these properties do not have any intended meaning but could as well have been defined to be of any other value. therefore the semantics given here are of a form that the values can be arbitrarily chosen without leading to any nontrivial semantic conclusions. it is however recommended to still use an object literal of the form true xsd boolean in ontologies in order to not get in conflict with the required usage of these properties in scenarios that ask for applying the reverse rdf mapping compare table 13 in section 3.2.4 of the owl 2 rdf mapping owl 2 rdf mapping for owl hasself and section 5.5 of the owl 2 structural specification owl 2 specification for owl deprecated the range of the property owl annotatedproperty is unrestricted i.e. it is not specified as the set of properties. annotations are meant to be semantically weak i.e. their formal meaning should not significantly exceed that originating from the rdf semantics specification. several properties such as owl priorversion have been specified as both ontology properties and annotation properties in order to be in line with both the original owl 1 rdf-compatible semantics specification owl 1 rdf-compatible semantics and the rest of the owl 2 specification see section 5.5 of the owl 2 structural specification owl 2 specification table 5.3 semantic conditions for the vocabulary properties iri e i e iext i e owl allvaluesfrom ip icext i owl restriction ic owl annotatedproperty ip ir ir owl annotatedsource ip ir ir owl annotatedtarget ip ir ir owl assertionproperty ip icext i owl negativepropertyassertion ip owl backwardcompatiblewith ioxp ioap ix ix owl bottomdataproperty iodp owl bottomobjectproperty ip owl cardinality ip icext i owl restriction inni rdfs comment ioap ir lv owl complementof ip ic ic owl datatypecomplementof ip idc idc owl deprecated ioap ir ir owl differentfrom ip ir ir owl disjointunionof ip ic iseq owl disjointwith ip ic ic owl distinctmembers ip icext i owl alldifferent iseq owl equivalentclass ip ic ic owl equivalentproperty ip ip ip owl haskey ip ic iseq owl hasself ip icext i owl restriction ir owl hasvalue ip icext i owl restriction ir owl imports ioxp ix ix owl incompatiblewith ioxp ioap ix ix owl intersectionof ip ic iseq owl inverseof ip ip ip rdfs isdefinedby ioap ir ir rdfs label ioap ir lv owl maxcardinality ip icext i owl restriction inni owl maxqualifiedcardinality ip icext i owl restriction inni owl members ip ir iseq owl mincardinality ip icext i owl restriction inni owl minqualifiedcardinality ip icext i owl restriction inni owl onclass ip icext i owl restriction ic owl ondatarange ip icext i owl restriction idc owl ondatatype ip idc idc owl oneof ip ic iseq owl onproperty ip icext i owl restriction ip owl onproperties ip icext i owl restriction iseq owl priorversion ioxp ioap ix ix owl propertychainaxiom ip ip iseq owl propertydisjointwith ip ip ip owl qualifiedcardinality ip icext i owl restriction inni owl sameas ip ir ir rdfs seealso ioap ir ir owl somevaluesfrom ip icext i owl restriction ic owl sourceindividual ip icext i owl negativepropertyassertion ir owl targetindividual ip icext i owl negativepropertyassertion ir owl targetvalue ip icext i owl negativepropertyassertion lv owl topdataproperty iodp ir lv owl topobjectproperty ip ir ir owl unionof ip ic iseq owl versioninfo ioap ir ir owl versioniri ioxp ix ix owl withrestrictions ip idc iseq 5.4 semantic conditions for boolean connectives table 5.4 lists the semantic conditions for boolean connectives including intersections unions and complements of classes and datatypes. an intersection or a union of a collection of datatypes or a complement of a datatype is itself a datatype. while a complement of a class is created w.r.t. the whole universe a datatype complement is created for a datatype w.r.t. the set of data values only. informative notes of the three pairs of semantic conditions in the table every first is an iff condition since the corresponding owl 2 language constructs are both class expressions and axioms. in contrast the semantic condition on datatype complements is an if-then condition since it only corresponds to a datarange expression. see the notes on the form of semantic conditions for further information. for the remaining semantic conditions that treat the cases of intersections and unions of datatypes it is sufficient to have if-then conditions since stronger iff conditions would be redundant due to the more general iff conditions that already exist for classes. note that the datatype related semantic conditions do not apply to empty sets but one can still receive a datatype from an empty set by explicitly asserting the resulting class to be an instance of class rdfs datatype. table 5.4 semantic conditions for boolean connectives if s sequence of c1 cn ir then z s iext i owl intersectionof iff z c1 cn ic icext z icext c1 icext cn if then s sequence of d1 dn idc n 1 z s iext i owl intersectionof z idc if s sequence of c1 cn ir then z s iext i owl unionof iff z c1 cn ic icext z icext c1 icext cn if then s sequence of d1 dn idc n 1 z s iext i owl unionof z idc z c iext i owl complementof iff z c ic icext z ir icext c if then z d iext i owl datatypecomplementof icext z lv icext d 5.5 semantic conditions for enumerations table 5.5 lists the semantic conditions for enumerations i.e. classes that consist of an explicitly given finite set of instances. in particular an enumeration entirely consisting of data values is a datatype. informative notes the first semantic condition is an iff condition since the corresponding owl 2 language construct is both a class expression and an axiom. see the notes on the form of semantic conditions for further information. for the remaining semantic condition that treats the case of enumerations of data values it is sufficient to have an if-then condition since a stronger iff condition would be redundant due to the more general iff condition that already exists for individuals. note that the data value related semantic condition does not apply to empty sets but one can still receive a datatype from an empty set by explicitly asserting the resulting class to be an instance of class rdfs datatype. table 5.5 semantic conditions for enumerations if s sequence of a1 an ir then z s iext i owl oneof iff z ic icext z a1 an if then s sequence of v1 vn lv n 1 z s iext i owl oneof z idc 5.6 semantic conditions for property restrictions table 5.6 lists the semantic conditions for property restrictions. value restrictions require that some or all of the values of a certain property must be instances of a given class or data range or that the property has a specifically defined value. by placing a self restriction on some given property one only considers those individuals that are reflexively related to themselves via this property. cardinality restrictions determine how often a certain property is allowed to be applied to a given individual. qualified cardinality restrictions are more specific than cardinality restrictions in that they determine the quantity of a property application with respect to a particular class or data range from which the property values are taken. implementations are not required to support the semantic conditions for owl onproperties but may support them in order to realize n-ary dataranges with arity 2 see sections 7 and 8.4 of the owl 2 structural specification owl 2 specification for further information informative notes all the semantic conditions are if-then conditions since the corresponding owl 2 language constructs are class expressions. the if-then conditions generally only list those consequences on their right hand side that are specific for the respective condition i.e. consequences that do not already follow by other means. see the notes on the form of semantic conditions for further information. note that the semantic condition for self restrictions does not constrain the right hand side of a owl hasself assertion to be the boolean value true xsd boolean. see section 5.3 for an explanation. table 5.6 semantic conditions for property restrictions if then z c iext i owl somevaluesfrom z p iext i owl onproperty icext z x y x y iext p and y icext c s sequence of p1 pn ir n 1 z c iext i owl somevaluesfrom z s iext i owl onproperties p1 pn ip icext z x y1 yn x yk iext pk for each 1 k n and y1 yn icext c z c iext i owl allvaluesfrom z p iext i owl onproperty icext z x y x y iext p implies y icext c s sequence of p1 pn ir n 1 z c iext i owl allvaluesfrom z s iext i owl onproperties p1 pn ip icext z x y1 yn x yk iext pk for each 1 k n implies y1 yn icext c z a iext i owl hasvalue z p iext i owl onproperty icext z x x a iext p z v iext i owl hasself z p iext i owl onproperty icext z x x x iext p z n iext i owl mincardinality z p iext i owl onproperty icext z x y x y iext p n z n iext i owl maxcardinality z p iext i owl onproperty icext z x y x y iext p n z n iext i owl cardinality z p iext i owl onproperty icext z x y x y iext p n z n iext i owl minqualifiedcardinality z p iext i owl onproperty z c iext i owl onclass icext z x y x y iext p and y icext c n z n iext i owl minqualifiedcardinality z p iext i owl onproperty z d iext i owl ondatarange p iodp icext z x y lv x y iext p and y icext d n z n iext i owl maxqualifiedcardinality z p iext i owl onproperty z c iext i owl onclass icext z x y x y iext p and y icext c n z n iext i owl maxqualifiedcardinality z p iext i owl onproperty z d iext i owl ondatarange p iodp icext z x y lv x y iext p and y icext d n z n iext i owl qualifiedcardinality z p iext i owl onproperty z c iext i owl onclass icext z x y x y iext p and y icext c n z n iext i owl qualifiedcardinality z p iext i owl onproperty z d iext i owl ondatarange p iodp icext z x y lv x y iext p and y icext d n 5.7 semantic conditions for datatype restrictions table 5.7 lists the semantic conditions for datatype restrictions which are used to define sub datatypes of existing datatypes by restricting the original datatype by means of a set of facet-value pairs. see section 3.4 for information and an example on constraining facets. certain special cases exist if no facet-value pair is applied to a given datatype then the resulting datatype will be equivalent to the original datatype. further if a facet-value pair is applied to a datatype without being a member of the datatype s facet space then the ontology cannot be satisfied and will therefore be inconsistent. in particular a datatype restriction with one or more specified facet-value pairs will result in an inconsistent ontology if applied to a datatype with an empty facet space. the set ifs is defined by ifs d i f v f v fs d where d is a datatype f is the iri of a constraining facet and v is a constraining value of the facet. this set corresponds to the facet space fs d as defined in section 4.1 but rather consists of pairs of the denotation of a facet and a value. the mapping if2v is defined by if2v d i f v f2v d f v where d is a datatype f is the iri of a constraining facet and v is a constraining value of the facet. this mapping corresponds to the facet-to-value mapping f2v d as defined in section 4.1 resulting in the same subsets of the value space vs d but rather applies to pairs of the denotation of a facet and a value. informative notes the semantic condition is an if-then condition since the corresponding owl 2 language construct is a datarange expression. the if-then condition only lists those consequences on its right hand side that are specific for the condition i.e. consequences that do not already follow by other means. see the notes on the form of semantic conditions for further information. table 5.7 semantic conditions for datatype restrictions if then s sequence of z1 zn ir f1 fn ip z d iext i owl ondatatype z s iext i owl withrestrictions z1 v1 iext f1 zn vn iext fn f1 fn iodp v1 vn lv f1 v1 fn vn ifs d icext z icext d if2v d f1 v1 if2v d fn vn 5.8 semantic conditions for the rdfs vocabulary table 5.8 extends the rdfs semantic conditions for subclass axioms subproperty axioms domain axioms and range axioms. the semantic conditions provided here are iff conditions while the original semantic conditions as specified in section 4.1 of the rdf semantics rdf semantics are weaker if-then conditions. only the additional semantic conditions are given here and the other conditions of rdf and rdfs are retained. informative notes all the semantic conditions are iff conditions since the corresponding owl 2 language constructs are axioms. see the notes on the form of semantic conditions for further information. table 5.8 semantic conditions for the rdfs vocabulary c1 c2 iext i rdfs subclassof iff c1 c2 ic icext c1 icext c2 p1 p2 iext i rdfs subpropertyof p1 p2 ip iext p1 iext p2 p c iext i rdfs domain p ip c ic x y x y iext p implies x icext c p c iext i rdfs range p ip c ic x y x y iext p implies y icext c 5.9 semantic conditions for equivalence and disjointness table 5.9 lists the semantic conditions for specifying that two individuals are equal or different from each other and that either two classes or two properties are equivalent or disjoint with each other respectively. the property owl equivalentclass is also used to formulate datatype definitions see section 9.4 of the owl 2 structural specification owl 2 specification for information about datatype definitions in addition the table treats disjoint union axioms. informative notes all the semantic conditions are iff conditions since the corresponding owl 2 language constructs are axioms. see the notes on the form of semantic conditions for further information. table 5.9 semantic conditions for equivalence and disjointness a1 a2 iext i owl sameas iff a1 a2 a1 a2 iext i owl differentfrom a1 a2 c1 c2 iext i owl equivalentclass c1 c2 ic icext c1 icext c2 c1 c2 iext i owl disjointwith c1 c2 ic icext c1 icext c2 p1 p2 iext i owl equivalentproperty p1 p2 ip iext p1 iext p2 p1 p2 iext i owl propertydisjointwith p1 p2 ip iext p1 iext p2 if s sequence of c1 cn ir then c s iext i owl disjointunionof iff c c1 cn ic icext c icext c1 icext cn icext cj icext ck for each 1 j n and each 1 k n such that j k 5.10 semantic conditions for n-ary disjointness table 5.10 lists the semantic conditions for specifying n-ary diversity and disjointness axioms i.e. that several given individuals are mutually different from each other and that several given classes or properties are mutually disjoint with each other respectively. note that there are two alternative ways to specify owl alldifferent axioms by using either the property owl members that is used for all other constructs too or by applying the legacy property owl distinctmembers. both variants have an equivalent formal meaning. informative notes the semantic conditions essentially represent iff conditions since the corresponding owl 2 language constructs are axioms. however there are actually two semantic conditions for each language construct due to the multi-triple rdf encoding of these language constructs. the if-then conditions only list those consequences on their right hand side that are specific for the respective condition i.e. consequences that do not already follow by other means. see the notes on the form of semantic conditions for further information. table 5.10 semantic conditions for n-ary disjointness if then s sequence of a1 an ir z icext i owl alldifferent z s iext i owl members aj ak for each 1 j n and each 1 k n such that j k if then exists z ir s sequence of a1 an ir aj ak for each 1 j n and each 1 k n such that j k z icext i owl alldifferent z s iext i owl members if then s sequence of a1 an ir z icext i owl alldifferent z s iext i owl distinctmembers aj ak for each 1 j n and each 1 k n such that j k if then exists z ir s sequence of a1 an ir aj ak for each 1 j n and each 1 k n such that j k z icext i owl alldifferent z s iext i owl distinctmembers if then s sequence of c1 cn ir z icext i owl alldisjointclasses z s iext i owl members c1 cn ic icext cj icext ck for each 1 j n and each 1 k n such that j k if then exists z ir s sequence of c1 cn ic icext cj icext ck for each 1 j n and each 1 k n such that j k z icext i owl alldisjointclasses z s iext i owl members if then s sequence of p1 pn ir z icext i owl alldisjointproperties z s iext i owl members p1 pn ip iext pj iext pk for each 1 j n and each 1 k n such that j k if then exists z ir s sequence of p1 pn ip iext pj iext pk for each 1 j n and each 1 k n such that j k z icext i owl alldisjointproperties z s iext i owl members 5.11 semantic conditions for sub property chains table 5.11 lists the semantic conditions for sub property chains which allow for specifying complex property subsumption axioms. as an example one can define a sub property chain axiom that specifies the chain consisting of the property extensions of properties ex hasfather and ex hasbrother to be a sub relation of the extension of the property ex hasuncle. informative notes the semantic condition is an iff condition since the corresponding owl 2 language construct is an axiom. see the notes on the form of semantic conditions for further information. the semantics has been specified in a way such that a sub property chain axiom can be satisfied without requiring the existence of a property that has the property chain as its property extension. table 5.11 semantic conditions for sub property chains if s sequence of p1 pn ir then p s iext i owl propertychainaxiom iff p ip p1 pn ip y0 yn y0 y1 iext p1 and and yn-1 yn iext pn implies y0 yn iext p 5.12 semantic conditions for inverse properties table 5.12 lists the semantic conditions for inverse property axioms. the inverse of a given property is the corresponding property with subject and object swapped for each property assertion built from it. informative notes the semantic condition is an iff condition since the corresponding owl 2 language construct is an axiom. see the notes on the form of semantic conditions for further information. table 5.12 semantic conditions for inverse properties p1 p2 iext i owl inverseof iff p1 p2 ip iext p1 x y y x iext p2 5.13 semantic conditions for property characteristics table 5.13 lists the semantic conditions for property characteristics. if a property is functional then at most one distinct value can be assigned to any given individual via this property. an inverse functional property can be regarded as a key property i.e. no two different individuals can be assigned the same value via this property. a reflexive property relates every individual in the universe to itself whereas an irreflexive property does not relate any individual with itself. if two individuals are related by a symmetric property then this property also relates them reversely while this is never the case for an asymmetric property. a transitive property that relates an individual a with an individual b and the latter with an individual c also relates a with c. informative notes all the semantic conditions are iff conditions since the corresponding owl 2 language constructs are axioms. see the notes on the form of semantic conditions for further information. table 5.13 semantic conditions for property characteristics p icext i owl functionalproperty iff p ip x y1 y2 x y1 iext p and x y2 iext p implies y1 y2 p icext i owl inversefunctionalproperty p ip x1 x2 y x1 y iext p and x2 y iext p implies x1 x2 p icext i owl reflexiveproperty p ip x x x iext p p icext i owl irreflexiveproperty p ip x x x iext p p icext i owl symmetricproperty p ip x y x y iext p implies y x iext p p icext i owl asymmetricproperty p ip x y x y iext p implies y x iext p p icext i owl transitiveproperty p ip x y z x y iext p and y z iext p implies x z iext p 5.14 semantic conditions for keys table 5.14 lists the semantic conditions for keys. keys provide an alternative to inverse functional properties see section 5.13 they allow for defining a property as a key local to a given class the specified property will have the features of a key only for individuals being instances of the class and no assumption is made about individuals for which membership of the class cannot be entailed. further it is possible to define compound keys i.e. several properties can be combined into a single key applicable to composite values. note that keys are not functional by default under the owl 2 rdf-based semantics. informative notes the semantic condition is an iff condition since the corresponding owl 2 language construct is an axiom. see the notes on the form of semantic conditions for further information. table 5.14 semantic conditions for keys if s sequence of p1 pn ir then c s iext i owl haskey iff c ic p1 pn ip x y z1 zn if x icext c and y icext c and x zk iext pk and y zk iext pk for each 1 k n then x y 5.15 semantic conditions for negative property assertions table 5.15 lists the semantic conditions for negative property assertions. they allow to state that two given individuals are not related by a given property. the second form based on owl targetvalue is more specific than the first form based on owl targetindividual in that the second form is restricted to the case of negative data property assertions. note that the second form will coerce the target value of a negative property assertion into a data value due to the range defined for the property owl targetvalue in section 5.3. informative notes the semantic conditions essentially represent iff conditions since the corresponding owl 2 language constructs are axioms. however there are actually two semantic conditions for each language construct due to the multi-triple rdf encoding of these language constructs. the if-then conditions only list those consequences on their right hand side that are specific for the respective condition i.e. consequences that do not already follow by other means. see the notes on the form of semantic conditions for further information. table 5.15 semantic conditions for negative property assertions if then z a1 iext i owl sourceindividual z p iext i owl assertionproperty z a2 iext i owl targetindividual a1 a2 iext p if then exists z ir a1 ir p ip a2 ir a1 a2 iext p z a1 iext i owl sourceindividual z p iext i owl assertionproperty z a2 iext i owl targetindividual if then z a iext i owl sourceindividual z p iext i owl assertionproperty z v iext i owl targetvalue p iodp a v iext p if then exists z ir a ir p iodp v lv a v iext p z a iext i owl sourceindividual z p iext i owl assertionproperty z v iext i owl targetvalue 6 appendix axiomatic triples informative the rdf semantics specification rdf semantics defines so called axiomatic triples as part of the semantics of rdf and rdfs. unlike the rdf semantics the owl 2 rdf-based semantics does not normatively specify any axiomatic triples since one cannot expect to find a set of rdf triples that fully captures all axiomatic aspects of the owl 2 rdf-based semantics. furthermore axiomatic triples for the owl 2 rdf-based semantics could in principle contain arbitrarily complex class expressions e.g. the union of several classes and by this it becomes nonobvious which of several possible nonequivalent sets of axiomatic triples should be selected. however the owl 2 rdf-based semantics includes many semantic conditions that can in a sense be regarded as being axiomatic and thus can be considered a replacement for the missing axiomatic triples. after an overview on axiomatic triples for rdf and rdfs in section 6.1 sections 6.2 and 6.3 will discuss how the axiomatic semantic conditions of the owl 2 rdf-based semantics relate to axiomatic triples. based on this discussion an explicit example set of axiomatic triples that is compatible with the owl 2 rdf-based semantics will be provided in section 6.4. 6.1 axiomatic triples in rdf in rdf and rdfs rdf semantics axiomatic triples are used to provide basic meaning for all the vocabulary terms of the two languages. this formal meaning is independent of any given rdf graph and it even holds for vocabulary terms which do not occur in a graph that is interpreted by an rdf or rdfs interpretation. as a consequence all the axiomatic triples of rdf and rdfs are entailed by the empty graph when being interpreted under the semantics of rdf or rdfs respectively. examples of rdf and rdfs axiomatic triples are 1 rdf type rdf type rdf property 2 rdf type rdfs domain rdfs resource 3 rdf type rdfs range rdfs class 4 rdfs datatype rdfs subclassof rdfs class 5 rdfs isdefinedby rdfs subpropertyof rdfs seealso as shown by these examples axiomatic triples are typically used by the rdf semantics specification to determine the part of the universe to which the denotation of a vocabulary term belongs 1 in the case of a property the domain 2 and range 3 is specified as well. also in some cases hierarchical relationships between classes 4 or properties 5 of the vocabulary are determined. under the owl 2 rdf-based semantics all the axiomatic triples of rdf and rdfs could in principle be replaced by axiomatic semantic conditions that have neither premises nor bound variables. by applying the rdfs semantic conditions given in section 5.8 the example axiomatic triples 1 5 can be equivalently restated as i rdf type icext i rdf property iext i rdf type icext i rdfs resource icext i rdfs class icext i rdfs datatype icext i rdfs class iext i rdfs isdefinedby iext i rdfs seealso all the axiomatic triples of rdf and rdfs can be considered simple in the sense that they have in their object position only single terms from the rdf and rdfs vocabularies and no complex class or property expressions appear there. 6.2 axiomatic triples for the vocabulary classes the semantic conditions for vocabulary classes in section 5.2 can be considered as corresponding to a set of axiomatic triples for the classes in the vocabulary of the owl 2 rdf-based semantics. first for each iri e occurring in the first column of table 5.2 if the second column contains an entry of the form i e s for some set s then this entry corresponds to an rdf triple of the form e rdf type c where c is the iri of a vocabulary class with icext i c s. in the table s will always be either the part ic of all classes or some sub part of ic. hence in a corresponding rdf triple the iri c will be one of rdfs class owl class s ic in both cases or rdfs datatype s idc for example for the iri owl functionalproperty the semantic condition i owl functionalproperty ic has the corresponding axiomatic triple owl functionalproperty rdf type rdfs class further for each iri e in the first column of the table if the third column contains an entry of the form icext i e s or icext i e s for some set s then this entry corresponds to an rdf triple of the form e rdfs subclassof c or additionally c rdfs subclassof e where c is the iri of a vocabulary class with icext i c s. in each case s will be one of the parts of the universe of i. for example the semantic condition icext i owl functionalproperty ip has the corresponding axiomatic triple owl functionalproperty rdfs subclassof rdf property in addition the semantic conditions for the parts of the universe in table 5.1 of section 5.1 have to be taken into account. in particular if an entry in the second column of table 5.1 is of the form s1 s2 for some sets s1 and s2 then this corresponds to an rdf triple of the form c1 owl subclassof c2 where c1 and c2 are the iris of vocabulary classes with icext i c1 s1 and icext i c2 s2 respectively according to section 5.2. section 5.2 also specifies semantic conditions for all the datatypes of the owl 2 rdf-based semantics as listed in section 3.3. for each datatype iri e such as e xsd string for the semantic conditions i e idc and icext i e lv the corresponding axiomatic triples are of the form e rdf type rdfs datatype e rdfs subclassof rdfs literal in analogy to section 6.1 for the rdf axiomatic triples all the axiomatic triples for the vocabulary classes including datatypes can be considered simple in the sense that they will have in their object position only single terms from the rdf rdfs and owl 2 rdf-based vocabularies section 3.2 note that some of the axiomatic triples obtained in this way already follow from the semantics of rdf and rdfs as defined in the rdf semantics rdf semantics 6.3 axiomatic triples for the vocabulary properties the semantic conditions for vocabulary properties in section 5.3 can be considered as corresponding to a set of axiomatic triples for the properties in the vocabulary of the owl 2 rdf-based semantics. first for each iri e occurring in the first column of table 5.3 if the second column contains an entry of the form i e s for some set s then this entry corresponds to an rdf triple of the form e rdf type c where c is the iri of a vocabulary class with icext i c s. in the table s will always be either the part ip of all properties or some sub part of ip. hence in a corresponding rdf triple the iri c will be one of rdf property owl objectproperty s ip in both cases owl datatypeproperty s iodp owl ontologyproperty s ioxp or owl annotationproperty s ioap for example for the iri owl disjointwith the semantic condition i owl disjointwith ip has the corresponding axiomatic triple owl disjointwith rdf type rdf property further for each iri e in the first column of the table if the third column contains an entry of the form iext i e s1 s2 for some sets s1 and s2 then this entry corresponds to rdf triples of the form e rdfs domain c1 and e rdfs range c2 where c1 and c2 are the iris of vocabulary classes with icext i c1 s1 and icext i c2 s2 respectively. note that the sets s1 and s2 do not always correspond to any of the parts of the universe of i. for example the semantic condition iext i owl disjointwith ic ic has the corresponding axiomatic triples owl disjointwith rdfs domain owl class owl disjointwith rdfs range owl class exceptions are the semantic conditions iext i owl topobjectproperty ir ir and iext i owl topdataproperty ir lv since the exactly specified property extensions of these properties cannot be expressed solely by domain and range axiomatic triples. for example the domain and range axiomatic triples for owl sameas are equal to those for owl topobjectproperty but the property extension of owl sameas is different from the property extension of owl topobjectproperty. section 5.3 also specifies semantic conditions for all the facets of the owl 2 rdf-based semantics as listed in section 3.4. for each facet iri e such as e xsd length for the semantic conditions i e iodp and iext i e ir lv the corresponding axiomatic triples are of the form e rdf type owl datatypeproperty e rdfs domain rdfs resource e rdfs range rdfs literal in analogy to section 6.1 for the rdf axiomatic triples all the axiomatic triples for the vocabulary properties including facets can be considered simple in the sense that they will have in their object position only single terms from the rdf rdfs and owl 2 rdf-based vocabularies section 3.2 6.4 a set of axiomatic triples this section provides a concrete example set of axiomatic triples based on the discussion in the sections 6.2 and 6.3. the axiomatic triples are grouped by different tables for the classes and the properties of the owl 2 rdf-based vocabulary for the datatypes and the facets of the owl 2 rdf-based semantics and for some of the classes and properties of the rdfs vocabulary. note that this set of axiomatic triples is not meant to be free of redundancy. table 6.1 axiomatic triples for the classes of the owl 2 rdf-based vocabulary owl alldifferent rdf type rdfs class owl alldifferent rdfs subclassof rdfs resource owl alldisjointclasses rdf type rdfs class owl alldisjointclasses rdfs subclassof rdfs resource owl alldisjointproperties rdf type rdfs class owl alldisjointproperties rdfs subclassof rdfs resource owl annotation rdf type rdfs class owl annotation rdfs subclassof rdfs resource owl annotationproperty rdf type rdfs class owl annotationproperty rdfs subclassof rdf property owl asymmetricproperty rdf type rdfs class owl asymmetricproperty rdfs subclassof owl objectproperty owl axiom rdf type rdfs class owl axiom rdfs subclassof rdfs resource owl class rdf type rdfs class owl class rdfs subclassof rdfs class owl datarange rdf type rdfs class owl datarange rdfs subclassof rdfs datatype owl datatypeproperty rdf type rdfs class owl datatypeproperty rdfs subclassof rdf property owl deprecatedclass rdf type rdfs class owl deprecatedclass rdfs subclassof rdfs class owl deprecatedproperty rdf type rdfs class owl deprecatedproperty rdfs subclassof rdf property owl functionalproperty rdf type rdfs class owl functionalproperty rdfs subclassof rdf property owl inversefunctionalproperty rdf type rdfs class owl inversefunctionalproperty rdfs subclassof owl objectproperty owl irreflexiveproperty rdf type rdfs class owl irreflexiveproperty rdfs subclassof owl objectproperty owl namedindividual rdf type rdfs class owl namedindividual rdfs subclassof owl thing owl negativepropertyassertion rdf type rdfs class owl negativepropertyassertion rdfs subclassof rdfs resource owl nothing rdf type owl class owl nothing rdfs subclassof owl thing owl objectproperty rdf type rdfs class owl objectproperty rdfs subclassof rdf property owl ontology rdf type rdfs class owl ontology rdfs subclassof rdfs resource owl ontologyproperty rdf type rdfs class owl ontologyproperty rdfs subclassof rdf property owl reflexiveproperty rdf type rdfs class owl reflexiveproperty rdfs subclassof owl objectproperty owl restriction rdf type rdfs class owl restriction rdfs subclassof owl class owl symmetricproperty rdf type rdfs class owl symmetricproperty rdfs subclassof owl objectproperty owl thing rdf type owl class owl transitiveproperty rdf type rdfs class owl transitiveproperty rdfs subclassof owl objectproperty table 6.2 axiomatic triples for the properties of the owl 2 rdf-based vocabulary owl allvaluesfrom rdf type rdf property owl allvaluesfrom rdfs domain owl restriction owl allvaluesfrom rdfs range rdfs class owl annotatedproperty rdf type rdf property owl annotatedproperty rdfs domain rdfs resource owl annotatedproperty rdfs range rdfs resource owl annotatedsource rdf type rdf property owl annotatedsource rdfs domain rdfs resource owl annotatedsource rdfs range rdfs resource owl annotatedtarget rdf type rdf property owl annotatedtarget rdfs domain rdfs resource owl annotatedtarget rdfs range rdfs resource owl assertionproperty rdf type rdf property owl assertionproperty rdfs domain owl negativepropertyassertion owl assertionproperty rdfs range rdf property owl backwardcompatiblewith rdf type owl annotationproperty owl backwardcompatiblewith rdf type owl ontologyproperty owl backwardcompatiblewith rdfs domain owl ontology owl backwardcompatiblewith rdfs range owl ontology owl bottomdataproperty rdf type owl datatypeproperty owl bottomdataproperty rdfs domain owl thing owl bottomdataproperty rdfs range rdfs literal owl bottomobjectproperty rdf type owl objectproperty owl bottomobjectproperty rdfs domain owl thing owl bottomobjectproperty rdfs range owl thing owl cardinality rdf type rdf property owl cardinality rdfs domain owl restriction owl cardinality rdfs range xsd nonnegativeinteger owl complementof rdf type rdf property owl complementof rdfs domain owl class owl complementof rdfs range owl class owl datatypecomplementof rdf type rdf property owl datatypecomplementof rdfs domain rdfs datatype owl datatypecomplementof rdfs range rdfs datatype owl deprecated rdf type owl annotationproperty owl deprecated rdfs domain rdfs resource owl deprecated rdfs range rdfs resource owl differentfrom rdf type rdf property owl differentfrom rdfs domain owl thing owl differentfrom rdfs range owl thing owl disjointunionof rdf type rdf property owl disjointunionof rdfs domain owl class owl disjointunionof rdfs range rdf list owl disjointwith rdf type rdf property owl disjointwith rdfs domain owl class owl disjointwith rdfs range owl class owl distinctmembers rdf type rdf property owl distinctmembers rdfs domain owl alldifferent owl distinctmembers rdfs range rdf list owl equivalentclass rdf type rdf property owl equivalentclass rdfs domain rdfs class owl equivalentclass rdfs range rdfs class owl equivalentproperty rdf type rdf property owl equivalentproperty rdfs domain rdf property owl equivalentproperty rdfs range rdf property owl haskey rdf type rdf property owl haskey rdfs domain owl class owl haskey rdfs range rdf list owl hasself rdf type rdf property owl hasself rdfs domain owl restriction owl hasself rdfs range rdfs resource owl hasvalue rdf type rdf property owl hasvalue rdfs domain owl restriction owl hasvalue rdfs range rdfs resource owl imports rdf type owl ontologyproperty owl imports rdfs domain owl ontology owl imports rdfs range owl ontology owl incompatiblewith rdf type owl annotationproperty owl incompatiblewith rdf type owl ontologyproperty owl incompatiblewith rdfs domain owl ontology owl incompatiblewith rdfs range owl ontology owl intersectionof rdf type rdf property owl intersectionof rdfs domain rdfs class owl intersectionof rdfs range rdf list owl inverseof rdf type rdf property owl inverseof rdfs domain owl objectproperty owl inverseof rdfs range owl objectproperty owl maxcardinality rdf type rdf property owl maxcardinality rdfs domain owl restriction owl maxcardinality rdfs range xsd nonnegativeinteger owl maxqualifiedcardinality rdf type rdf property owl maxqualifiedcardinality rdfs domain owl restriction owl maxqualifiedcardinality rdfs range xsd nonnegativeinteger owl members rdf type rdf property owl members rdfs domain rdfs resource owl members rdfs range rdf list owl mincardinality rdf type rdf property owl mincardinality rdfs domain owl restriction owl mincardinality rdfs range xsd nonnegativeinteger owl minqualifiedcardinality rdf type rdf property owl minqualifiedcardinality rdfs domain owl restriction owl minqualifiedcardinality rdfs range xsd nonnegativeinteger owl onclass rdf type rdf property owl onclass rdfs domain owl restriction owl onclass rdfs range owl class owl ondatarange rdf type rdf property owl ondatarange rdfs domain owl restriction owl ondatarange rdfs range rdfs datatype owl ondatatype rdf type rdf property owl ondatatype rdfs domain rdfs datatype owl ondatatype rdfs range rdfs datatype owl oneof rdf type rdf property owl oneof rdfs domain rdfs class owl oneof rdfs range rdf list owl onproperty rdf type rdf property owl onproperty rdfs domain owl restriction owl onproperty rdfs range rdf property owl onproperties rdf type rdf property owl onproperties rdfs domain owl restriction owl onproperties rdfs range rdf list owl priorversion rdf type owl annotationproperty owl priorversion rdf type owl ontologyproperty owl priorversion rdfs domain owl ontology owl priorversion rdfs range owl ontology owl propertychainaxiom rdf type rdf property owl propertychainaxiom rdfs domain owl objectproperty owl propertychainaxiom rdfs range rdf list owl propertydisjointwith rdf type rdf property owl propertydisjointwith rdfs domain rdf property owl propertydisjointwith rdfs range rdf property owl qualifiedcardinality rdf type rdf property owl qualifiedcardinality rdfs domain owl restriction owl qualifiedcardinality rdfs range xsd nonnegativeinteger owl sameas rdf type rdf property owl sameas rdfs domain owl thing owl sameas rdfs range owl thing owl somevaluesfrom rdf type rdf property owl somevaluesfrom rdfs domain owl restriction owl somevaluesfrom rdfs range rdfs class owl sourceindividual rdf type rdf property owl sourceindividual rdfs domain owl negativepropertyassertion owl sourceindividual rdfs range owl thing owl targetindividual rdf type rdf property owl targetindividual rdfs domain owl negativepropertyassertion owl targetindividual rdfs range owl thing owl targetvalue rdf type rdf property owl targetvalue rdfs domain owl negativepropertyassertion owl targetvalue rdfs range rdfs literal owl topdataproperty rdf type owl datatypeproperty owl topdataproperty rdfs domain owl thing owl topdataproperty rdfs range rdfs literal owl topobjectproperty rdf type rdf objectproperty owl topobjectproperty rdfs domain owl thing owl topobjectproperty rdfs range owl thing owl unionof rdf type rdf property owl unionof rdfs domain rdfs class owl unionof rdfs range rdf list owl versioninfo rdf type owl annotationproperty owl versioninfo rdfs domain rdfs resource owl versioninfo rdfs range rdfs resource owl versioniri rdf type owl ontologyproperty owl versioniri rdfs domain owl ontology owl versioniri rdfs range owl ontology owl withrestrictions rdf type rdf property owl withrestrictions rdfs domain rdfs datatype owl withrestrictions rdfs range rdf list table 6.3 axiomatic triples for the datatypes of the owl 2 rdf-based semantics xsd anyuri rdf type rdfs datatype xsd anyuri rdfs subclassof rdfs literal xsd base64binary rdf type rdfs datatype xsd base64binary rdfs subclassof rdfs literal xsd boolean rdf type rdfs datatype xsd boolean rdfs subclassof rdfs literal xsd byte rdf type rdfs datatype xsd byte rdfs subclassof rdfs literal xsd datetime rdf type rdfs datatype xsd datetime rdfs subclassof rdfs literal xsd datetimestamp rdf type rdfs datatype xsd datetimestamp rdfs subclassof rdfs literal xsd decimal rdf type rdfs datatype xsd decimal rdfs subclassof rdfs literal xsd double rdf type rdfs datatype xsd double rdfs subclassof rdfs literal xsd float rdf type rdfs datatype xsd float rdfs subclassof rdfs literal xsd hexbinary rdf type rdfs datatype xsd hexbinary rdfs subclassof rdfs literal xsd int rdf type rdfs datatype xsd int rdfs subclassof rdfs literal xsd integer rdf type rdfs datatype xsd integer rdfs subclassof rdfs literal xsd language rdf type rdfs datatype xsd language rdfs subclassof rdfs literal xsd long rdf type rdfs datatype xsd long rdfs subclassof rdfs literal xsd name rdf type rdfs datatype xsd name rdfs subclassof rdfs literal xsd ncname rdf type rdfs datatype xsd ncname rdfs subclassof rdfs literal xsd negativeinteger rdf type rdfs datatype xsd negativeinteger rdfs subclassof rdfs literal xsd nmtoken rdf type rdfs datatype xsd nmtoken rdfs subclassof rdfs literal xsd nonnegativeinteger rdf type rdfs datatype xsd nonnegativeinteger rdfs subclassof rdfs literal xsd nonpositiveinteger rdf type rdfs datatype xsd nonpositiveinteger rdfs subclassof rdfs literal xsd normalizedstring rdf type rdfs datatype xsd normalizedstring rdfs subclassof rdfs literal rdf plainliteral rdf type rdfs datatype rdf plainliteral rdfs subclassof rdfs literal xsd positiveinteger rdf type rdfs datatype xsd positiveinteger rdfs subclassof rdfs literal owl rational rdf type rdfs datatype owl rational rdfs subclassof rdfs literal owl real rdf type rdfs datatype owl real rdfs subclassof rdfs literal xsd short rdf type rdfs datatype xsd short rdfs subclassof rdfs literal xsd string rdf type rdfs datatype xsd string rdfs subclassof rdfs literal xsd token rdf type rdfs datatype xsd token rdfs subclassof rdfs literal xsd unsignedbyte rdf type rdfs datatype xsd unsignedbyte rdfs subclassof rdfs literal xsd unsignedint rdf type rdfs datatype xsd unsignedint rdfs subclassof rdfs literal xsd unsignedlong rdf type rdfs datatype xsd unsignedlong rdfs subclassof rdfs literal xsd unsignedshort rdf type rdfs datatype xsd unsignedshort rdfs subclassof rdfs literal rdf xmlliteral rdf type rdfs datatype rdf xmlliteral rdfs subclassof rdfs literal table 6.4 axiomatic triples for the facets of the owl 2 rdf-based semantics rdf langrange rdf type owl datatypeproperty rdf langrange rdfs domain rdfs resource rdf langrange rdfs range rdfs literal xsd length rdf type owl datatypeproperty xsd length rdfs domain rdfs resource xsd length rdfs range rdfs literal xsd maxexclusive rdf type owl datatypeproperty xsd maxexclusive rdfs domain rdfs resource xsd maxexclusive rdfs range rdfs literal xsd maxinclusive rdf type owl datatypeproperty xsd maxinclusive rdfs domain rdfs resource xsd maxinclusive rdfs range rdfs literal xsd maxlength rdf type owl datatypeproperty xsd maxlength rdfs domain rdfs resource xsd maxlength rdfs range rdfs literal xsd minexclusive rdf type owl datatypeproperty xsd minexclusive rdfs domain rdfs resource xsd minexclusive rdfs range rdfs literal xsd mininclusive rdf type owl datatypeproperty xsd mininclusive rdfs domain rdfs resource xsd mininclusive rdfs range rdfs literal xsd minlength rdf type owl datatypeproperty xsd minlength rdfs domain rdfs resource xsd minlength rdfs range rdfs literal xsd pattern rdf type owl datatypeproperty xsd pattern rdfs domain rdfs resource xsd pattern rdfs range rdfs literal table 6.5 additional axiomatic triples for classes and properties of the rdfs vocabulary rdfs class rdfs subclassof owl class rdfs comment rdf type owl annotationproperty rdfs comment rdfs domain rdfs resource rdfs comment rdfs range rdfs literal rdfs datatype rdfs subclassof owl datarange rdfs isdefinedby rdf type owl annotationproperty rdfs isdefinedby rdfs domain rdfs resource rdfs isdefinedby rdfs range rdfs resource rdfs label rdf type owl annotationproperty rdfs label rdfs domain rdfs resource rdfs label rdfs range rdfs literal rdfs literal rdf type rdfs datatype rdf property rdfs subclassof owl objectproperty rdfs resource rdfs subclassof owl thing rdfs seealso rdf type owl annotationproperty rdfs seealso rdfs domain rdfs resource rdfs seealso rdfs range rdfs resource 7 appendix relationship to the direct semantics informative this section compares the owl 2 rdf-based semantics with the owl 2 direct semantics owl 2 direct semantics while the owl 2 rdf-based semantics is based on the rdf semantics specification rdf semantics the owl 2 direct semantics is a description logic style semantics. several fundamental differences exist between the two semantics but there is also a strong relationship basically stating that the owl 2 rdf-based semantics is able to reflect all logical conclusions of the owl 2 direct semantics. this means that the owl 2 direct semantics can in a sense be regarded as a semantics subset of the owl 2 rdf-based semantics. technically the comparison will be performed by comparing the sets of entailments that hold for each of the two semantics respectively. the definition of an owl 2 rdf-based entailment was given in section 4.3 of this document while the definition of an owl 2 direct entailment is provided in section 2.5 of the owl 2 direct semantics owl 2 direct semantics in both cases entailments are defined for pairs of ontologies and such an ordered pair of two ontologies will be called an entailment query in this section. comparing the two semantics by means of entailments will only be meaningful if the entailment queries allow for applying both the owl 2 rdf-based semantics and the owl 2 direct semantics to them. in order to ensure this the comparison will be restricted to entailment queries for which the left-hand side and right-hand side ontologies are both owl 2 dl ontologies in rdf graph form. these are rdf graphs that by applying the reverse rdf mapping owl 2 rdf mapping can be transformed into corresponding owl 2 dl ontologies in functional syntax form according to the functional style syntax defined in the owl 2 structural specification owl 2 specification and which must further meet all the restrictions on owl 2 dl ontologies that are specified in section 3 of the owl 2 structural specification owl 2 specification in fact these restrictions must be mutually met by both ontologies that occur in an entailment query i.e. all these restrictions need to be satisfied as if the two ontologies would be part of a single ontology. any entailment query that adheres to the conditions defined here will be called an owl 2 dl entailment query. ideally the relationship between the owl 2 rdf-based semantics and the owl 2 direct semantics would be of the form that every owl 2 dl entailment query that is an owl 2 direct entailment is also an owl 2 rdf-based entailment. however this desirable relationship cannot hold in general due to a variety of differences that exist between the owl 2 rdf-based semantics and the owl 2 direct semantics as demonstrated in section 7.1. fortunately the problems resulting from these semantic differences can be overcome in a way that for every owl 2 dl entailment query there is another one for which the desired entailment relationship indeed holds and the new entailment query is semantically equivalent to the original entailment query under the owl 2 direct semantics. this is the gist of the owl 2 correspondence theorem which will be presented in section 7.2. the proof of this theorem given in section 7.3 will further demonstrate that such a substitute owl 2 dl entailment query can always be algorithmically constructed by means of simple syntactic transformations. 7.1 example on semantic differences this section will show that differences exist between the owl 2 rdf-based semantics and the owl 2 direct semantics and it will be demonstrated how these semantic differences complicate a comparison of the two semantics in terms of entailments. an example owl 2 dl entailment query will be given which will happen to be an owl 2 direct entailment without being an owl 2 rdf-based entailment. the section will explain the different reasons and will provide a resolution of each of them. it will turn out that the example entailment query can be syntactically transformed into another owl 2 dl entailment query that is both an owl 2 direct entailment and an owl 2 rdf-based entailment while being semantically unchanged compared to the original entailment query under the owl 2 direct semantics. this example will motivate the owl 2 correspondence theorem in section 7.2 and its proof in section 7.3. the example entailment query consists of the following pair g1 g2 of rdf graphs g1 1 ex o1 rdf type owl ontology 2 ex c1 rdf type owl class 3 ex c2 rdf type owl class 4 ex c1 rdfs subclassof ex c2 g2 1 ex o2 rdf type owl ontology 2 ex c1 rdf type owl class 3 ex c2 rdf type owl class 4 ex c3 rdf type owl class 5 ex c1 rdfs subclassof x 6 x rdf type owl class 7 x owl unionof ex c2 ex c3 8 ex c3 rdfs label c3 both g1 and g2 are owl 2 dl ontologies in rdf graph form and can therefore be mapped by the reverse rdf mapping owl 2 rdf mapping to the following two owl 2 dl ontologies in functional syntax form f g1 and f g2 f g1 1 ontology ex o1 2 declaration class ex c1 3 declaration class ex c2 4 subclassof ex c1 ex c2 5 f g2 1 ontology ex o2 2 declaration class ex c1 3 declaration class ex c2 4 declaration class ex c3 5 subclassof ex c1 objectunionof ex c2 ex c3 6 annotationassertion rdfs label ex c3 c3 7 note that f g1 and f g2 mutually meet the restrictions on owl 2 dl ontologies as specified in section 3 of the owl 2 structural specification owl 2 specification for example none of the iris being declared as a class in f g1 is declared as a datatype in f g2 since this would not be allowed for an owl 2 dl entailment query. it follows that f g1 owl 2 direct entails f g2 to show this only the axioms 4 of f g1 and 5 of f g2 have to be considered. none of the other statements in the two ontologies are relevant for this owl 2 direct entailment to hold since they do not have a formal meaning under the owl 2 direct semantics. however it turns out that the rdf graph g1 does not owl 2 rdf-based entail g2 for reasons discussed in detail now. reason 1 an annotation in f g2 the ontology f g2 contains an annotation 6 the owl 2 direct semantics does not give a formal meaning to annotations. in contrast under the owl 2 rdf-based semantics every rdf triple occurring in an rdf graph has a formal meaning including the corresponding annotation triple 8 in g2 since this annotation triple only occurs in g2 but not in g1 there will exist owl 2 rdf-based interpretations that satisfy g1 without satisfying triple 8 of g2 hence g1 does not owl 2 rdf-based entail g2 resolution of reason 1. the annotation triple 8 in g2 will be removed which will avoid requiring owl 2 rdf-based interpretations to interpret this triple. the changed rdf graphs will still be owl 2 dl ontologies in rdf graph form since annotations are strictly optional in owl 2 dl ontologies and may therefore be omitted. also this operation will not change the formal meaning of the ontologies under the owl 2 direct semantics since annotations do not have a formal meaning under this semantics. reason 2 an entity declaration exclusively in f g2 the ontology f g2 contains an entity declaration for the class iri ex c3 4 for which there is no corresponding entity declaration in f g1 the owl 2 direct semantics does not give a formal meaning to entity declarations while the owl 2 rdf-based semantics gives a formal meaning to the corresponding declaration statement 4 in g2 the consequences are analog to those described for reason 1. resolution of reason 2. the declaration statement 4 in g2 will be copied to g1 an owl 2 rdf-based interpretation that satisfies the modified graph g1 will then also satisfy the declaration statement. the changed rdf graphs will still be owl 2 dl ontologies in rdf graph form since the copied declaration statement is not in conflict with any of the other entity declarations in g1 also this operation will not change the formal meaning of the ontologies under the owl 2 direct semantics since entity declarations do not have a formal meaning under this semantics. reason 3 different ontology iris in f g1 and f g2 the ontology iris for the two ontologies given by 1 in f g1 and by 1 in f g2 differ from each other. the owl 2 direct semantics does not give a formal meaning to ontology headers while the owl 2 rdf-based semantics gives a formal meaning to the corresponding header triples 1 in g1 and 1 in g2 since these header triples differ from each other the consequences are analog to those described for reason 1. resolution of reason 3. the iri in the subject position of the header triple 1 in g2 is changed into a blank node. due to the existential semantics of blank nodes under the owl 2 rdf-based semantics the resulting triple will then be entailed by triple 1 in g1 the changed rdf graphs will still be owl 2 dl ontologies in rdf graph form since an ontology iri is optional for an owl 2 dl ontology. note however that it would have been an error to simply remove triple 1 from g2 since an owl 2 dl ontology is required to contain an ontology header. also this operation will not change the formal meaning of the ontologies under the owl 2 direct semantics since ontology headers do not have a formal meaning under this semantics. reason 4 a class expression in f g2 axiom 5 of f g2 contains a class expression that represents the union of the two classes denoted by ex c2 and ex c3. within g2 this class expression is represented by the triples 6 and 7 both having the blank node x in their respective subject position. the way the owl 2 rdf-based semantics interprets these two triples differs from the way the owl 2 direct semantics treats the class expression in axiom 5 of f g2 the owl 2 direct semantics treats classes as sets i.e. subsets of the universe. thus the iris ex c2 and ex c3 in f g2 denote two sets and the class expression in axiom 5 of f g2 therefore represents the set that consists of the union of these two sets. the owl 2 rdf-based semantics on the other hand treats classes as individuals i.e. members of the universe. while every class under the owl 2 rdf-based semantics represents a certain subset of the universe namely its class extension this set is actually distinguished from the class itself. for two given classes it is ensured under the owl 2 rdf-based semantics just as for the owl 2 direct semantics that the union of their class extensions will always exist as a subset of the universe. however there is no guarantee that there will also exist an individual in the universe that has this set union as its class extension. under the owl 2 rdf-based semantics triple 7 of g2 essentially claims that a class exists being the union of two other classes. but since the existence of such a union class is not ensured by g1 there will be owl 2 rdf-based interpretations that satisfy g1 without satisfying triple 7 of g2 hence g1 does not owl 2 rdf-based entail g2 resolution of reason 4. the triples 6 and 7 of g2 are copied to g1 together with the new triple x owl equivalentclass x in addition for the iri ex c3 which only occurs in the union class expression but not in g1 an entity declaration is added to g1 by the resolution of reason 2. if an owl 2 rdf-based interpretation satisfies the modified graph g1 then the triples 6 and 7 of g2 will now be satisfied. the changed rdf graphs will still be owl 2 dl ontologies in rdf graph form since the whole set of added triples validly encodes an owl 2 axiom and since none of the restrictions on owl 2 dl ontologies is hurt. also this operation will not change the formal meaning of the ontologies under the owl 2 direct semantics since the added equivalence axiom is a tautology under this semantics. note that it would have been an error to simply copy the triples 6 and 7 of g2 to g1 without also adding the new triple x owl equivalentclass x this would have produced a class expression that has no connection to any axiom in the ontology. an owl 2 dl ontology is basically a set of axioms and does not allow for the occurrence of dangling class expressions. this is the reason for actually embedding the class expression in an axiom. it would have also been wrong to use an arbitrary axiom for such an embedding since it has to be ensured that the formal meaning of the original ontology does not change under the owl 2 direct semantics. however any tautological axiom that contains the original class expression would have been sufficient for this purpose as well. complete resolution the transformed entailment query. combining the resolutions of all the above reasons leads to the following new pair of rdf graphs g1 g2 g1 1 ex o1 rdf type owl ontology 2 ex c1 rdf type owl class 3 ex c2 rdf type owl class 4 ex c3 rdf type owl class 5 ex c1 rdfs subclassof ex c2 6 x owl equivalentclass x 7 x rdf type owl class 8 x owl unionof ex c2 ex c3 g2 1 o rdf type owl ontology 2 ex c1 rdf type owl class 3 ex c2 rdf type owl class 4 ex c3 rdf type owl class 5 ex c1 rdfs subclassof x 6 x rdf type owl class 7 x owl unionof ex c2 ex c3 the following list reiterates the changes compared to the original rdf graphs g1 and g2 resolution of reason 1 annotation triple 8 in g2 has been removed i.e. there is no corresponding annotation triple in g2. resolution of reason 2 entity declaration triple 4 in g2 has been copied to g1 becoming triple 4 in g1. resolution of reason 3 ontology iris the iri in the subject position of triple 1 in g2 has been changed into a blank node becoming triple 1 in g2. resolution of reason 4 class expression triples 6 and 7 in g2 have been copied to g1 together with the new triple x owl equivalentclass x becoming triples 6 7 and 8 in g1. g1 and g2 are again owl 2 dl ontologies in rdf graph form and can be mapped to the following owl 2 dl ontologies in functional syntax form f g1 and f g2 which again mutually meet the restrictions on owl 2 dl ontologies f g1 1 ontology ex o1 2 declaration class ex c1 3 declaration class ex c2 4 declaration class ex c3 5 subclassof ex c1 ex c2 6 equivalentclasses objectunionof ex c2 ex c3 objectunionof ex c2 ex c3 7 f g2 1 ontology 2 declaration class ex c1 3 declaration class ex c2 4 declaration class ex c3 5 subclassof ex c1 objectunionof ex c2 ex c3 6 as said earlier all the applied changes preserve the formal meaning of the original owl 2 dl ontologies under the owl 2 direct semantics. hence it is still the case that f g1 owl 2 direct entails f g2 however due to the syntactic transformation the situation has changed for the owl 2 rdf-based semantics it is now possible to show by following the lines of argumentation for the resolutions of the different reasons given above that g1 owl 2 rdf-based entails g2 as well. 7.2 correspondence theorem this section presents the owl 2 correspondence theorem which compares the semantic expressivity of the owl 2 rdf-based semantics with that of the owl 2 direct semantics. the theorem basically states that the owl 2 rdf-based semantics is able to reflect all the semantic conclusions of the owl 2 direct semantics where the notion of a semantic conclusion is technically expressed in terms of an entailment. however as discussed in section 7.1 there exist semantic differences between the owl 2 rdf-based semantics and the owl 2 direct semantics which do not allow for stating that any owl 2 dl entailment query that is an owl 2 direct entailment will always also be an owl 2 rdf-based entailment. nevertheless it can still be ensured that any given owl 2 dl entailment query can be substituted by another owl 2 dl entailment query in a way that for the substitute entailment query the desired relationship will really hold while preserving the formal meaning compared to the original entailment query under the owl 2 direct semantics. in fact the theorem only makes the seemingly weak assertion that such a substitute entailment query will always exist. but the actual proof for the theorem in section 7.3 will be more concrete in that it will substitute each given owl 2 dl entailment query with a variant that can be algorithmically constructed by applying a set of simple syntactic transformations to the original entailment query. one can get an idea of how this works from section 7.1. technical note on corresponding datatype maps. a distinction exists between the format of an owl 2 rdf-based datatype map as defined by definition 4.1 and the format of an owl 2 direct datatype map as defined in section 2.1 of the owl 2 direct semantics owl 2 direct semantics it is however possible to translate between an owl 2 rdf-based datatype map d and the corresponding owl 2 direct datatype map f d in the following way for an owl 2 rdf-based datatype map d the corresponding owl 2 direct datatype map f d ndt nls nfs dt ls fs owl 2 direct semantics is given by datatype names ndt is defined as the set of all iris u for which there is a datatype d such that u d d. lexical space for each datatype name u ndt set nls u ls d where u d d. facet space for each datatype name u ndt set nfs u fs d where u d d. value space for each datatype name u ndt set u dt vs d where u d d. lexical-to-value mapping for each datatype name u ndt and each lexical form a nls u set a u ls l2v d a where u d d. facet-to-value mapping for each datatype name u ndt and each facet-value pair f v nfs u set f v fs f2v d f v where u d d. theorem 7.1 owl 2 correspondence theorem let d be an owl 2 rdf-based datatype map according to definition 4.1 with f d being the owl 2 direct datatype map according to section 2.1 of the owl 2 direct semantics owl 2 direct semantics that corresponds to d according to the technical note on corresponding datatype maps. let g1 and g2 be rdf graphs that are owl 2 dl ontologies in rdf graph form with f g1 and f g2 being the owl 2 dl ontologies in functional syntax form owl 2 specification that result from applying the reverse rdf mapping owl 2 rdf mapping to g1 and g2 respectively. let f g1 and f g2 mutually meet the restrictions on owl 2 dl ontologies as specified in section 3 of the owl 2 structural specification owl 2 specification then there exist rdf graphs g1 and g2 that are owl 2 dl ontologies in rdf graph form such that all the following relationships hold with f g1 and f g2 being the owl 2 dl ontologies in functional syntax form that result from applying the reverse rdf mapping to g1 and g2 respectively f g1 and f g2 mutually meet the restrictions on owl 2 dl ontologies. f g1 owl 2 direct entails f g1 with respect to f d and f g1 owl 2 direct entails f g1 with respect to f d f g2 owl 2 direct entails f g2 with respect to f d and f g2 owl 2 direct entails f g2 with respect to f d if f g1 owl 2 direct entails f g2 with respect to f d then g1 owl 2 rdf-based entails g2 with respect to d. 7.3 proof for the correspondence theorem this is the sketch of a proof for theorem 7.1 owl 2 correspondence theorem in section 7.2. the proof sketch provides the basic line of argumentation for showing the theorem. however for complexity reasons some technical aspects of the theorem are only coarsely treated and the proof sketch also refrains from considering the full amount of owl 2 language constructs. for certain steps of the proof there are example calculations that focus only on a small fraction of language constructs but which can be taken as a hint on how a complete proof taking into account every feature of the owl 2 rdf-based semantics could be constructed in principle. a complete proof could make use of the observation that the definitions of the owl 2 direct semantics and the owl 2 rdf-based semantics despite their technical differences as outlined in section 7.1 are closely aligned with respect to the different language constructs of owl 2. the proof sketch will make use of an approach that will be called balancing throughout this section and which will now be introduced. the basic idea is to substitute the original pair of rdf graphs in an owl 2 dl entailment query by another entailment query having the same semantic characteristics under the owl 2 direct semantics but for which the technical differences between the two semantics specifications have no relevant consequences under the owl 2 rdf-based semantics anymore. a concrete example for the application of this approach was given in section 7.1. definition balanced a pair of rdf graphs g1 g2 is called balanced if and only if g1 and g2 are owl 2 dl ontologies in rdf graph form such that all the following conditions hold with f g1 and f g2 being the owl 2 dl ontologies in functional syntax form owl 2 specification that result from applying the reverse rdf mapping owl 2 rdf mapping to g1 and g2 respectively f g1 and f g2 mutually meet the restrictions on owl 2 dl ontologies as specified in section 3 of the owl 2 structural specification owl 2 specification nodes in g1 and g2 for every iri u occurring in g1 or g2 that corresponds to a non-built-in entity in f g1 or f g2 respectively the graph contains for every entity type t of u a declaration statement of the form u rdf type t where t is the vocabulary class iri corresponding to t see table 7 in the owl 2 rdf mapping owl 2 rdf mapping and section 5.8 of the owl 2 structural specification owl 2 specification every plain or typed literal occurring in g2 also occurs in g1 see section 4 of the owl 2 structural specification owl 2 specification g2 contains exactly one ontology header consisting of a single rdf triple of the form x rdf type owl ontology where x is either a blank node or if an ontology iri is used in g1 may alternatively equal that ontology iri see table 4 in the owl 2 rdf mapping owl 2 rdf mapping g2 does not contain the rdf encoding of an annotation see sections 3.2.2 and 3.2.3 and table 17 in the owl 2 rdf mapping owl 2 rdf mapping a statement with an ontology property such as owl imports a deprecation statement based on owl deprecatedclass owl deprecatedproperty and owl deprecated see table 16 in the owl 2 rdf mapping owl 2 rdf mapping an annotation property axiom based on rdfs subclassof rdfs domain and rdfs range see table 16 in the owl 2 rdf mapping owl 2 rdf mapping any of the following sub graphs of g2 is also a sub graph of g1 the rdf encoding of an entity declaration see table 7 in the owl 2 rdf mapping owl 2 rdf mapping the rdf encoding of a property expression see table 11 in the owl 2 rdf mapping owl 2 rdf mapping the rdf encoding of a class expression see tables 13 and 15 in the owl 2 rdf mapping owl 2 rdf mapping the rdf encoding of a data range expression see tables 12 and 14 in the owl 2 rdf mapping owl 2 rdf mapping an rdf sequence see table 3 in the owl 2 rdf mapping owl 2 rdf mapping balancing lemma an algorithm exists that terminates on every valid input and that has the following input output behavior the valid input of the algorithm is given by all the pairs of rdf graphs g1 g2 where g1 and g2 are owl 2 dl ontologies in rdf graph form with f g1 and f g2 being the owl 2 dl ontologies in functional syntax form owl 2 specification that result from applying the reverse rdf mapping owl 2 rdf mapping to g1 and g2 respectively. further f g1 and f g2 have to mutually meet the restrictions on owl 2 dl ontologies as specified in section 3 of the owl 2 structural specification owl 2 specification for a valid input the output of the algorithm is a pair of rdf graphs g1 g2 where g1 and g2 are owl 2 dl ontologies in rdf graph form such that for any owl 2 rdf-based datatype map d according to definition 4.1 all the following relationships hold with f g1 and f g2 being the owl 2 dl ontologies in functional syntax form that result from applying the reverse rdf mapping to g1 and g2 respectively and with f d being the owl 2 direct datatype map according to section 2.1 of the owl 2 direct semantics owl 2 direct semantics that corresponds to d according to the technical note on corresponding datatype maps in section 7.2 the pair g1 g2 is balanced. f g1 owl 2 direct entails f g1 with respect to f d and f g1 owl 2 direct entails f g1 with respect to f d f g2 owl 2 direct entails f g2 with respect to f d and f g2 owl 2 direct entails f g2 with respect to f d proof for the balancing lemma let the graph pair g1 g2 be a valid input. the resulting rdf graphs g1 and g2 are constructed as follows starting from copies of g1 and g2 respectively. since the initial versions of g1 and g2 are owl 2 dl ontologies in rdf graph form the canonical parsing process cp for computing the reverse rdf mapping as described in section 3 of the owl 2 rdf mapping owl 2 rdf mapping can be applied. based on cp it is possible to identify within these graphs all entity types for every non-built-in iri all blank nodes that correspond to anonymous individuals and all sub graphs that correspond to owl 2 language constructs ontology headers declarations expressions axioms and annotations as described in the owl 2 structural specification owl 2 specification based on this observation the following steps are performed consistently substitute all blank nodes in g2 such that g1 and g2 have no common blank nodes. apply cp to g1 and g2 without changing these graphs to identify the entity types of the iris the anonymous individuals and the sub graphs encoding owl 2 language constructs. for each sub graph g of g2 remove g from g2 if g is the rdf encoding of an annotation or a deprecation statement or an annotation property axiom. for the sub graph g of g2 corresponding to the ontology header in f g2 substitute g in g2 by a triple of the form x rdf type owl ontology where x is a new blank node not yet used in g2. for each non-built-in iri u in g1 and g2 and for each entity type t of u identified by cp add to g1 or g2 respectively the rdf triple u rdf type t where t is the vocabulary class iri corresponding to t. for each plain or typed literal l in g2 add to g1 the rdf triple o rdfs comment l where o is the iri or blank node of the ontology header triple o rdf type owl ontology in g1. for each sub graph g of g2 that is the rdf encoding of an entity declaration add g to g1. for each sub graph g of g2 that is the rdf encoding of a property expression with root blank node x add g to g1 together with the rdf triple x owl equivalentproperty x for each sub graph g of g2 that is the rdf encoding of a class expression with root blank node x add g to g1 together with the rdf triple x owl equivalentclass x for each sub graph g of g2 that is the rdf encoding of a data range expression with root blank node x if g is part of a data property restriction expression then nothing needs to be done since the comprising restriction expression is covered by the treatment of class expressions and therefore g occurs in g1 as well. otherwise add a declaration triple to g1 for a new data property p that does not yet occur in g1 and g2. then the rdf encoding r of a universal data property restriction expression on property p is created for g. let r have the new root blank node y. add r to g1 together with the rdf triple y owl equivalentclass y for each sub graph g of g2 that is an rdf sequence with root blank node x which does not occur in the rdf encoding of language constructs already treated by one of the earlier steps i.e. g is part of the encoding of an axiom create the rdf encoding r of an enumeration class expression with a new root blank node y having the main rdf triple y owl oneof x then add r to g1 together with the rdf triple y owl equivalentclass y additionally for every iri u being a member of the rdf sequence add to g1 a typing triple u rdf type owl namedindividual if one of the sequence members is a blank node z that is the root node of some property expression or class expression e then select a new iri w not yet occurring in g1 consistently replace z by w everywhere in r add to g1 the triple w owl equivalentproperty z or w owl equivalentclass z respectively and add to g1 the two triples w rdf type owl namedindividual and w rdf type t where t is the vocabulary class iri that represents the appropriate entity type of the expression e. no further treatment of e is needed since e is treated by the earlier steps covering expressions. in the following it is shown that all the claims of the balancing lemma hold. a existence of a terminating algorithm. an algorithm exists for mapping the input graph pair g1 g2 to the output graph pair g1 g2 since cp applied in step 2 is described in the form of an algorithm in the owl 2 rdf mapping owl 2 rdf mapping and since all other steps can obviously be performed algorithmically. the algorithm terminates since cp terminates on arbitrary input graphs and since all other steps can obviously be executed in finite time. b the resulting rdf graphs are owl 2 dl ontologies. the rdf graphs g1 and g2 are owl 2 dl ontologies in rdf graph form that mutually meet the restrictions on owl 2 dl ontologies since the original rdf graphs g1 and g2 have this feature and since each of the steps described above transforms a pair of rdf graphs with this feature again into a pair of rdf graphs with this feature for the following reasons the consistent substitution of blank nodes in step 1 does not change the structure of an owl 2 dl ontology. the application of cp in step 2 does not change the graphs. annotations deprecation statements and annotation property axioms are optional information in an owl 2 dl ontology and can therefore be omitted in step 3. the ontology header of an owl 2 dl ontology does neither require the existence of an ontology iri nor of any ontology properties and so the substitution of the ontology header in step 4 is a valid operation. if an entity has some particular entity type for which there is no explicitly given entity declaration then the entity declaration may be added as done in step 5. it is allowed to add arbitrary annotations to the ontology header of an owl 2 dl ontology as done in step 6. entity declarations may be copied from g2 to g1 in step 7 without conflict since the original ontologies have been assumed to mutually meet the restrictions on owl 2 dl ontologies regarding different entity declarations for the same iri e.g. that one iri must not be the name of both an object property and a data property adding to g1 an axiom that claims equivalence of some property expression step 8 or class expression step 9 with itself where the expression already occurs in g2 is an allowed operation since the original ontologies are assumed to mutually meet the restrictions on owl 2 dl ontologies concerning property and class expressions and since no syntactic restrictions exist on this specific use of equivalence axioms. for the case of data ranges step 10 it is sufficient to note that placing universal property restrictions on arbitrary simple or complex property expressions is allowed in owl 2 dl. the rest of the argumentation follows the lines of the treatment of class expressions in step 9. for the treatment of rdf sequences in step 11 first the enumeration class expressions being constructed from the rdf sequences are syntactically valid in owl 2 dl since all enumerated entries are iris by construction. second there is no restriction in owl 2 dl disallowing axioms that claim equivalence of enumeration class expressions with themselves. third punning in owl 2 dl allows a given non-built-in iri of any entity type to be additionally declared as a named individual. forth there is no owl 2 dl restriction forbidding to add an entity declaration for a new i.e. not elsewhere used iri and to assert the denotation of this new iri to be equivalent to some existing property or class expression. hence the resulting ontologies still mutually meet all syntactic restrictions on owl 2 dl ontologies. c the resulting pair of rdf graphs is balanced. all the conditions of balanced pairs of rdf graphs are met by the pair g1 g2 for the following reasons condition 1 it has already been shown in paragraph b that g1 and g2 mutually meet the restrictions on owl 2 dl ontologies. conditions 2.1 and 2.2 on nodes in g1 and g2 are met by steps 5 and 6 respectively. condition 3 on ontology headers in g2 is satisfied by step 4 always applying an anonymous ontology header. conditions 4.1 4.3 and 4.4 on annotations deprecation statements and annotation property axioms in g2 respectively are all satisfied by step 3. condition 4.2 on statements with ontology properties is implicitly satisfied by step 4 since the substitution of the ontology header in g2 removes all existing statements with ontology properties. condition 5.1 on entity declarations in g2 being reflected in g1 is satisfied by step 7. conditions 5.2 5.3 and 5.4 on property class and data range expressions in g2 respectively being reflected in g1 are met by steps 8 9 and 10 respectively. condition 5.5 on rdf sequences in g2 being reflected in g1 is satisfied by step 11. d the resulting ontologies are semantically equivalent with the original ontologies under the owl 2 direct semantics. f g1 is semantically equivalent with f g1 since f g1 differs from f g1 only by potentially additional entity declarations steps 5 7 and 11 which have no formal meaning under the owl 2 direct semantics additional annotations step 6 which have no formal meaning additional tautological axioms steps 8 9 10 and 11 which do not change the formal meaning f g2 is semantically equivalent with f g2 since f g2 differs from f g2 only by potentially differently labeled anonymous individuals step 1 by which the formal meaning under the owl 2 direct semantics keeps unchanged since anonymous individuals are existentially interpreted missing annotations deprecation statements and annotation property axioms step 3 which have no formal meaning a modified ontology header step 4 which has no formal meaning additional entity declarations step 5 which have no formal meaning. end of proof for the balancing lemma. in the following the correspondence theorem will be proven. assume that the premises of the correspondence theorem are true for a given pair g1 g2 of rdf graphs. this allows for applying the balancing lemma which provides the existence of corresponding rdf graphs g1 and g2 that are owl 2 dl ontologies in rdf graph form and which meet the definition of balanced graph pairs. let f g1 and f g2 be the corresponding owl 2 dl ontologies in functional syntax form. then the claimed relationship 1 of the correspondence theorem follows directly from relationship 1 of the balancing lemma and from condition 1 of the definition of balanced graph pairs. further the claimed relationships 2 and 3 of the correspondence theorem follow directly from the relationships 2 and 3 of the balancing lemma respectively. the rest of this proof will treat the claimed relationship 4 of the correspondence theorem which states that if f g1 owl 2 direct entails f g2 with respect to f d then g1 owl 2 rdf-based entails g2 with respect to d. for this to see an arbitrary owl 2 rdf-based interpretation i will be selected that owl 2 rdf-based satisfies g1. for i a closely corresponding owl 2 direct interpretation j will be constructed and it will then be shown that j owl 2 direct satisfies f g1 since it was assumed that f g1 owl 2 direct entails f g2 it will follow that j owl 2 direct satisfies f g2 based on this result it will then be possible to show that i also owl 2 rdf-based satisfies g2. since i was arbitrarily selected this will mean that g1 owl 2 rdf-based entails g2. step 1 selection of a pair of corresponding interpretations. let f g1 owl 2 direct entail f g2 w.r.t. f d and let i be an owl 2 rdf-based interpretation of a vocabulary vi w.r.t. d such that i owl 2 rdf-based satisfies g1. since the pair g1 g2 is balanced there exist entity declarations in f g1 for each entity type of every non-built-in iri occurring in g1 for each entity declaration of the form declaration t u in f g1 such that t is the entity type for some iri u a typing triple of the form u rdf type t exists in g1 where t is the vocabulary class iri representing the part of the universe of i that corresponds to t. since i owl 2 rdf-based satisfies g1 all these declaration typing triples are owl 2 rdf-based satisfied by i and thus all non-built-in iris in g1 are instances of all their declared parts of the universe of i. the vocabulary vj vjc vjop vjdp vji vjdt vjlt vjfa of the owl 2 direct interpretation j w.r.t. the datatype map f d is now constructed as follows. the set vjc of classes contains all iris in vi that are declared as classes in f g1 together with all the required class names listed in section 2.1 of the owl 2 direct semantics owl 2 direct semantics the set vjop of object properties contains all iris in vi that are declared as object properties in f g1 together with all the required object property names listed in section 2.1 of the owl 2 direct semantics owl 2 direct semantics the set vjdp of data properties contains all iris in vi that are declared as data properties in f g1 together with all the required data property names listed in section 2.1 of the owl 2 direct semantics owl 2 direct semantics the set vji of individuals contains all iris in vi that are declared as named individuals in f g1 and additionally all anonymous individuals occurring in f g1 and f g2 the set vjdt of datatypes is defined according to section 2.1 of the owl 2 direct semantics owl 2 direct semantics w.r.t. the datatype map f d together with all other iris in vi that are declared as datatypes in f g1 the set vjlt of literals is defined according to section 2.1 of the owl 2 direct semantics owl 2 direct semantics w.r.t. the datatype map f d the set vjfa of facet-literal pairs is defined according to section 2.1 of the owl 2 direct semantics owl 2 direct semantics w.r.t. the datatype map f d the owl 2 direct interpretation j i d c op dp i dt lt fa is now defined as follows. the object and data domains of j are identified with the universe ir and the set of data values lv of i respectively i.e. i ir and d lv. the class interpretation function c the object property interpretation function op the data property interpretation function dp the datatype interpretation function dt the literal interpretation function lt and the facet interpretation function fa are defined according to section 2.2 of the owl 2 direct semantics owl 2 direct semantics specifically for every non-built-in iri u occurring in f g1 if u is declared as a class then set uc icext i u since g1 contains the triple u rdf type owl class i.e. i u ic. if u is declared as an object property then set uop iext i u since g1 contains the triple u rdf type owl objectproperty i.e. i u ip. if u is declared as a data property then set udp iext i u since g1 contains the triple u rdf type owl datatypeproperty i.e. i u iodp. if u is declared as a named individual then set ui i u since g1 contains the triple u rdf type owl namedindividual i.e. i u ir. if u is declared as a datatype then set udt icext i u since g1 contains the triple u rdf type rdfs datatype i.e. i u idc. notes a literal occurring in g1 is mapped by the reverse rdf mapping to the same literal in f g1 and the formal meaning of a well-formed literal is analog for both the owl 2 rdf-based semantics and the owl 2 direct semantics. a blank node b occurring in g1 that represents an anonymous individual is written as the same blank node b in f g1 both the owl 2 rdf-based semantics and the owl 2 direct semantics treat anonymous individuals in an analog way as existential variables defined locally to a given ontology i.e. some individual x exists in the universe to which all occurrences of b in the ontology can be mapped see section 1.5 in the rdf semantics rdf semantics for the precise definition on how blank nodes are treated under the owl 2 rdf-based semantics hence the same mapping from b to x can be used with both i and j. g1 may also contain declarations for annotation properties. since annotation properties have no formal meaning under the owl 2 direct semantics the owl 2 direct interpretation j does not treat them. with the above definition it is possible for j to have a nonseparated vocabulary according to section 5.9 of the owl 2 structural specification owl 2 specification since g1 is an owl 2 dl ontology in rdf graph form it is allowed that the same iri u may be declared as one or more of an individual name either a class name or a datatype name and either an object property name or a data property name. for the owl 2 rdf-based interpretation i the iri u will always denote the same individual in the universe ir where i u may additionally have a class extension or a property extension or both. for the owl 2 direct interpretation j however u will denote as an individual name an element of i as a class name a subset of i as a datatype name a subset of d as an object property name a subset of i i and as a data property name a subset of i d. step 2 satisfaction of f g1 by the owl 2 direct interpretation. based on the premise that i owl 2 rdf-based satisfies g1 it has to be shown that j owl 2 direct satisfies f g1 for this to hold it will be sufficient that j owl 2 direct satisfies every axiom a occurring in f g1 let ga be the sub graph of g1 that is mapped to a by the reverse rdf mapping. the basic idea can roughly be described as follows since i is an owl 2 rdf-based interpretation all the owl 2 rdf-based semantic conditions are met by i. due to the close alignment between the definitions in the owl 2 rdf-based semantics and the owl 2 direct semantics owl 2 rdf-based semantic conditions exist that semantically correspond to the definition of the interpretation of the axiom a. in particular the antecedent of one of these semantic conditions will become true if the rdf-encoding of a i.e. the graph ga is satisfied in the case of an if-and-only-if semantic condition this will generally be the left-to-right direction of that condition now all the rdf triples in ga are owl 2 rdf-based satisfied by i since i owl 2 rdf-based satisfies g1. hence the antecedent of the semantic condition becomes true and therefore its consequent becomes true as well. this will reveal a certain semantic relationship that according to i holds between the denotations of the iris literals and anonymous individuals occurring in ga which roughly speaking expresses the meaning of the owl 2 axiom a. because of the close semantic correspondence of the owl 2 direct interpretation j to i the analog semantic relationship holds according to j between the denotations of the iris literals and anonymous individuals occurring in a. this semantic relationship turns out to be compatible with the formal meaning of the axiom a as specified by the owl 2 direct semantics i.e. j satisfies a. this basic idea is now demonstrated in more detail for a single example axiom a in f g1 which can be taken as a hint on how a complete proof taking into account every feature of the owl 2 rdf-based semantics could be constructed in principle. let a be the following owl 2 axiom in f g1 a subclassof ex c1 objectunionof ex c2 ex c3 and let ga be the corresponding sub graph in g1 that is being mapped to a via the reverse rdf mapping namely ga ex c1 rdfs subclassof x x rdf type owl class x owl unionof ex c2 ex c3 since the pair g1 g2 is balanced g1 contains the typing triples ex c1 rdf type owl class ex c2 rdf type owl class ex c3 rdf type owl class that correspond to class entity declarations in f g1 for the iris ex c1 ex c2 and ex c3 respectively. all these declaration typing triples are owl 2 rdf-based satisfied by i since it has been postulated that i owl 2 rdf-based satisfies g1. hence by applying the semantics of rdf type see section 4.1 of the rdf semantics rdf semantics all the iris denote classes precisely i ex c1 ic i ex c2 ic and i ex c3 ic since i is an owl 2 rdf-based interpretation it meets all the owl 2 rdf-based semantic conditions and since i owl 2 rdf-based satisfies g1 all the triples in ga are owl 2 rdf-based satisfied. this meets the left-to-right directions of the semantic conditions for subclass axioms rdfs subclassof see section 5.8 and union class expressions owl unionof see section 5.4 which results in the following semantic relationship that holds between the extensions of the classes above according to i icext i ex c1 icext i ex c2 icext i ex c3 by applying the definition of j one can conclude that the following semantic relationship holds between the denotations of the class names occurring in a according to j ex c1 c ex c2 c ex c3 c this semantic relationship is compatible with the formal meaning of the axiom a under the owl 2 direct semantics. hence j owl 2 direct satisfies a. since j owl 2 direct satisfies f g1 and since it has been postulated that f g1 owl 2 direct entails f g2 it follows that j owl 2 direct satisfies f g2 step 3 satisfaction of g2 by the owl 2 rdf-based interpretation. the last step will be to show that i owl 2 rdf-based satisfies g2. for this to hold i needs to owl 2 rdf-based satisfy every triple occurring in g2. the basic idea can roughly be described as follows first according to the semantic conditions for ground graphs in section 1.4 of the rdf semantics specification rdf semantics all the iris and literals used in rdf triples in g2 need to be in the vocabulary vi of i. this is true for the following reason since the pair g1 g2 is balanced all iris and literals occurring in g2 do also occur in g1. since i satisfies g1 all iris and literals in g1 including those in g2 are contained in vi due to the semantic conditions for ground graphs. second if a set of rdf triples encodes an owl 2 language construct that is not interpreted by the owl 2 direct semantics such as annotations then g2 should contain such a set of rdf triples only if they are also included in g1. the reason is that with such triples there will in general exist owl 2 rdf-based interpretations only satisfying the graph g1 but not g2 which will render the pair g1 g2 into a nonentailment an exception are rdf triples that are true under every owl 2 rdf-based interpretation since the pair g1 g2 is balanced g2 will not contain the rdf encoding for any annotations statements with ontology properties deprecation statements or annotation property axioms. hence there are no corresponding rdf triples that need to be satisfied by i. third since g2 is an owl 2 dl ontology in rdf graph form the graph is partitioned by the reverse rdf mapping owl 2 rdf mapping into sub graphs corresponding to either ontology headers entity declarations or axioms where axioms may further consist of different kinds of expressions such as boolean class expressions. it has to be shown that all the triples in each such sub graph are owl 2 rdf-based satisfied by i. for ontology headers let a be the ontology header of f g2 and let ga be the corresponding sub graph of g2. since the pair g1 g2 is balanced ga is encoded as a single rdf triple of the form x rdf type owl ontology where x is either an iri or a blank node. since g1 is an owl 2 dl ontology in rdf graph form g1 also contains the encoding of an ontology header including a triple g1 of the form y rdf type owl ontology where y is either an iri or a blank node. since i owl 2 rdf-based satisfies g1 g1 is satisfied by i. if both y and x are iris then due to balancing x equals y and therefore ga equals g1 i.e. ga is owl 2 rdf-based satisfied by i. otherwise balancing forces x to be a blank node i.e. x is treated as an existential variable under the owl 2 rdf-based semantics according to the semantic conditions for blank nodes rdf semantics from this observation and from the premise that i satisfies g1 it follows that ga is owl 2 rdf-based satisfied by i. for entity declarations let a be an entity declaration in f g2 and let ga be the corresponding sub graph of g2. since the pair g1 g2 is balanced a occurs in f g1 and hence ga is a sub graph of g1. since i owl 2 rdf-based satisfies g1 i owl 2 rdf-based satisfies ga. for axioms let a be an axiom in f g2 and let ga be the corresponding sub graph of g2. since i is an owl 2 rdf-based interpretation all the owl 2 rdf-based semantic conditions are met by i. due to the close alignment between the definitions in the owl 2 rdf-based semantics and the owl 2 direct semantics owl 2 rdf-based semantic conditions exist that semantically correspond to the definition of the interpretation of the axiom a. in particular the consequent of one of these semantic conditions corresponds to the rdf-encoding of a i.e. the graph ga except for declaration typing triples for which satisfaction has already been shown in the case of an if-and-only-if semantic condition this will generally be the right-to-left direction of that condition hence in order to show that ga is owl 2 rdf-based satisfied by i it will be sufficient to show that the antecedent of this semantic condition is true. in general several requirements have to be met to ensure this requirement 1 the denotations of all the non-built-in iris in ga have to be contained in the appropriate part of the universe of i. this can be shown as follows. for every non-built-in iri u occurring in ga u also occurs in a. since the pair g1 g2 is balanced there are entity declarations in f g2 for all the entity types of u each being of the form d declaration t u for some entity type t. from the reverse rdf mapping follows that for each such declaration d a typing triple d exists in g2 being of the form d u rdf type t where t is the vocabulary class iri representing the part of the universe of i that corresponds to the entity type t. it has already been shown that for d being an entity declaration in f g2 and d being the corresponding sub graph in g2 i owl 2 rdf-based satisfies d. hence i u is an individual contained in the appropriate part of the universe. requirement 2 for every expression e occurring in a with the rdf encoding ge in ga an individual has to exist in the universe of i that appropriately represents the denotation of e. since i is an owl 2 rdf-based interpretation all the owl 2 rdf-based semantic conditions are met by i. due to the close alignment between the definitions in the owl 2 rdf-based semantics and the owl 2 direct semantics owl 2 rdf-based semantic conditions exist that semantically correspond to the definition of the interpretation of the expression e. in particular the antecedent of one of these semantic conditions will become true if the rdf-encoding of e i.e. the graph ge is satisfied in the case of an if-and-only-if semantic condition this will generally be the left-to-right direction of that condition now since the pair g1 g2 is balanced ge also occurs in g1. so since i owl 2 rdf-based satisfies g1 ge is owl 2 rdf-based satisfied by i. hence the antecedent of the semantic condition becomes true and therefore its consequent becomes true as well. this will result in the existence of an individual with the required properties when taking into account existential blank node semantics. requirement 3 a semantic relationship has to hold between the denotations of the iris literals and anonymous individuals occurring in ga with respect to i which roughly speaking expresses the meaning of the owl 2 axiom a. this is the case for the following reasons first the literals and anonymous individuals occurring in a and ga respectively are interpreted in an analog way under the owl 2 direct semantics and the owl 2 rdf-based semantics. second it was assumed that the owl 2 direct interpretation j owl 2 direct satisfies a and therefore a semantic relationship with the desired properties holds with respect to j. third j has been defined in close correspondence to i so that for the semantic relationship expressed by j an analog semantic relationship holds with respect to i. this basic idea is now demonstrated in more detail for a single example axiom a in f g2 which can be taken as a hint on how a complete proof taking into account every feature of the owl 2 rdf-based semantics could be constructed in principle. let a be the following owl 2 axiom in f g2 a subclassof ex c1 objectunionof ex c2 ex c3 and let ga be the corresponding sub graph in g2 that is being mapped to a via the reverse rdf mapping namely ga ex c1 rdfs subclassof x x rdf type owl class x owl unionof ex c2 ex c3 first since the pair g1 g2 is balanced g2 contains the typing triples ex c1 rdf type owl class ex c2 rdf type owl class ex c3 rdf type owl class that correspond to class entity declarations in f g2 for the iris ex c1 ex c2 and ex c3 respectively. all these declaration typing triples are owl 2 rdf-based satisfied by i since due to balancing the typing triples exist in g1 as well and since it has been postulated that i owl 2 rdf-based satisfies all triples in g1. hence by applying the semantics of rdf type see section 4.1 of the rdf semantics rdf semantics all the iris denote classes and therefore the denotations of the iris are included in the appropriate part of the universe of i precisely i ex c1 ic i ex c2 ic and i ex c3 ic second ga contains the sub graph ge given by ge x rdf type owl class x owl unionof c2 c3 which corresponds to the union class expression e in a given by e objectunionof ex c2 ex c3 since the pair g1 g2 is balanced ge occurs as a sub graph of g1 as well. ge contains blank nodes and since i satisfies g1 the semantic conditions for rdf graphs with blank nodes apply see section 1.5 of the rdf semantics rdf semantics this provides the existence of a mapping b from blank ge to ir where blank ge is the set of all blank nodes occurring in ge. it follows that the extended interpretation i+b owl 2 rdf-based satisfies all the triples in ge. further since i is an owl 2 rdf-based interpretation i meets all the owl 2 rdf-based semantic conditions. thus the left-to-right direction of the semantic condition for union class expressions owl unionof see section 5.4 applies providing i+b x ic icext i+b x icext i ex c2 icext i ex c3 third since the owl 2 direct interpretation j owl 2 direct satisfies a the following semantic relationship holds between the denotations of the class names in a according to j ex c1 c ex c2 c ex c3 c by applying the definition of the owl 2 direct interpretation j one can conclude that the following semantic relationship holds between the extensions of the classes above according to i icext i ex c1 icext i ex c2 icext i ex c3 finally combining all intermediate results gives i ex c1 ic i+b x ic icext i ex c1 icext i+b x therefore all the premises are met to apply the right-to-left direction of the semantic condition for subclass axioms rdfs subclassof see section 5.8 which results in i ex cl i+b x iext i rdfs subclassof so the remaining triple ex c1 rdfs subclassof x in ga is owl 2 rdf-based satisfied by i+b where x is the root blank node of the union class expression ge. hence w.r.t. existential blank node semantics i owl 2 rdf-based satisfies all the triples in ga. to conclude for any owl 2 rdf-based interpretation i that owl 2 rdf-based satisfies g1 i also owl 2 rdf-based satisfies g2. hence g1 owl 2 rdf-based entails g2 and therefore relationship 4 of the correspondence theorem holds. q.e.d. 8 appendix comprehension conditions informative the correspondence theorem in section 7.2 shows that it is possible for the owl 2 rdf-based semantics to reflect all the entailments of the owl 2 direct semantics owl 2 direct semantics provided that one allows for certain harmless syntactic transformations on the rdf graphs being considered. this makes numerous potentially desirable and useful entailments available that would otherwise be outside the scope of the owl 2 rdf-based semantics for the technical reasons discussed in section 7.1. it seems natural to ask for similar entailments even when an entailment query does not consist of owl 2 dl ontologies in rdf graph form. however the correspondence theorem does not apply to such cases and thus the owl 2 direct semantics cannot be taken as a reference frame for desirable and useful entailments or for when a graph transformation can be considered harmless or not. as discussed in section 7.1 a core obstacle for the correspondence theorem to hold was the rdf encoding of owl 2 expressions such as union class expressions when they appear on the right hand side of an entailment query. under the owl 2 rdf-based semantics it is not generally ensured that an individual exists which represents the denotation of such an expression. the comprehension conditions defined in this section are additional semantic conditions that provide the necessary individuals for every sequence class and property expression. by this the combination of the normative semantic conditions of the owl 2 rdf-based semantics section 5 and the comprehension conditions can be regarded to simulate the semantic expressivity of the owl 2 direct semantics on entailment queries consisting of arbitrary rdf graphs. the combined semantics is however not primarily intended for use in actual implementations. the comprehension conditions add significantly to the complexity and expressivity of the basic semantics and in fact have proven to lead to formal inconsistency. but the combined semantics can still be seen as a generalized reference frame for desirable and useful entailments and this can be used for example to evaluate methods that syntactically transform unrestricted entailment queries in order to receive additional entailments under the owl 2 rdf-based semantics. such a concrete method is however outside the scope of this specification. note the conventions in the introduction of section 5 semantic conditions apply to the current section as well. 8.1 comprehension conditions for sequences table 8.1 lists the comprehension conditions for sequences i.e. rdf lists. these comprehension conditions provide the existence of sequences built from any finite combination of individuals contained in the universe. table 8.1 comprehension conditions for sequences if then exists z1 zn ir a1 an ir z1 a1 iext i rdf first z1 z2 iext i rdf rest zn an iext i rdf first zn i rdf nil iext i rdf rest 8.2 comprehension conditions for boolean connectives table 8.2 lists the comprehension conditions for boolean connectives see section 5.4 for the corresponding semantic conditions these comprehension conditions provide the existence of complements for any class and datatype and of intersections and unions built from any finite set of classes contained in the universe. table 8.2 comprehension conditions for boolean connectives if then exists z ir s sequence of c1 cn ic z s iext i owl intersectionof s sequence of c1 cn ic z s iext i owl unionof c ic z c iext i owl complementof d idc z d iext i owl datatypecomplementof 8.3 comprehension conditions for enumerations table 8.3 lists the comprehension conditions for enumerations see section 5.5 for the corresponding semantic conditions these comprehension conditions provide the existence of enumeration classes built from any finite set of individuals contained in the universe. table 8.3 comprehension conditions for enumerations if then exists z ir s sequence of a1 an ir z s iext i owl oneof 8.4 comprehension conditions for property restrictions table 8.4 lists the comprehension conditions for property restrictions see section 5.6 for the corresponding semantic conditions these comprehension conditions provide the existence of cardinality restrictions on any property and for any nonnegative integer as well as value restrictions on any property and on any class contained in the universe. note that the comprehension conditions for self restrictions constrains the right hand side of the produced owl hasself assertions to be the boolean value true xsd boolean. this is in accordance with table 13 in section 3.2.4 of the owl 2 rdf mapping owl 2 rdf mapping implementations are not required to support the comprehension conditions for owl onproperties but may support them in order to realize n-ary dataranges with arity 2 see sections 7 and 8.4 of the owl 2 structural specification owl 2 specification for further information table 8.4 comprehension conditions for property restrictions if then exists z ir c ic p ip z c iext i owl somevaluesfrom z p iext i owl onproperty c ic s sequence of p1 pn ip n 1 z c iext i owl somevaluesfrom z s iext i owl onproperties c ic p ip z c iext i owl allvaluesfrom z p iext i owl onproperty c ic s sequence of p1 pn ip n 1 z c iext i owl allvaluesfrom z s iext i owl onproperties a ir p ip z a iext i owl hasvalue z p iext i owl onproperty p ip z i true xsd boolean iext i owl hasself z p iext i owl onproperty n inni p ip z n iext i owl mincardinality z p iext i owl onproperty n inni p ip z n iext i owl maxcardinality z p iext i owl onproperty n inni p ip z n iext i owl cardinality z p iext i owl onproperty n inni c ic p ip z n iext i owl minqualifiedcardinality z c iext i owl onclass z p iext i owl onproperty n inni d idc p iodp z n iext i owl minqualifiedcardinality z d iext i owl ondatarange z p iext i owl onproperty n inni c ic p ip z n iext i owl maxqualifiedcardinality z c iext i owl onclass z p iext i owl onproperty n inni d idc p iodp z n iext i owl maxqualifiedcardinality z d iext i owl ondatarange z p iext i owl onproperty n inni c ic p ip z n iext i owl qualifiedcardinality z c iext i owl onclass z p iext i owl onproperty n inni d idc p iodp z n iext i owl qualifiedcardinality z d iext i owl ondatarange z p iext i owl onproperty 8.5 comprehension conditions for datatype restrictions table 8.5 lists the comprehension conditions for datatype restrictions see section 5.7 for the corresponding semantic conditions these comprehension conditions provide the existence of datatypes built from restricting any datatype contained in the universe by any finite set of facet-value pairs contained in the facet space see section 4.1 of the original datatype. the set ifs is defined in section 5.7. table 8.5 comprehension conditions for datatype restrictions if then exists z ir s sequence of z1 zn ir d idc f1 fn iodp v1 vn lv f1 v1 fn vn ifs d z d iext i owl ondatatype z s iext i owl withrestrictions z1 v1 iext f1 zn vn iext fn 8.6 comprehension conditions for inverse properties table 8.6 lists the comprehension conditions for inverse property expressions. these comprehension conditions provide the existence of an inverse property for any property contained in the universe. inverse property expressions can be used to build axioms with anonymous inverse properties such as in the graph x owl inverseof ex p x rdfs subpropertyof owl topobjectproperty note that to some extent the owl 2 rdf-based semantics already covers the use of inverse property expressions by means of the semantic conditions of inverse property axioms see section 5.12 since these semantic conditions also apply to an existential variable on the left hand side of an inverse property axiom. nevertheless not all relevant cases are covered by this semantic condition. for example one might expect the above example graph to be generally true. however the normative semantic conditions do not permit this conclusion since it is not ensured that for every property p there is an individual in the universe with a property extension being inverse to that of p. table 8.6 comprehension conditions for inverse properties if then exists z ir p ip z p iext i owl inverseof 9 appendix changes from owl 1 informative this section lists relevant differences between the owl 2 rdf-based semantics and the original specification of the owl 1 rdf-compatible semantics owl 1 rdf-compatible semantics significant effort has been spent in keeping the design of the owl 2 rdf-based semantics as close as possible to that of the owl 1 rdf-compatible semantics. while this aim was achieved to a large degree the owl 2 rdf-based semantics actually deviates from its predecessor in several aspects. in most cases this is because of serious technical problems that would have arisen from a conservative semantic extension. not listed are the new language constructs and the new datatypes of owl 2. the following markers are used dev a deviation from owl 1 that breaks backward compatibility ext a backward compatible extension to owl 1 nom a change of the nomenclature originally used in owl 1 dpr a feature of owl 1 that has been deprecated as of owl 2 generalized graph syntax ext the owl 2 rdf-based semantics allows rdf graphs to contain iris rfc 3987 see section 2.1 whereas the owl 1 rdf-compatible semantics was restricted to rdf graphs with uris rfc 2396 this change is in accordance with the rest of the owl 2 specification see section 2.4 of the owl 2 structural specification owl 2 specification in addition the owl 2 rdf-based semantics is now explicitly allowed to be applied to rdf graphs containing generalized rdf triples i.e. triples that can consist of iris literals or blank nodes in all three positions section 2.1 although implementations are not required to support this. in contrast the owl 1 rdf-compatible semantics was restricted to rdf graphs conforming to the rdf concepts specification rdf concepts these limitations of the owl 1 rdf-compatible semantics were actually inherited from the rdf semantics specification rdf semantics the relaxations are intended to warrant interoperability with existing and future technologies and tools. both changes are compatible with owl 1 since all rdf graphs that were legal under the owl 1 rdf-compatible semantics are still legal under the owl 2 rdf-based semantics. facets for datatypes ext the basic definitions of a datatype and a d-interpretation as defined by the rdf semantics specification and as applied by the owl 1 rdf-compatible semantics have been extended to take into account constraining facets see section 4 in order to allow for datatype restrictions as specified in section 5.7. this change is compatible with owl 1 since section 5.1 of the rdf semantics specification explicitly allows for extending the minimal datatype definition provided there. correspondence theorem and comprehension conditions dev the semantic conditions of the owl 1 rdf-compatible semantics included a set of so called comprehension conditions which allowed to prove the original correspondence theorem stating that every entailment of owl 1 dl was also an entailment of owl 1 full. the document at hand adds comprehension conditions for the new language constructs of owl 2 see section 8 however the comprehension conditions are not a normative aspect of the owl 2 rdf-based semantics anymore. it has turned out that combining the comprehension conditions with the normative set of semantic conditions in section 5 would lead to formal inconsistency of the resulting semantics issue 119 in addition it became clear that a correspondence theorem along the lines of the original theorem would not work for the relationship between the owl 2 rdf-based semantics and the owl 2 direct semantics owl 2 direct semantics since it is not possible to balance the differences between the two semantics solely by means of additional comprehension conditions see section 7.1 consequently the correspondence theorem of the owl 2 rdf-based semantics section 7.2 follows an alternative approach that replaces the use of the comprehension conditions and can be seen as a technical refinement of an idea originally discussed by the webont working group email this change is an incompatible deviation from owl 1 since certain aspects of the originally normative definition of the semantics have been removed. flawed semantics of language constructs with argument lists dev in the owl 1 rdf-compatible semantics the semantic conditions for unions intersections and enumerations of classes were defined in a flawed form which lead to formal inconsistency of the semantics issue 120 see also this unofficial problem description the affected semantic conditions have been revised see section 5.4 and section 5.5. this change is an incompatible deviation from owl 1 since the semantics has formally been weakened in order to eliminate a source of inconsistency. incomplete semantics of owl alldifferent ext the owl 1 rdf-compatible semantics missed a certain semantic condition for axioms based on the vocabulary term owl alldifferent see also this unofficial problem description the missing semantic condition has been added to the owl 2 rdf-based semantics see section 5.10 this change is compatible with owl 1 since the semantics has been conservatively extended. aligned semantics of owl datarange and rdfs datatype ext the class owl datarange has been made an equivalent class to rdfs datatype see section 5.2 the main purpose for this change was to allow for the deprecation of the term owl datarange in favor of rdfs datatype. this change is compatible with owl 1 according to an uow.acc.tab.analysis of the relationship between the two classes in the owl 1 rdf-compatible semantics email ontology properties as annotation properties ext several properties that have been ontology properties in owl 1 such as owl priorversion have now been specified as both ontology properties and annotation properties in order to be in line with the rest of the owl 2 specification see section 5.5 of the owl 2 structural specification owl 2 specification this change is compatible with owl 1 since the semantics has been conservatively extended all the ontology properties of owl 1 are still ontology properties in owl 2. nonempty data value enumerations dev the semantic condition for enumerations of data values in section 5.5 is now restricted to nonempty sets of data values. this prevents the class owl nothing from unintentionally becoming an instance of the class rdfs datatype as analyzed in email this restriction of the semantics is an incompatible deviation from owl 1. note however that it is still possible to define a datatype as an empty enumeration of data values as explained in section 5.5. terminological clarifications nom this document uses the term owl 2 rdf-based semantics to refer to the specified semantics only. according to section 2.1 the term owl 2 full refers to the language that is determined by the set of all rdf graphs also called owl 2 full ontologies being interpreted using the owl 2 rdf-based semantics. owl 1 has not been particularly clear on this distinction. where the owl 1 rdf-compatible semantics specification talked about owl full interpretations owl full satisfaction owl full consistency and owl full entailment the owl 2 rdf-based semantics specification talks in section 4 about owl 2 rdf-based interpretations owl 2 rdf-based satisfaction owl 2 rdf-based consistency and owl 2 rdf-based entailment respectively since these terms are primarily meant to be related to the semantics rather than the whole language. modified abbreviations nom the names ri pi ci exti cexti si li and lvi which have been used in the owl 1 rdf-compatible semantics specification have been replaced by the corresponding names defined in the rdf semantics document rdf semantics namely ir ip ic iext icext is il and lv respectively. furthermore all uses of the iri mapping is have been replaced by the more general interpretation mapping i following the conventions in the rdf semantics document. these changes are intended to support the use of the owl 2 rdf-based semantics document as an incremental extension of the rdf semantics document. names for the parts of the universe that were exclusively used in the owl 1 rdf-compatible semantics document such as ix or iodp have not been changed. other abbreviations such as iad for the class extension of owl alldifferent have in general not been reused in the document at hand but the explicit nonabbreviated form such as iext i owl alldifferent is used instead. modified tuple notation style nom tuples are written in the form instead of as in the other owl 2 documents. deprecated vocabulary terms dpr the following vocabulary terms have been deprecated as of owl 2 by the working group and should not be used in new ontologies anymore owl datarange per resolution of issue 29 10 appendix change log informative 10.1 changes since recommendation this section summarizes the changes to this document since the recommendation of 27 october 2009. with the publication of the xml schema definition language xsd 1.1 part 2 datatypes recommendation of 5 april 2012 the elements of owl 2 which are based on xsd 1.1 are now considered required and the note detailing the optional dependency on the xsd 1.1 candidate recommendation of 30 april 2009 has been removed from the status of this document section. 10.2 changes since proposed recommendation this section summarizes the changes to this document since the proposed recommendation of 22 september 2009. editorial correction of grammar punctuation word order etc. mainly in the introduction section. editorial updated and corrected several hyperlinks. 10.3 changes since candidate recommendation this section summarizes the changes to this document since the candidate recommendation of 11 june 2009. resolution re-definition of several ontology properties to be both ontology properties and annotation properties in order to align the rdf-based semantics with the rest of the owl 2 specification and in particular to avoid an equivocal definition of the owl 2 rl rdf rules per wg resolution correction correction of the type of facets facets are intended to be data properties and have been used as such elsewhere in the document but they were wrongly specified as unrestricted properties so far. correction correction of a mismatch between the definition of d-interpretations in the document at hand and the rdf semantics specification according to the definition of simple interpretations lv contains all plain literals in the vocabulary v. the missing reference to v has been added. nonnormative correction of an error in the formulation of the correspondence theorem. nonnormative the section on axiomatic triples has been extended by an explicit set of axiomatic triples based on the discussion in the rest of the section. nonnormative the section on axiomatic triples now explicitly mentions axiomatic triples for datatypes and facets corresponding to the semantic conditions for datatypes and facets respectively. nonnormative refinement of the proof for the correspondence theorem and correction of several errors. motivated by these changes the example in section 7.1 has been slightly revised as well. editorial added a description and alt-attribute text to figure 1 on the parts hierarchy. editorial distinction between normative and nonnormative references as in other owl 2 documents. editorial added some clarification to the introduction section. editorial removed a redundant conclusion from the table presenting the semantic conditions for datatype restrictions since this conclusion already follows from the semantic conditions for the vocabulary properties and having the conclusion repeated would not match the general approach that is applied when presenting if-then semantic conditions in this document. editorial reworded the description of the markers in the section on changes from owl 1 and added a marker dpr for the deprecated features. editorial changed the presentation style of references and citations to a form used in all owl 2 documents. editorial changed the presentation style for tuples from to to follow the conventions used in the other owl 2 documents. editorial numerous minor corrections and stylistic improvements. 10.4 changes since last call this section summarizes the changes to this document since the last call working draft of 21 april 2009. resolution renamed the annotation vocabulary terms owl subject owl predicate and owl object to owl annotatedsource owl annotatedproperty and owl annotatedtarget respectively per wg resolution resolution replaced the datatype rdf text by rdf plainliteral per wg resolution resolution replaced the facet rdf langpattern by rdf langrange following the same replacement in the original rdf plainliteral specification. correction changed the range of the property owl annotatedproperty from ip to ir in order to avoid undesired semantic side effects from annotations. this was an oversight when the original semantic conditions for annotations of axioms and annotations were removed from the document. nonnormative the semantic conditions and comprehension conditions for the n-ary property restrictions have been changed to only cover property sequences of length greater than 0 since the meaning of an expression with an empty property set is not clear. editorial explained the optional status of the semantic conditions concerned with the iri owl onproperties in accordance with the rest of the owl 2 specification. editorial shortened and clarified some section titles moved the section on semantic conditions for sub property chains within section 5 and aligned the entry order of all tables in section 8 with those in section 5. editorial several clarifications minor corrections and cosmetic changes. 11 acknowledgments the starting point for the development of owl 2 was the owl1.1 member submission itself a result of user and developer feedback and in particular of information gathered during the owl experiences and directions owled workshop series. the working group also considered postponed issues from the webont working group. this document has been produced by the owl working group see below and its contents reflect extensive discussions within the working group as a whole. the editors extend special thanks to jie bao rpi ivan herman w3c ercim peter f. patel-schneider bell labs research alcatel-lucent and zhe wu oracle corporation for their thorough reviews. the regular attendees at meetings of the owl working group at the time of publication of this document were jie bao rpi diego calvanese free university of bozen-bolzano bernardo cuenca grau oxford university computing laboratory martin dzbor open university achille fokoue ibm corporation christine golbreich universit de versailles st-quentin and lirmm sandro hawke w3c mit ivan herman w3c ercim rinke hoekstra university of amsterdam ian horrocks oxford university computing laboratory elisa kendall sandpiper software markus kr tzsch fzi carsten lutz universit t bremen deborah l. mcguinness rpi boris motik oxford university computing laboratory jeff pan university of aberdeen bijan parsia university of manchester peter f. patel-schneider bell labs research alcatel-lucent sebastian rudolph fzi alan ruttenberg science commons uli sattler university of manchester michael schneider fzi mike smith clark parsia evan wallace nist zhe wu oracle corporation and antoine zimmermann deri galway we would also like to thank past members of the working group jeremy carroll jim hendler and vipul kashyap. 12 references 12.1 normative references owl 2 specification owl 2 web ontology language structural specification and functional-style syntax second edition boris motik peter f. patel-schneider bijan parsia eds. w3c recommendation 11 december 2012 http www.w3.org tr 2012 rec-owl2-syntax-20121211 latest version available at http www.w3.org tr owl2-syntax rdf concepts resource description framework rdf concepts and abstract syntax. graham klyne and jeremy j. carroll eds. w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-rdf-concepts-20040210 latest version available as http www.w3.org tr rdf-concepts rdf semantics rdf semantics. patrick hayes ed. w3c recommendation 10 february 2004 http www.w3.org tr 2004 rec-rdf-mt-20040210 latest version available as http www.w3.org tr rdf-mt rfc 2119 rfc 2119 key words for use in rfcs to indicate requirement levels. network working group s. bradner. ietf march 1997 http www.ietf.org rfc rfc2119.txt rfc 3987 rfc 3987 internationalized resource identifiers iris m. duerst and m. suignard. ietf january 2005 http www.ietf.org rfc rfc3987.txt 12.2 nonnormative references owl 2 direct semantics owl 2 web ontology language direct semantics second edition boris motik peter f. patel-schneider bernardo cuenca grau eds. w3c recommendation 11 december 2012 http www.w3.org tr 2012 rec-owl2-direct-semantics-20121211 latest version available at http www.w3.org tr owl2-direct-semantics owl 2 rdf mapping owl 2 web ontology language mapping to rdf graphs second edition peter f. patel-schneider boris motik eds. w3c recommendation 11 december 2012 http www.w3.org tr 2012 rec-owl2-mapping-to-rdf-20121211 latest version available at http www.w3.org tr owl2-mapping-to-rdf owl 1 rdf-compatible semantics owl web ontology language semantics and abstract syntax section 5. rdf-compatible model-theoretic semantics. peter f. patel-schneider patrick hayes and ian horrocks eds. w3c recommendation 10 february 2004. rfc 2396 rfc 2396 uniform resource identifiers uri generic syntax. t. berners-lee r. fielding u.c. irvine and l. masinter. ietf august 1998. 