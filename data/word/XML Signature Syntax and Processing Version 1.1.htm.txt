xml signature syntax and processing version 1.1 xml signature syntax and processing version 1.1 w3c recommendation 11 april 2013 this version http www.w3.org tr 2013 rec-xmldsig-core1-20130411 latest published version http www.w3.org tr xmldsig-core1 latest editor s draft http www.w3.org 2008 xmlsec drafts xmldsig-core-11 previous version http www.w3.org tr 2013 pr-xmldsig-core1-20130124 editors donald eastlake d3e3e3@gmail.com joseph reagle reagle@mit.edu david solo dsolo@alum.mit.edu frederick hirsch frederick.hirsch@nokia.com 2nd edition 1.1 magnus nystr m mnystrom@microsoft.com 1.1 thomas roessler tlr@w3.org 2nd edition 1.1 kelvin yiu kelviny@microsoft.com 1.1 authors mark bartel mbartel@adobe.com john boyer boyerj@ca.ibm.com barb fox bfox@exchange.microsoft.com brian lamacchia bal@microsoft.com ed simon edsimon@xmlsec.com please refer to the errata for this document which may include some normative corrections. the english version of this specification is the only normative version. non-normative translations may also be available. copyright 2013 the ietf trust w3c mit ercim keio beihang all rights reserved. w3c liability trademark and document use rules apply. abstract this document specifies xml digital signature processing rules and syntax. xml signatures provide integrity message authentication and or signer authentication services for data of any type whether located within the xml that includes the signature or elsewhere. status of this document note on 23 april 2013 the reference to the additional xml security uris rfc was updated. the director previously authorized the publication knowing that the reference would be updated in a near future. this section describes the status of this document at the time of its publication. other documents may supersede this document. a list of current w3c publications and the latest revision of this technical report can be found in the w3c technical reports index at http www.w3.org tr this document has been reviewed by w3c members by software developers and by other w3c groups and interested parties and is endorsed by the director as a w3c recommendation. it is a stable document and may be used as reference material or cited from another document. w3c s role in making the recommendation is to draw attention to the specification and to promote its widespread deployment. this enhances the functionality and interoperability of the web. the original version of this specification was produced by the ietf w3c xml signature working group the interoperability report shows at least 10 implementations with at least two interoperable implementations over every feature. the second edition was produced by the w3c xml security specifications maintenance working group adding canonical xml 1.1 as a required canonicalization algorithm and incorporating known errata. a detailed list of second edition changes is available as is a second edition implementation report demonstrating four or more implementations of all new features. conformance-affecting changes of xml signature 1.1 against this previous recommendation mainly affect the set of mandatory to implement cryptographic algorithms including elliptic curve dsa and mark-up for corresponding key material and additional hash algorithms. a detailed explanation of changes since the last recommendation are available xmldsig-core1-chgs changes are also described in a diff document showing changes since the second edition as well as a diff document showing changes since the previous pr draft. please refer to the implementation report for version 1.1 of this specification for additional details about the implementation status of features added in this revision. this document was published by the xml security working group as a recommendation. if you wish to make comments regarding this document please send them to public-xmlsec@w3.org subscribe archives all comments are welcome. this document was produced by a group operating under the 5 february 2004 w3c patent policy. w3c maintains a public list of any patent disclosures made in connection with the deliverables of the group that page also includes instructions for disclosing a patent. an individual who has actual knowledge of a patent which the individual believes contains essential claim s must disclose the information in accordance with section 6 of the w3c patent policy. additional information related to the ipr status of xml signature 1.1 is available. table of contents 1. introduction 1.1 conformance 1.2 design philosophy 1.3 versions namespaces and identifiers 1.4 acknowledgements 2. signature overview and examples 2.1 simple example signature signedinfo methods and references 2.1.1 more on reference 2.2 extended example object and signatureproperty 2.3 extended example object and manifest 3. processing rules 3.1 signature generation 3.1.1 reference generation 3.1.2 signature generation 3.2 core validation 3.2.1 reference validation 3.2.2 signature validation 4. core signature syntax 4.1 the ds cryptobinary simple type 4.2 the signature element 4.3 the signaturevalue element 4.4 the signedinfo element 4.4.1 the canonicalizationmethod element 4.4.2 the signaturemethod element 4.4.3 the reference element 4.4.3.1 the uri attribute 4.4.3.2 the reference processing model 4.4.3.3 same-document uri-references 4.4.3.4 the transforms element 4.4.3.5 the digestmethod element 4.4.3.6 the digestvalue element 4.5 the keyinfo element 4.5.1 the keyname element 4.5.2 the keyvalue element 4.5.2.1 the dsakeyvalue element 4.5.2.2 the rsakeyvalue element 4.5.2.3 the eckeyvalue element 4.5.2.3.1 explicit curve parameters 4.5.2.3.2 compatibility with rfc 4050 4.5.3 the retrievalmethod element 4.5.4 the x509data element 4.5.4.1 distinguished name encoding rules 4.5.5 the pgpdata element 4.5.6 the spkidata element 4.5.7 the mgmtdata element 4.5.8 xml encryption encryptedkey and derivedkey elements 4.5.9 the derencodedkeyvalue element 4.5.10 the keyinforeference element 4.6 the object element 5. additional signature syntax 5.1 the manifest element 5.2 the signatureproperties element 5.3 processing instructions in signature elements 5.4 comments in signature elements 6. algorithms 6.1 algorithm identifiers and implementation requirements 6.2 message digests 6.2.1 sha-1 6.2.2 sha-224 6.2.3 sha-256 6.2.4 sha-384 6.2.5 sha-512 6.3 message authentication codes 6.3.1 hmac 6.4 signature algorithms 6.4.1 dsa 6.4.2 rsa pkcs#1 v1.5 6.4.3 ecdsa 6.5 canonicalization algorithms 6.5.1 canonical xml 1.0 6.5.2 canonical xml 1.1 6.5.3 exclusive xml canonicalization 1.0 6.6 transform algorithms 6.6.1 canonicalization 6.6.2 base64 6.6.3 xpath filtering 6.6.4 enveloped signature transform 6.6.5 xslt transform 7. xml canonicalization and syntax constraint considerations 7.1 xml 1.0 syntax constraints and canonicalization 7.2 dom sax processing and canonicalization 7.3 namespace context and portable signatures 8. security considerations 8.1 transforms 8.1.1 only what is signed is secure 8.1.2 only what is seen should be signed 8.1.3 see what is signed 8.2 check the security model 8.3 algorithms key lengths certificates etc. 8.4 error messages 9. schema 9.1 xsd schema 9.2 rng schema 10. definitions a. references a.1 normative references a.2 informative references 1. introduction this document specifies xml syntax and processing rules for creating and representing digital signatures. xml signatures can be applied to any digital content data object including xml. an xml signature may be applied to the content of one or more resources. enveloped or enveloping signatures are over data within the same xml document as the signature detached signatures are over data external to the signature element. more specifically this specification defines an xml signature element type and an xml signature application conformance requirements for each are specified by way of schema definitions and prose respectively. this specification also includes other useful types that identify methods for referencing collections of resources algorithms and keying and management information. the xml signature is a method of associating a key with referenced data octets it does not normatively specify how keys are associated with persons or institutions nor the meaning of the data being referenced and signed. consequently while this specification is an important component of secure xml applications it itself is not sufficient to address all application security trust concerns particularly with respect to using signed xml or other data formats as a basis of human-to-human communication and agreement. such an application must specify additional key algorithm processing and rendering requirements. for further information please see see section 8. security considerations. the working group encourages implementers and developers to read xml signature best practices xmldsig-bestpractices it contains a number of best practices related to the use of xml signature including implementation considerations and practical ways of improving security. 1.1 conformance for readability brevity and historic reasons this document uses the term signature to generally refer to digital authentication values of all types. obviously the term is also strictly used to refer to authentication values that are based on public keys and that provide signer authentication. when specifically discussing authentication values based on symmetric secret key codes we use the terms authenticators or authentication codes. see section 8.2 check the security model. this specification provides a normative xml schema xmlschema-1 xmlschema-2 the full normative grammar is defined by the xsd schema and the normative text in this specification. the standalone xsd schema file is authoritative in case there is any disagreement between it and the xsd schema portions in this specification. the key words must must not required shall shall not should should not recommended may and optional in this specification are to be interpreted as described in rfc2119 they must only be used where it is actually required for interoperation or to limit behavior which has potential for causing harm e.g. limiting retransmissions consequently we use these capitalized key words to unambiguously specify requirements over protocol and application features and behavior that affect the interoperability and security of implementations. these key words are not used capitalized to describe xml grammar schema definitions unambiguously describe such requirements and we wish to reserve the prominence of these terms for the natural language descriptions of protocols and features. for instance an xml attribute might be described as being optional. compliance with the namespaces in xml specification xml-names is described as required. this document specifies optional and mandatory to support algorithms providing references for these algorithms. this means that a conformant implementation should for given inputs be able to produce outputs for those algorithms that interoperate as specified in the referenced specification. a conformant implementation may use any technique to achieve the results as-if it were implemented according to the referenced specification but is not required to follow detailed implementation techniques of that specification. 1.2 design philosophy the design philosophy and requirements of this specification are addressed in the original xml-signature requirements document xmldsig-requirements and the xml security 1.1 requirements document xmlsec11-reqs 1.3 versions namespaces and identifiers this specification makes use of xml namespaces and uses uniform resource identifiers uri to identify resources algorithms and semantics. implementations of this specification must use the following xml namespace uris uri namespace prefix xml internal entity http www.w3.org 2000 09 xmldsig# default namespace ds dsig entity dsig http www.w3.org 2000 09 xmldsig# http www.w3.org 2009 xmldsig11# dsig11 entity dsig11 http www.w3.org 2009 xmldsig11# while implementations must support xml and xml namespaces and while use of the above namespace uris is required the namespace prefixes and entity declarations given are merely editorial conventions used in this document. their use by implementations is optional. these namespace uris are also used as the prefix for algorithm identifiers that are under control of this specification. for resources not under the control of this specification we use the designated uniform resource names urn rfc3406 or uniform resource identifiers uri defined by the relevant normative external specification. the http www.w3.org 2000 09 xmldsig# dsig namespace was introduced in the first edition of this specification. this version does not coin any new elements or algorithm identifiers in that namespace instead the http www.w3.org 2009 xmldsig11# dsig11 namespace is used. this specification uses algorithm identifiers in the namespace http www.w3.org 2001 04 xmldsig-more# that were originally coined in rfc6931 rfc 6931 associates these identifiers with specific algorithms. implementations of this specification must be fully interoperable with the algorithms specified in rfc6931 but may compute the requisite values through any technique that leads to the same output. examples of items in various namespaces include signatureproperties is identified and defined by the disg namespace http www.w3.org 2000 09 xmldsig#signatureproperties eckeyvalue is identified and defined by the dsig11 namespace http www.w3.org 2009 xmldsig11#eckeyvalue xslt is identified and defined by an external uri http www.w3.org tr 1999 rec-xslt-19991116 sha1 is identified via this specification s namespace and defined via a normative reference fips-180-3 http www.w3.org 2001 04 xmlenc#sha256 fips pub 180-3. secure hash standard. u.s. department of commerce national institute of standards and technology. no provision is made for an explicit version number in this syntax. if a future version of this specification requires explicit versioning of the document format a different namespace will be used. 1.4 acknowledgements the contributions of the members of the xml signature working group to the first edition specification are gratefully acknowledged mark bartel adobe was accelio author john boyer ibm author mariano p. consens university of waterloo john cowan reuters health donald eastlake 3rd motorola chair author editor barb fox microsoft author christian geuer-pollmann university siegen tom gindin ibm phillip hallam-baker verisign inc richard himes us courts merlin hughes baltimore gregor karlinger iaik tu graz brian lamacchia microsoft author peter lipp iaik tu graz joseph reagle nyu was w3c chair author editor ed simon xmlsec author david solo citigroup author editor petteri stenius capslock raghavan srinivas sun kent tamura ibm winchel todd vincent iii gsu carl wallace corsec security inc. greg whitehead signio inc. as are the first edition last call comments from the following dan connolly w3c paul biron kaiser permanente on behalf of the xml schema wg. martin j. duerst w3c and masahiro sekiguchi fujitsu on behalf of the internationalization wg ig. jonathan marsh microsoft on behalf of the extensible stylesheet language wg. the following members of the xml security specification maintenance working group contributed to the second edition juan carlos cruellas universitat polit cnica de catalunya pratik datta oracle corporation phillip hallam-baker verisign inc. frederick hirsch nokia chair editor konrad lanz applied information processing and kommunications iaik hal lockhart bea systems inc. robert miller mitre corporation sean mullan sun microsystems inc. bruce rich ibm corporation thomas roessler w3c ercim staff contact editor ed simon w3c invited expert greg whitehead hp. contributions for version 1.1 were received from the members of the xml security working group scott cantor juan carlos cruellas pratik datta gerald edgar ken graf phillip hallam-baker brad hill frederick hirsch chair editor brian lamacchia konrad lanz hal lockhart cynthia martin rob miller sean mullan shivaram mysore magnus nystr m bruce rich thomas roessler staff contact editor ed simon chris solc john wray kelvin yiu editor the working group thanks makoto murata for assistance with the relax ng schemas. 2. signature overview and examples this section provides an overview and examples of xml digital signature syntax. the specific processing is given in section 3. processing rules. the formal syntax is found in section 4. core signature syntax and section 5. additional signature syntax. in this section an informal representation and examples are used to describe the structure of the xml signature syntax. this representation and examples may omit attributes details and potential features that are fully explained later. xml signatures are applied to arbitrary digital content data objects via an indirection. data objects are digested the resulting value is placed in an element with other information and that element is then digested and cryptographically signed. xml digital signatures are represented by the signature element which has the following structure where denotes zero or one occurrence denotes one or more occurrences and denotes zero or more occurrences example 1 signature id signedinfo canonicalizationmethod signaturemethod reference uri transforms digestmethod digestvalue reference signedinfo signaturevalue keyinfo object id signature signatures are related to data objects via uris uri within an xml document signatures are related to local data objects via fragment identifiers. such local data can be included within an enveloping signature or can enclose an enveloped signature. detached signatures are over external network resources or local data objects that reside within the same xml document as sibling elements in this case the signature is neither enveloping signature is parent nor enveloped signature is child since a signature element and its id attribute value name may co-exist or be combined with other elements and their ids within a single xml document care should be taken in choosing names such that there are no subsequent collisions that violate the id uniqueness validity constraint xml10 2.1 simple example signature signedinfo methods and references the following example is a detached signature of the content of the html4 in xml specification. example 2 s01 signature id myfirstsignature xmlns http www.w3.org 2000 09 xmldsig# s02 signedinfo s03 canonicalizationmethod algorithm http www.w3.org 2006 12 xml-c14n11 s04 signaturemethod algorithm http www.w3.org 2001 04 xmldsig-more#rsa-sha256 s05 reference uri http www.w3.org tr 2000 rec-xhtml1-20000126 s06 transforms s07 transform algorithm http www.w3.org 2006 12 xml-c14n11 s08 transforms s09 digestmethod algorithm http www.w3.org 2001 04 xmlenc#sha256 s10 digestvalue dghpcybpcybub3qgysbzawduyxr1cmuk... digestvalue s11 reference s12 signedinfo s13 signaturevalue signaturevalue s14 keyinfo s15a keyvalue s15b dsakeyvalue s15c p p q q g g y y s15d dsakeyvalue s15e keyvalue s16 keyinfo s17 signature s02-12 the required signedinfo element is the information that is actually signed. core validation of signedinfo consists of two mandatory processes validation of the signature over signedinfo and validation of each reference digest within signedinfo. note that the algorithms used in calculating the signaturevalue are also included in the signed information while the signaturevalue element is outside signedinfo. s03 the canonicalizationmethod is the algorithm that is used to canonicalize the signedinfo element before it is digested as part of the signature operation. note that this example is not in canonical form. none of the examples in this specification are in canonical form. s04 the signaturemethod is the algorithm that is used to convert the canonicalized signedinfo into the signaturevalue. it is a combination of a digest algorithm and a key dependent algorithm and possibly other algorithms such as padding for example rsa-sha1. the algorithm names are signed to resist attacks based on substituting a weaker algorithm. to promote application interoperability we specify a set of signature algorithms that must be implemented though their use is at the discretion of the signature creator. we specify additional algorithms as recommended or optional for implementation the design also permits arbitrary user specified algorithms. s05-11 each reference element includes the digest method and resulting digest value calculated over the identified data object. it also may include transformations that produced the input to the digest operation. a data object is signed by computing its digest value and a signature over that value. the signature is later checked via reference and signature validation. s14-16 keyinfo indicates the key to be used to validate the signature. possible forms for identification include certificates key names and key agreement algorithms and information we define only a few. keyinfo is optional for two reasons. first the signer may not wish to reveal key information to all document processing parties. second the information may be known within the application s context and need not be represented explicitly. since keyinfo is outside of signedinfo if the signer wishes to bind the keying information to the signature a reference can easily identify and include the keyinfo as part of the signature. use of keyinfo is optional however note that senders and receivers must agree on how it will be used through a mechanism out of scope for this specification. 2.1.1 more on reference example 3 s05 reference uri http www.w3.org tr 2000 rec-xhtml1-20000126 s06 transforms s07 transform algorithm http www.w3.org 2006 12 xml-c14n11 s08 transforms s09 digestmethod algorithm http www.w3.org 2001 04 xmlenc#sha256 s10 digestvalue dghpcybpcybub3qgysbzawduyxr1cmuk... digestvalue s11 reference s05 the optional uri attribute of reference identifies the data object to be signed. this attribute may be omitted on at most one reference in a signature. this limitation is imposed in order to ensure that references and objects may be matched unambiguously. s05-08 this identification along with the transforms is a description provided by the signer on how they obtained the signed data object in the form it was digested i.e. the digested content the verifier may obtain the digested content in another method so long as the digest verifies. in particular the verifier may obtain the content from a different location such as a local store than that specified in the uri. s06-08 transforms is an optional ordered list of processing steps that were applied to the resource s content before it was digested. transforms can include operations such as canonicalization encoding decoding including compression inflation xslt xpath xml schema validation or xinclude. xpath transforms permit the signer to derive an xml document that omits portions of the source document. consequently those excluded portions can change without affecting signature validity. for example if the resource being signed encloses the signature itself such a transform must be used to exclude the signature value from its own computation. if no transforms element is present the resource s content is digested directly. while the working group has specified mandatory and optional canonicalization and decoding algorithms user specified transforms are permitted. s09-10 digestmethod is the algorithm applied to the data after transforms is applied if specified to yield the digestvalue. the signing of the digestvalue is what binds the content of a resource to the signer s key. 2.2 extended example object and signatureproperty this specification does not address mechanisms for making statements or assertions. instead this document defines what it means for something to be signed by an xml signature integrity message authentication and or signer authentication applications that wish to represent other semantics must rely upon other technologies such as xml10 rdf-primer for instance an application might use a foo assuredby attribute within its own markup to reference a signature element. consequently it s the application that must understand and know how to make trust decisions given the validity of the signature and the meaning of assuredby syntax. we also define a signatureproperties element type for the inclusion of assertions about the signature itself e.g. signature semantics the time of signing or the serial number of hardware used in cryptographic processes such assertions may be signed by including a reference for the signatureproperties in signedinfo. while the signing application should be very careful about what it signs it should understand what is in the signatureproperty a receiving application has no obligation to understand that semantic though its parent trust engine may wish to any content about the signature generation may be located within the signatureproperty element. the mandatory target attribute references the signature element to which the property applies. consider the preceding example with an additional reference to a local object that includes a signatureproperty element. such a signature would not only be detached p02 but enveloping p03 example 4 signature id mysecondsignature p01 signedinfo p02 reference uri http www.w3.org tr xml-stylesheet p03 reference uri amadeuptimestamp p04 type http www.w3.org 2000 09 xmldsig#signatureproperties p05 transforms p06 transform algorithm http www.w3.org 2006 12 xml-c14n11 p07 transforms p08 digestmethod algorithm http www.w3.org 2001 04 xmlenc#sha256 p09 digestvalue dghpcybpcybub3qgysbzawduyxr1cmuk... digestvalue p10 reference p11 signedinfo p12 p13 object p14 signatureproperties p15 signatureproperty id amadeuptimestamp target mysecondsignature p16 timestamp xmlns http www.ietf.org rfcxxxx.txt p17 date 19990914 date p18 time 14 34 34 34 time p19 timestamp p20 signatureproperty p21 signatureproperties p22 object p23 signature p04 the optional type attribute of reference provides information about the resource identified by the uri. in particular it can indicate that it is an object signatureproperty or manifest element. this can be used by applications to initiate special processing of some reference elements. references to an xml data element within an object element should identify the actual element pointed to. where the element content is not xml perhaps it is binary or encoded data the reference should identify the object and the reference type if given should indicate object. note that type is advisory and no action based on it or checking of its correctness is required by core behavior. p13 object is an optional element for including data objects within the signature element or elsewhere. the object can be optionally typed and or encoded. p14-21 signature properties such as time of signing can be optionally signed by identifying them from within a reference. these properties are traditionally called signature attributes although that term has no relationship to the xml term attribute 2.3 extended example object and manifest the manifest element is provided to meet additional requirements not directly addressed by the mandatory parts of this specification. two requirements and the way the manifest satisfies them follow. first applications frequently need to efficiently sign multiple data objects even where the signature operation itself is an expensive public key signature. this requirement can be met by including multiple reference elements within signedinfo since the inclusion of each digest secures the data digested. however some applications may not want the core validation behavior associated with this approach because it requires every reference within signedinfo to undergo reference validation the digestvalue elements are checked. these applications may wish to reserve reference validation decision logic to themselves. for example an application might receive a signature valid signedinfo element that includes three reference elements. if a single reference fails the identified data object when digested does not yield the specified digestvalue the signature would fail core validation. however the application may wish to treat the signature over the two valid reference elements as valid or take different actions depending on which fails. to accomplish this signedinfo would reference a manifest element that contains one or more reference elements with the same structure as those in signedinfo then reference validation of the manifest is under application control. second consider an application where many signatures using different keys are applied to a large number of documents. an inefficient solution is to have a separate signature per key repeatedly applied to a large signedinfo element with many references this is wasteful and redundant. a more efficient solution is to include many references in a single manifest that is then referenced from multiple signature elements. the example below includes a reference that signs a manifest found within the object element. example 5 m01 reference uri myfirstmanifest m02 type http www.w3.org 2000 09 xmldsig#manifest m03 transforms m04 transform algorithm http www.w3.org 2006 12 xml-c14n11 m05 transforms m06 digestmethod algorithm http www.w3.org 2001 04 xmlenc#sha256 m07 digestvalue dghpcybpcybub3qgysbzawduyxr1cmuk... digestvalue m08 reference m09 object m10 manifest id myfirstmanifest m11 reference m12 m13 reference m14 reference m15 m16 reference m17 manifest m18 object 3. processing rules the sections below describe the operations to be performed as part of signature generation and validation. 3.1 signature generation the required steps include the generation of reference elements and the signaturevalue over signedinfo. 3.1.1 reference generation for each data object being signed apply the transforms as determined by the application to the data object. calculate the digest value over the resulting data object. create a reference element including the optional identification of the data object any optional transform elements the digest algorithm and the digestvalue. note it is the canonical form of these references that are signed in section 3.1.2 signature generation and validated in section 3.2.1 reference validation. the reference processing model section 4.4.3.2 the reference processing model requires use of canonical xml 1.0 xml-c14n as default processing behavior when a transformation is expecting an octet-stream but the data object resulting from uri dereferencing or from the previous transformation in the list of transform elements is a node-set. we recommend that when generating signatures signature applications do not rely on this default behavior but explicitly identify the transformation that is applied to perform this mapping. in cases in which inclusive canonicalization is desired we recommend that canonical xml 1.1 xml-c14n11 be used. 3.1.2 signature generation create signedinfo element with signaturemethod canonicalizationmethod and reference s canonicalize and then calculate the signaturevalue over signedinfo based on algorithms specified in signedinfo. construct the signature element that includes signedinfo object s if desired encoding may be different than that used for signing keyinfo if required and signaturevalue. note if the signature includes same-document references xml10 or xmlschema-1 xmlschema-2 validation of the document might introduce changes that break the signature. consequently applications should be careful to consistently process the document or refrain from using external contributions e.g. defaults and entities 3.2 core validation the required steps of core validation include 1 reference validation the verification of the digest contained in each reference in signedinfo and 2 the cryptographic signature validation of the signature calculated over signedinfo. note there may be valid signatures that some signature applications are unable to validate. reasons for this include failure to implement optional parts of this specification inability or unwillingness to execute specified algorithms or inability or unwillingness to dereference specified uris some uri schemes may cause undesirable side effects etc. comparison of each value in reference and signature validation is over the numeric e.g. integer or decoded octet sequence of the value. different implementations may produce different encoded digest and signature values when processing the same resources because of variances in their encoding such as accidental white space. but if one uses numeric or octet comparison choose one on both the stated and computed values these problems are eliminated. 3.2.1 reference validation canonicalize the signedinfo element based on the canonicalizationmethod in signedinfo. for each reference in signedinfo obtain the data object to be digested. for example the signature application may dereference the uri and execute transforms provided by the signer in the reference element or it may obtain the content through other means such as a local cache. digest the resulting data object using the digestmethod specified in its reference specification. compare the generated digest value against digestvalue in the signedinfo reference if there is any mismatch validation fails. note signedinfo is canonicalized in step 1. the application must ensure that the canonicalizationmethod has no dangerous side effects such as rewriting uris see note on canonicalization method and that it sees what is signed which is the canonical form. note after a signature element has been created in signature generation for a signature with a same document reference an implementation can serialize the xml content with variations in that serialization. this means that reference validation needs to canonicalize the xml document before digesting in step 1 to avoid issues related to variations in serialization. 3.2.2 signature validation obtain the keying information from keyinfo or from an external source. obtain the canonical form of the signaturemethod using the canonicalizationmethod and use the result and previously obtained keyinfo to confirm the signaturevalue over the signedinfo element. note keyinfo or some transformed version thereof may be signed via a reference element. transformation and validation of this reference 3.2.1 is orthogonal to signature validation which uses the keyinfo as parsed. additionally the signaturemethod uri may have been altered by the canonicalization of signedinfo e.g. absolutization of relative uris and it is the canonical form that must be used. however the required canonicalization xml-c14n of this specification does not change uris. 4. core signature syntax the general structure of an xml signature is described in section 2. signature overview and examples. this section provides detailed syntax of the core signature features. features described in this section are mandatory to implement unless otherwise indicated. the syntax is defined via an xmlschema-1 xmlschema-2 with the following xml preamble declaration and internal entity. schema definition xml version 1.0 encoding utf-8 doctype schema public w3c dtd xmlschema 200102 en attlist schema xmlns ds cdata fixed http www.w3.org 2000 09 xmldsig# entity dsig http www.w3.org 2000 09 xmldsig# entity p entity s schema xmlns http www.w3.org 2001 xmlschema xmlns ds http www.w3.org 2000 09 xmldsig# targetnamespace http www.w3.org 2000 09 xmldsig# version 0.1 elementformdefault qualified additional markup defined in version 1.1 of this specification uses the dsig11 namespace. the syntax is defined in an xml schema with the following preamble schema definition xml version 1.0 encoding utf-8 doctype schema public w3c dtd xmlschema 200102 en entity dsig http www.w3.org 2000 09 xmldsig# entity dsig11 http www.w3.org 2009 xmldsig11# entity p entity s schema xmlns http www.w3.org 2001 xmlschema xmlns ds http www.w3.org 2000 09 xmldsig# xmlns dsig11 http www.w3.org 2009 xmldsig11# targetnamespace http www.w3.org 2009 xmldsig11# version 0.1 elementformdefault qualified 4.1 the ds cryptobinary simple type this specification defines the ds cryptobinary simple type for representing arbitrary-length integers e.g. bignums in xml as octet strings. the integer value is first converted to a big endian bitstring. the bitstring is then padded with leading zero bits so that the total number of bits 0 mod 8 so that there are an integral number of octets if the bitstring contains entire leading octets that are zero these are removed so the high-order octet is always non-zero this octet string is then base64 rfc2045 encoded. the conversion from integer to octet string is equivalent to ieee 1363 s i2osp ieee1363 with minimal length this type is used by bignum values such as rsakeyvalue and dsakeyvalue. if a value can be of type base64binary or ds cryptobinary they are defined as base64binary. for example if the signature algorithm is rsa or dsa then signaturevalue represents a bignum and could be ds cryptobinary. however if hmac-sha1 is the signature algorithm then signaturevalue could have leading zero octets that must be preserved. thus signaturevalue is generically defined as of type base64binary. schema definition simpletype name cryptobinary restriction base base64binary simpletype 4.2 the signature element the signature element is the root element of an xml signature. implementation must generate laxly schema valid xmlschema-1 xmlschema-2 signature elements as specified by the following schema schema definition element name signature type ds signaturetype complextype name signaturetype sequence element ref ds signedinfo element ref ds signaturevalue element ref ds keyinfo minoccurs 0 element ref ds object minoccurs 0 maxoccurs unbounded sequence attribute name id type id use optional complextype 4.3 the signaturevalue element the signaturevalue element contains the actual value of the digital signature it is always encoded using base64 rfc2045 schema definition element name signaturevalue type ds signaturevaluetype complextype name signaturevaluetype simplecontent extension base base64binary attribute name id type id use optional extension simplecontent complextype 4.4 the signedinfo element the structure of signedinfo includes the canonicalization algorithm a signature algorithm and one or more references. the signedinfo element may contain an optional id attribute that will allow it to be referenced by other signatures and objects. signedinfo does not include explicit signature or digest properties such as calculation time cryptographic device serial number etc. if an application needs to associate properties with the signature or digest it may include such information in a signatureproperties element within an object element. schema definition element name signedinfo type ds signedinfotype complextype name signedinfotype sequence element ref ds canonicalizationmethod element ref ds signaturemethod element ref ds reference maxoccurs unbounded sequence attribute name id type id use optional complextype 4.4.1 the canonicalizationmethod element canonicalizationmethod is a required element that specifies the canonicalization algorithm applied to the signedinfo element prior to performing signature calculations. this element uses the general structure for algorithms described in section 6.1 algorithm identifiers and implementation requirements. implementations must support the required canonicalization algorithms. alternatives to the required canonicalization algorithms section 6.5 such as canonical xml with comments section 6.5.1 or a minimal canonicalization such as crlf and charset normalization may be explicitly specified but are not required. consequently their use may not interoperate with other applications that do not support the specified algorithm see xml canonicalization and syntax constraint considerations section 7 security issues may also arise in the treatment of entity processing and comments if non-xml aware canonicalization algorithms are not properly constrained see section 8.1.2 only what is seen should be signed the way in which the signedinfo element is presented to the canonicalization method is dependent on that method. the following applies to algorithms which process xml as nodes or characters xml based canonicalization implementations must be provided with an xpath node-set originally formed from the document containing the signedinfo and currently indicating the signedinfo its descendants and the attribute and namespace nodes of signedinfo and its descendant elements. text based canonicalization algorithms such as crlf and charset normalization should be provided with the utf-8 octets that represent the well-formed signedinfo element from the first character to the last character of the xml representation inclusive. this includes the entire text of the start and end tags of the signedinfo element as well as all descendant markup and character data i.e. the text between those tags. use of text based canonicalization of signedinfo is not recommended. we recommend applications that implement a text-based instead of xml-based canonicalization such as resource constrained apps generate canonicalized xml as their output serialization so as to mitigate interoperability and security concerns. for instance such an implementation should at least generate standalone xml instances xml10 note the signature application must exercise great care in accepting and executing an arbitrary canonicalizationmethod. for example the canonicalization method could rewrite the uris of the references being validated. or the method could massively transform signedinfo so that validation would always succeed i.e. converting it to a trivial signature with a known key over trivial data since canonicalizationmethod is inside signedinfo in the resulting canonical form it could erase itself from signedinfo or modify the signedinfo element so that it appears that a different canonicalization function was used thus a signature which appears to authenticate the desired data with the desired key digestmethod and signaturemethod can be meaningless if a capricious canonicalizationmethod is used. schema definition element name canonicalizationmethod type ds canonicalizationmethodtype complextype name canonicalizationmethodtype mixed true sequence any namespace any minoccurs 0 maxoccurs unbounded 0 unbounded elements from 1,1 namespace sequence attribute name algorithm type anyuri use required complextype 4.4.2 the signaturemethod element signaturemethod is a required element that specifies the algorithm used for signature generation and validation. this algorithm identifies all cryptographic functions involved in the signature operation e.g. hashing public key algorithms macs padding etc. this element uses the general structure here for algorithms described in section 6.1 algorithm identifiers and implementation requirements. while there is a single identifier that identifier may specify a format containing multiple distinct signature values. schema definition element name signaturemethod type ds signaturemethodtype complextype name signaturemethodtype mixed true sequence element name hmacoutputlength minoccurs 0 type ds hmacoutputlengthtype any namespace other minoccurs 0 maxoccurs unbounded 0 unbounded elements from 1,1 external namespace sequence attribute name algorithm type anyuri use required complextype the ds hmacoutputlength parameter is used for hmac hmac algorithms. the parameter specifies a truncation length in bits. if this parameter is trusted without further verification then this can lead to a security bypass cve-2009-0217 signatures must be deemed invalid if the truncation length is below the larger of a half the underlying hash algorithm s output length and b 80 bits. note that some implementations are known to not accept truncation lengths that are lower than the underlying hash algorithm s output length. 4.4.3 the reference element reference is an element that may occur one or more times. it specifies a digest algorithm and digest value and optionally an identifier of the object being signed the type of the object and or a list of transforms to be applied prior to digesting. the identification uri and transforms describe how the digested content i.e. the input to the digest method was created. the type attribute facilitates the processing of referenced data. for example while this specification makes no requirements over external data an application may wish to signal that the referent is a manifest. an optional id attribute permits a reference to be referenced from elsewhere. schema definition element name reference type ds referencetype complextype name referencetype sequence element ref ds transforms minoccurs 0 element ref ds digestmethod element ref ds digestvalue sequence attribute name id type id use optional attribute name uri type anyuri use optional attribute name type type anyuri use optional complextype 4.4.3.1 the uri attribute the uri attribute identifies a data object using a uri-reference uri the mapping from this attribute s value to a uri reference must be performed as specified in section 3.2.17 of xmlschema-2 additionally some existing implementations are known to verify the value of the uri attribute against the grammar in uri it is therefore safest to perform any necessary escaping while generating the uri attribute. we recommend xml signature applications be able to dereference uris in the http scheme. dereferencing a uri in the http scheme must comply with the status code definitions of http11 e.g. 302 305 and 307 redirects are followed to obtain the entity-body of a 200 status code response applications should also be cognizant of the fact that protocol parameter and state information such as http cookies html device profiles or content negotiation may affect the content yielded by dereferencing a uri. if a resource is identified by more than one uri the most specific should be used e.g. http www.w3.org 2000 06 interop-pressrelease.html.en instead of http www.w3.org 2000 06 interop-pressrelease see section 3.2 core validation for further information on reference processing. if the uri attribute is omitted altogether the receiving application is expected to know the identity of the object. for example a lightweight data protocol might omit this attribute given the identity of the object is part of the application context. this attribute may be omitted from at most one reference in any particular signedinfo or manifest. the optional type attribute contains information about the type of object being signed after all ds reference transforms have been applied. this is represented as a uri. for example type http www.w3.org 2000 09 xmldsig#object type http www.w3.org 2000 09 xmldsig#manifest the type attribute applies to the item being pointed at not its contents. for example a reference that results in the digesting of an object element containing a signatureproperties element is still of type object. the type attribute is advisory. no validation of the type information is required by this specification. 4.4.3.2 the reference processing model note xpath is recommended. signature applications need not conform to xpath specification in order to conform to this specification. however the xpath data model definitions e.g. node-sets and syntax is used within this document in order to describe functionality for those that want to process xml-as-xml instead of octets as part of signature generation. for those that want to use these features a conformant xpath implementation is one way to implement these features but it is not required. such applications could use a sufficiently functional replacement to a node-set and implement only those xpath expression behaviors required by this specification. however for simplicity we generally will use xpath terminology without including this qualification on every point. requirements over xpath node-sets can include a node-set functional equivalent. requirements over xpath processing can include application behaviors that are equivalent to the corresponding xpath behavior. the data-type of the result of uri dereferencing or subsequent transforms is either an octet stream or an xpath node-set. the transforms specified in this document are defined with respect to the input they require. the following is the default signature application behavior if the data object is an octet stream and the next transform requires a node-set the signature application must attempt to parse the octets yielding the required node-set via xml10 well-formed processing. if the data object is a node-set and the next transform requires octets the signature application must attempt to convert the node-set to an octet stream using canonical xml xml-c14n users may specify alternative transforms that override these defaults in transitions between transforms that expect different inputs. the final octet stream contains the data octets being secured. the digest algorithm specified by digestmethod is then applied to these data octets resulting in the digestvalue. note the section 3.1.1 reference generation includes further restrictions on the reliance upon defined default transformations when applications generate signatures. in this specification a same-document reference is defined as a uri-reference that consists of a hash sign followed by a fragment or alternatively consists of an empty uri uri unless the uri-reference is such a same-document reference the result of dereferencing the uri-reference must be an octet stream. in particular an xml document identified by uri is not parsed by the signature application unless the uri is a same-document reference or unless a transform that requires xml parsing is applied. see transforms section 4.4.3.4 when a fragment is preceded by an absolute or relative uri in the uri-reference the meaning of the fragment is defined by the resource s mime type rfc2045 even for xml documents uri dereferencing including the fragment processing might be done for the signature application by a proxy. therefore reference validation might fail if fragment processing is not performed in a standard way as defined in the following section for same-document references consequently we recommend in this case that the uri attribute not include fragment identifiers and that such processing be specified as an additional xpath transform or xpath filter 2 transform xmldsig-xpath-filter2 when a fragment is not preceded by a uri in the uri-reference xml signature applications must support the null uri and shortname xpointer xptr-framework we recommend support for the same-document xpointers xpointer and xpointer id id if the application also intends to support any canonicalization that preserves comments. otherwise uri foo will automatically remove comments before the canonicalization can even be invoked due to the processing defined in same-document uri-references section 4.4.3.3 all other support for xpointers is optional especially all support for shortname and other xpointers in external resources since the application may not have control over how the fragment is generated leading to interoperability problems and validation failures xpointer must be interpreted to identify the root node xpath of the document that contains the uri attribute. xpointer id id must be interpreted to identify the element node identified by element id xptr-element when evaluated with respect to the document that contains the uri attribute. the original edition of this specification xmldsig-core referenced the xpointer candidate recommendation xptr-xpointer-cr2001 and some implementations support it optionally. that candidate recommendation has been superseded by the xptr-framework xptr-xmlns and xptr-element recommendations and at the time of this edition the xptr-xpointer working draft. therefore the use of the xpointer scheme xptr-xpointer beyond the usage discussed in this section is discouraged. the following examples demonstrate what the uri attribute identifies and how it is dereferenced uri http example.com bar.xml identifies the octets that represent the external resource http example.com bar.xml that is probably an xml document given its file extension. uri http example.com bar.xml#chapter1 identifies the element with id attribute value chapter1 of the external xml resource http example.com bar.xml provided as an octet stream. again for the sake of interoperability the element identified as chapter1 should be obtained using an xpath transform rather than a uri fragment shortname xpointer resolution in external resources is not required in this specification uri identifies the node-set minus any comment nodes of the xml resource containing the signature uri chapter1 identifies a node-set containing the element with id attribute value chapter1 of the xml resource containing the signature. xml signature and its applications modify this node-set to include the element plus all descendants including namespaces and attributes but not comments. 4.4.3.3 same-document uri-references dereferencing a same-document reference must result in an xpath node-set suitable for use by canonical xml xml-c14n specifically dereferencing a null uri uri must result in an xpath node-set that includes every non-comment node of the xml document containing the uri attribute. in a fragment uri the characters after the number sign character conform to the xpointer syntax xptr-framework when processing an xpointer the application must behave as if the xpointer was evaluated with respect to the xml document containing the uri attribute the application must behave as if the result of xpointer processing xptr-framework were a node-set derived from the resultant subresource as follows include xpath nodes having full or partial content within the subresource replace the root node with its children if it is in the node-set replace any element node e with e plus all descendants of e text comment pi element and all namespace and attribute nodes of e and its descendant elements. if the uri has no fragment identifier or the fragment identifier is a shortname xpointer then delete all comment nodes the second to last replacement is necessary because xpointer typically indicates a subtree of an xml document s parse tree using just the element node at the root of the subtree whereas canonical xml treats a node-set as a set of nodes in which absence of descendant nodes results in absence of their representative text from the canonical form. the last step is performed for null uris and shortname xpointers it is necessary because when xml-c14n or xml-c14n11 is passed a node-set it processes the node-set as is with or without comments. only when it is called with an octet stream does it invoke its own xpath expressions default or without comments therefore to retain the default behavior of stripping comments when passed a node-set they are removed in the last step if the uri is not a scheme-based xpointer. to retain comments while selecting an element by an identifier id use the following scheme-based xpointer uri xpointer id id to retain comments while selecting the entire document use the following scheme-based xpointer uri xpointer the interpretation of these xpointers is defined in the reference processing model section 4.4.3.2 4.4.3.4 the transforms element the optional transforms element contains an ordered list of transform elements these describe how the signer obtained the data object that was digested. the output of each transform serves as input to the next transform. the input to the first transform is the result of dereferencing the uri attribute of the reference element. the output from the last transform is the input for the digestmethod algorithm. when transforms are applied the signer is not signing the native original document but the resulting transformed document. see only what is signed is secure section 8.1.1 each transform consists of an algorithm attribute and content parameters if any appropriate for the given algorithm. the algorithm attribute value specifies the name of the algorithm to be performed and the transform content provides additional data to govern the algorithm s processing of the transform input. see section 6.1 algorithm identifiers and implementation requirements as described in the reference processing model section 4.4.3.2 some transforms take an xpath node-set as input while others require an octet stream. if the actual input matches the input needs of the transform then the transform operates on the unaltered input. if the transform input requirement differs from the format of the actual input then the input must be converted. some transforms may require explicit mime type charset iana registered character set or other such information concerning the data they are receiving from an earlier transform or the source data although no transform algorithm specified in this document needs such explicit information. such data characteristics are provided as parameters to the transform algorithm and should be described in the specification for the algorithm. examples of transforms include but are not limited to base64 decoding rfc2045 canonicalization xml-c14n xpath filtering xpath and xslt xslt the generic definition of the transform element also allows application-specific transform algorithms. for example the transform could be a decompression routine given by a java class appearing as a base64 encoded parameter to a java transform algorithm. however applications should refrain from using application-specific transforms if they wish their signatures to be verifiable outside of their application domain. transform algorithms section 6.6 defines the list of standard transformations. schema definition element name transforms type ds transformstype complextype name transformstype sequence element ref ds transform maxoccurs unbounded sequence complextype element name transform type ds transformtype complextype name transformtype mixed true choice minoccurs 0 maxoccurs unbounded any namespace other processcontents lax 1,1 elements from 0 unbounded namespaces element name xpath type string choice attribute name algorithm type anyuri use required complextype 4.4.3.5 the digestmethod element digestmethod is a required element that identifies the digest algorithm to be applied to the signed object. this element uses the general structure here for algorithms specified in section 6.1 algorithm identifiers and implementation requirements. if the result of the uri dereference and application of transforms is an xpath node-set or sufficiently functional replacement implemented by the application then it must be converted as described in section 4.4.3.2 the reference processing model. if the result of uri dereference and application of transforms is an octet stream then no conversion occurs comments might be present if the canonical xml with comments was specified in the transforms the digest algorithm is applied to the data octets of the resulting octet stream. schema definition element name digestmethod type ds digestmethodtype complextype name digestmethodtype mixed true sequence any namespace other processcontents lax minoccurs 0 maxoccurs unbounded sequence attribute name algorithm type anyuri use required complextype 4.4.3.6 the digestvalue element digestvalue is an element that contains the encoded value of the digest. the digest is always encoded using base64 rfc2045 schema definition element name digestvalue type ds digestvaluetype simpletype name digestvaluetype restriction base base64binary simpletype 4.5 the keyinfo element keyinfo is an optional element that enables the recipient s to obtain the key needed to validate the signature. keyinfo may contain keys names certificates and other public key management information such as in-band key distribution or key agreement data. this specification defines a few simple types but applications may extend those types or all together replace them with their own key identification and exchange semantics using the xml namespace facility xml-names however questions of trust of such key information e.g. its authenticity or strength are out of scope of this specification and left to the application. details of the structure and usage of element children of keyinfo other than simple types described in this specification are out of scope. for example the definition of pki certificate contents certificate ordering certificate revocation and crl management are out of scope. if keyinfo is omitted the recipient is expected to be able to identify the key based on application context. multiple declarations within keyinfo refer to the same key. while applications may define and use any mechanism they choose through inclusion of elements from a different namespace compliant versions must implement keyvalue section 4.5.2 the keyvalue element and should implement keyinforeference section 4.5.10 the keyinforeference element keyinforeference is preferred over use of retrievalmethod as it avoids use of transform child elements that introduce security risk and implementation challenges. support for other children of keyinfo is optional. the schema specification of many of keyinfo s children e.g. pgpdata spkidata x509data permit their content to be extended complemented with elements from another namespace. this may be done only if it is safe to ignore these extension elements while claiming support for the types defined in this specification. otherwise external elements including alternative structures to those defined by this specification must be a child of keyinfo. for example should a complete xml-pgp standard be defined its root element must be a child of keyinfo. of course new structures from external namespaces can incorporate elements from the dsig namespace via features of the type definition language. for instance they can create a schema that permits includes imports or derives new types based on dsig elements. the following list summarizes the keyinfo types that are allocated an identifier in the dsig namespace these can be used within the retrievalmethod type attribute to describe a remote keyinfo structure. http www.w3.org 2000 09 xmldsig#dsakeyvalue http www.w3.org 2000 09 xmldsig#rsakeyvalue http www.w3.org 2000 09 xmldsig#x509data http www.w3.org 2000 09 xmldsig#pgpdata http www.w3.org 2000 09 xmldsig#spkidata http www.w3.org 2000 09 xmldsig#mgmtdata the following list summarizes the additional keyinfo types that are allocated an identifier in the dsig11 namespace. http www.w3.org 2009 xmldsig11#eckeyvalue http www.w3.org 2009 xmldsig11#derencodedkeyvalue in addition to the types above for which we define an xml structure we specify one additional type to indicate a binary asn.1 der x.509 certificate. http www.w3.org 2000 09 xmldsig#rawx509certificate schema definition element name keyinfo type ds keyinfotype complextype name keyinfotype mixed true choice maxoccurs unbounded element ref ds keyname element ref ds keyvalue element ref ds retrievalmethod element ref ds x509data element ref ds pgpdata element ref ds spkidata element ref ds mgmtdata element ref dsig11 derencodedkeyvalue derencodedkeyvalue xmldsig 1.1 will use the any element element ref dsig11 keyinforeference keyinforeference xmldsig 1.1 will use the any element element ref xenc encryptedkey encryptedkey xmlenc will use the any element element ref xenc agreement agreement xmlenc will use the any element any processcontents lax namespace other 1,1 elements from 0 unbounded namespaces choice attribute name id type id use optional complextype 4.5.1 the keyname element the keyname element contains a string value in which white space is significant which may be used by the signer to communicate a key identifier to the recipient. typically keyname contains an identifier related to the key pair used to sign the message but it may contain other protocol-related information that indirectly identifies a key pair. common uses of keyname include simple string names for keys a key index a distinguished name dn an email address etc. schema definition element name keyname type string 4.5.2 the keyvalue element the keyvalue element contains a single public key that may be useful in validating the signature. structured formats for defining dsa required rsa required and ecdsa required public keys are defined in section 6.4 signature algorithms. the keyvalue element may include externally defined public keys values represented as pcdata or element types from an external namespace. schema definition element name keyvalue type ds keyvaluetype complextype name keyvaluetype mixed true choice element ref ds dsakeyvalue element ref ds rsakeyvalue element ref dsig11 eckeyvalue ecc keys xmldsig 1.1 will use the any element any namespace other processcontents lax choice complextype 4.5.2.1 the dsakeyvalue element identifier type http www.w3.org 2000 09 xmldsig#dsakeyvalue this can be used within a retrievalmethod or reference element to identify the referent s type dsa keys and the dsa signature algorithm are specified in fips-186-3 dsa public key values can have the following fields p a prime modulus meeting the fips-186-3 requirements q an integer in the range 2 159 q 2 160 which is a prime divisor of p-1 g an integer with certain properties with respect to p and q y g x mod p where x is part of the private key and not made public j p 1 q seed a dsa prime generation seed pgencounter a dsa prime generation counter parameter j is available for inclusion solely for efficiency as it is calculatable from p and q. parameters seed and pgencounter are used in the dsa prime number generation algorithm specified in fips-186-3 as such they are optional but must either both be present or both be absent. this prime generation algorithm is designed to provide assurance that a weak prime is not being used and it yields a p and q value. parameters p q and g can be public and common to a group of users. they might be known from application context. as such they are optional but p and q must either both appear or both be absent. if all of p q seed and pgencounter are present implementations are not required to check if they are consistent and are free to use either p and q or seed and pgencounter. all parameters are encoded as base64 rfc2045 values. arbitrary-length integers e.g. bignums such as rsa moduli are represented in xml as octet strings as defined by the ds cryptobinary type. schema definition element name dsakeyvalue type ds dsakeyvaluetype complextype name dsakeyvaluetype sequence sequence minoccurs 0 element name p type ds cryptobinary element name q type ds cryptobinary sequence element name g type ds cryptobinary minoccurs 0 element name y type ds cryptobinary element name j type ds cryptobinary minoccurs 0 sequence minoccurs 0 element name seed type ds cryptobinary element name pgencounter type ds cryptobinary sequence sequence complextype 4.5.2.2 the rsakeyvalue element identifier type http www.w3.org 2000 09 xmldsig#rsakeyvalue this can be used within a retrievalmethod or reference element to identify the referent s type rsa key values have two fields modulus and exponent. example 6 rsakeyvalue modulus xa7seu+e0yqh5rm9kbcdn9o3apio7hbp7tx6wooclzatnfyxszdu16ksl6w jubafoqnepcwr3rdfst7bcqnxpbe5elh5u4vey19mzxkxrgrmvavzybpvrgbuwulv 5fok5hhmbktqhyndy 6lpqrhdudstvk+g9ucj47es9aqj3u modulus exponent aqab exponent rsakeyvalue arbitrary-length integers e.g. bignums such as rsa moduli are represented in xml as octet strings as defined by the ds cryptobinary type. schema definition element name rsakeyvalue type ds rsakeyvaluetype complextype name rsakeyvaluetype sequence element name modulus type ds cryptobinary element name exponent type ds cryptobinary sequence complextype 4.5.2.3 the eckeyvalue element identifier type http www.w3.org 2009 xmldsig11#eckeyvalue this can be used within a retrievalmethod or reference element to identify the referent s type the eckeyvalue element is defined in the http www.w3.org 2009 xmldsig11# namespace. ec public key values consists of two sub components domain parameters and publickey. example 7 eckeyvalue xmlns http www.w3.org 2009 xmldsig11# namedcurve uri urn oid 1.2.840.10045.3.1.7 publickey vwccup6jp3pcamcgicah3yoev4gaa2ukoanc7ufg cf8kdo7attosgjk7 ta8ic3vzocy9i5opjrhytbulbnj7y publickey eckeyvalue note a line break has been added to the publickey content to preserve printed page width. domain parameters can be encoded explicitly using the dsig11 ecparameters element or by reference using the dsig11 namedcurve element. a named curve is specified through the uri attribute. for named curves that are identified by oids such as those defined in rfc3279 and rfc4055 the oid should be encoded according to urn-oid conformant applications must support the dsig11 namedcurve element and the 256-bit prime field curve as identified by the oid 1.2.840.10045.3.1.7. the publickey element contains a base64 encoding of a binary representation of the x and y coordinates of the point. its value is computed as follows convert the elliptic curve point x y to an octet string by first converting the field elements x and y to octet strings as specified in section 6.2 of ecc-algs note and then prepend the concatenated result of the conversion with 0x04. support for elliptic-curve-point-to-octet-string conversion without point compression is required. base64 encode the octet string resulting from the conversion in step 1. schema definition targetnamespace http www.w3.org 2009 xmldsig11# element name eckeyvalue type dsig11 eckeyvaluetype complextype name eckeyvaluetype sequence choice element name ecparameters type dsig11 ecparameterstype element name namedcurve type dsig11 namedcurvetype choice element name publickey type dsig11 ecpointtype sequence attribute name id type id use optional complextype complextype name namedcurvetype attribute name uri type anyuri use required complextype simpletype name ecpointtype restriction base ds cryptobinary simpletype 4.5.2.3.1 explicit curve parameters the ecparameters element consists of the following subelements. note these definitions are based on the those described in rfc3279 the fieldid element identifies the finite field over which the elliptic curve is defined. additional details on the structures for defining prime and characteristic two fields is provided below. the dsig11 curve element specifies the coefficients a and b of the elliptic curve e. each coefficient is first converted from a field element to an octet string as specified in section 6.2 of ecc-algs then the resultant octet string is encoded in base64. the base element specifies the base point p on the elliptic curve. the base point is represented as a value of type ecpointtype. the order element specifies the order n of the base point and is encoded as a positiveinteger. the cofactor element is an optional element that specifies the integer h e fq n. the cofactor is not required to support ecdsa except in parameter validation. the cofactor may be included to support parameter validation for ecdsa keys. parameter validation is not required by this specification. the cofactor is required in ecdh public key parameters. the dsig11 validationdata element is an optional element that specifies the hash algorithm used to generate the elliptic curve e and the base point g verifiably at random. it also specifies the seed that was used to generate the curve and the base point. schema definition targetnamespace http www.w3.org 2009 xmldsig11# complextype name ecparameterstype sequence element name fieldid type dsig11 fieldidtype element name curve type dsig11 curvetype element name base type dsig11 ecpointtype element name order type ds cryptobinary element name cofactor type integer minoccurs 0 element name validationdata type dsig11 ecvalidationdatatype minoccurs 0 sequence complextype complextype name fieldidtype choice element ref dsig11 prime element ref dsig11 tnb element ref dsig11 pnb element ref dsig11 gnb any namespace other processcontents lax choice complextype complextype name curvetype sequence element name a type ds cryptobinary element name b type ds cryptobinary sequence complextype complextype name ecvalidationdatatype sequence element name seed type ds cryptobinary sequence attribute name hashalgorithm type anyuri use required complextype prime fields are described by a single subelement p which represents the field size in bits. it is encoded as a positiveinteger. schema definition targetnamespace http www.w3.org 2009 xmldsig11# element name prime type dsig11 primefieldparamstype complextype name primefieldparamstype sequence element name p type ds cryptobinary sequence complextype structures are defined for three types of characteristic two fields gaussian normal basis pentanomial basis and trinomial basis. schema definition targetnamespace http www.w3.org 2009 xmldsig11# element name gnb type dsig11 chartwofieldparamstype complextype name chartwofieldparamstype sequence element name m type positiveinteger sequence complextype element name tnb type dsig11 tnbfieldparamstype complextype name tnbfieldparamstype complexcontent extension base dsig11 chartwofieldparamstype sequence element name k type positiveinteger sequence extension complexcontent complextype element name pnb type dsig11 pnbfieldparamstype complextype name pnbfieldparamstype complexcontent extension base dsig11 chartwofieldparamstype sequence element name k1 type positiveinteger element name k2 type positiveinteger element name k3 type positiveinteger sequence extension complexcontent complextype 4.5.2.3.2 compatibility with rfc 4050 implementations that need to support the rfc4050 format for ecdsa keys can avoid known interoperability problems with that specification by adhering to the following profile avoid validating the ecdsakeyvalue element against the rfc4050 schema. xml schema validators may not support integer types with decimal data exceeding 18 decimal digits. xmlschema-1 xmlschema-2 support only the namedcurve element. support the 256-bit prime field curve as identified by the urn urn oid 1.2.840.10045.3.1.7. the following is an example of a ecdsakeyvalue element that meets the profile described in this section. example 8 ecdsakeyvalue xmlns http www.w3.org 2001 04 xmldsig-more# domainparameters namedcurve urn urn oid 1.2.840.10045.3.1.7 domainparameters publickey x value 5851106065380174439324917904648283332 0204931884267326155134056258624064349885 y value 1024033521368277752409102672177795083 59028642524881540878079119895764161434936 publickey ecdsakeyvalue note a line break has been added to the x and y value attribute values to preserve printed page width. 4.5.3 the retrievalmethod element a retrievalmethod element within keyinfo is used to convey a reference to keyinfo information that is stored at another location. for example several signatures in a document might use a key verified by an x.509v3 certificate chain appearing once in the document or remotely outside the document each signature s keyinfo can reference this chain using a single retrievalmethod element instead of including the entire chain with a sequence of x509certificate elements. retrievalmethod uses the same syntax and dereferencing behavior as the reference uri attribute section 4.4.3.1 the uri attribute and the reference processing model except that there are no digestmethod or digestvalue child elements and presence of the uri attribute is mandatory. type is an optional identifier for the type of data retrieved after all transforms have been applied. the result of dereferencing a retrievalmethod reference for all keyinfo types defined by this specification section 4.5 the keyinfo element with a corresponding xml structure is an xml element or document with that element as the root. the rawx509certificate keyinfo for which there is no xml structure returns a binary x509 certificate. note that when referencing one of the defined keyinfo types within the same document or some remote documents at least one transform is required to turn an id-based reference to a keyinfo element into a child element located inside it. this is due to the lack of an xml id attribute on the defined keyinfo types. in such cases use of keyinforeference is encouraged instead see section 4.5.10 the keyinforeference element. note the keyinforeference element is preferred over use of retrievalmethod as it avoids use of transform child elements that introduce security risk and implementation challenges. schema definition element name retrievalmethod type ds retrievalmethodtype complextype name retrievalmethodtype sequence element ref ds transforms minoccurs 0 sequence attribute name uri type anyuri attribute name type type anyuri use optional complextype note the schema for the uri attribute of retrievalmethod erroneously omitted the attribute use required however this error only results in a more lax schema which permits all valid retrievalmethod elements. because the existing schema is embedded in many applications which may include the schema in their signatures the schema has not been corrected to be more restrictive. 4.5.4 the x509data element identifier type http www.w3.org 2000 09 xmldsig#x509data this can be used within a retrievalmethod or reference element to identify the referent s type an x509data element within keyinfo contains one or more identifiers of keys or x509 certificates or certificates identifiers or a revocation list the content of x509data is at least one element from the following set of element types any of these may appear together or more than once iff if and only if each instance describes or is related to the same certificate the deprecated x509issuerserial element which contains an x.509 issuer distinguished name serial number pair. the distinguished name should be represented as a string that complies with section 3 of rfc4514 ldap-dn to be generated according to the distinguished name encoding rules section below the x509subjectname element which contains an x.509 subject distinguished name that should be represented as a string that complies with section 3 of rfc4514 ldap-dn to be generated according to the distinguished name encoding rules section below the x509ski element which contains the base64 encoded plain i.e. non-der-encoded value of a x509 v.3 subjectkeyidentifier extension the x509certificate element which contains a base64-encoded x509v3 certificate and the x509crl element which contains a base64-encoded certificate revocation list crl x509v3 the dsig11 x509digest element contains a base64-encoded digest of a certificate. the digest algorithm uri is identified with a required algorithm attribute. the input to the digest must be the raw octets that would be base64-encoded were the same certificate to appear in the x509certificate element. elements from an external namespace which accompanies complements any of the elements above. any x509issuerserial x509ski x509subjectname and dsig11 x509digest elements that appear must refer to the certificate or certificates containing the validation key. all such elements that refer to a particular individual certificate must be grouped inside a single x509data element and if the certificate to which they refer appears it must also be in that x509data element. any x509issuerserial x509ski x509subjectname and dsig11 x509digest elements that relate to the same key but different certificates must be grouped within a single keyinfo but may occur in multiple x509data elements. note that if x509data child elements are used to identify a trusted certificate rather than solely as an untrusted hint supplemented by validation by policy the complete set of such elements that are intended to identify a certificate should be integrity protected typically by signing an entire x509data or keyinfo element. all certificates appearing in an x509data element must relate to the validation key by either containing it or being part of a certification chain that terminates in a certificate containing the validation key. no ordering is implied by the above constraints. the comments in the following instance demonstrate these constraints example 9 keyinfo x509data two pointers to certificate-a x509issuerserial x509issuername cn tamura kent ou trl o ibm l yamato-shi st kanagawa c jp x509issuername x509serialnumber 12345678 x509serialnumber x509issuerserial x509ski 31d97bd7 x509ski x509data x509data single pointer to certificate-b x509subjectname subject of certificate b x509subjectname x509data x509data certificate chain signer cert issuer cn arbolca ou fvt o ibm c us serial 4-- x509certificate miicxtcca.. x509certificate intermediate cert subject cn arbolca ou fvt o ibm c us issuer cn tootiseca ou fvt o bridgepoint c us x509certificate miicpzcca... x509certificate root cert subject cn tootiseca ou fvt o bridgepoint c us x509certificate miicstcca... x509certificate x509data keyinfo note there is no direct provision for a pkcs#7 encoded bag of certificates or crls. however a set of certificates and crls can occur within an x509data element and multiple x509data elements can occur in a keyinfo. whenever multiple certificates occur in an x509data element at least one such certificate must contain the public key which verifies the signature. while in principle many certificate encodings are possible it is recommended that certificates appearing in an x509certificate element be limited to an encoding of ber or its der subset allowing that within the certificate other content may be present. the use of other encodings may lead to interoperability issues. in any case xml signature implementations should not alter or re-encode certificates as doing so could invalidate their signatures. the x509issuerserial element has been deprecated in favor of the newly-introduced dsig11 x509digest element. the xml schema type of the serial number was defined to be an integer and xml schema validators may not support integer types with decimal data exceeding 18 decimal digits xmlschema-2 this has proven insufficient because many certificate authorities issue certificates with large random serial numbers that exceed this limit. as a result deployments that do make use of this element should take care if schema validation is involved. new deployments should avoid use of the element. 4.5.4.1 distinguished name encoding rules to encode a distinguished name x509issuerserial x509subjectname and keyname if appropriate the encoding rules in section 2 of rfc 4514 ldap-dn should be applied except that the character escaping rules in section 2.4 of rfc 4514 ldap-dn may be augmented as follows escape all occurrences of ascii control characters unicode range x00 x1f by replacing them with followed by a two digit hex number showing its unicode number. escape any trailing space characters unicode x20 by replacing them with 20 instead of using the escape sequence since an xml document logically consists of characters not octets the resulting unicode string is finally encoded according to the character encoding used for producing the physical representation of the xml document. schema definition element name x509data type ds x509datatype complextype name x509datatype sequence maxoccurs unbounded choice element name x509issuerserial type ds x509issuerserialtype element name x509ski type base64binary element name x509subjectname type string element name x509certificate type base64binary element name x509crl type base64binary element ref dsig11 x509digest the x509digest element xmldsig 1.1 will use the any element any namespace other processcontents lax choice sequence complextype complextype name x509issuerserialtype sequence element name x509issuername type string element name x509serialnumber type integer sequence complextype note this schema permits x509data to be empty this is precluded by the text in a href sec-keyinfo class sectionref a which states that at least one element from the dsig namespace should be present in the pgp spki and x509 structures. this is easily expressed for the other key types but not for x509data because of its rich structure. targetnamespace http www.w3.org 2009 xmldsig11# element name x509digest type dsig11 x509digesttype complextype name x509digesttype simplecontent extension base base64binary attribute name algorithm type anyuri use required extension simplecontent complextype 4.5.5 the pgpdata element identifier type http www.w3.org 2000 09 xmldsig#pgpdata this can be used within a retrievalmethod or reference element to identify the referent s type the pgpdata element within keyinfo is used to convey information related to pgp public key pairs and signatures on such keys. the pgpkeyid s value is a base64binary sequence containing a standard pgp public key identifier as defined in pgp section 11.2 the pgpkeypacket contains a base64-encoded key material packet as defined in pgp section 5.5 these children element types can be complemented extended by siblings from an external namespace within pgpdata or pgpdata can be replaced all together with an alternative pgp xml structure as a child of keyinfo. pgpdata must contain one pgpkeyid and or one pgpkeypacket and 0 or more elements from an external namespace. schema definition element name pgpdata type ds pgpdatatype complextype name pgpdatatype choice sequence element name pgpkeyid type base64binary element name pgpkeypacket type base64binary minoccurs 0 any namespace other processcontents lax minoccurs 0 maxoccurs unbounded sequence sequence element name pgpkeypacket type base64binary any namespace other processcontents lax minoccurs 0 maxoccurs unbounded sequence choice complextype 4.5.6 the spkidata element identifier type http www.w3.org 2000 09 xmldsig#spkidata this can be used within a retrievalmethod or reference element to identify the referent s type the spkidata element within keyinfo is used to convey information related to spki public key pairs certificates and other spki data. spkisexp is the base64 encoding of a spki canonical s-expression. spkidata must have at least one spkisexp spkisexp can be complemented extended by siblings from an external namespace within spkidata or spkidata can be entirely replaced with an alternative spki xml structure as a child of keyinfo. schema definition element name spkidata type ds spkidatatype complextype name spkidatatype sequence maxoccurs unbounded element name spkisexp type base64binary any namespace other processcontents lax minoccurs 0 sequence complextype 4.5.7 the mgmtdata element identifier type http www.w3.org 2000 09 xmldsig#mgmtdata this can be used within a retrievalmethod or reference element to identify the referent s type the mgmtdata element within keyinfo is a string value used to convey in-band key distribution or agreement data. however use of this element is not recommended and should not be used. the section 4.5.8 xml encryption encryptedkey and derivedkey elements describes new keyinfo types for conveying key information. schema definition element name mgmtdata type string 4.5.8 xml encryption encryptedkey and derivedkey elements the xenc encryptedkey and xenc derivedkey elements defined in xmlenc-core1 as children of ds keyinfo can be used to convey in-band encrypted or derived key material. in particular the xenc derivedkey element may be present when the key used in calculating a message authentication code is derived from a shared secret. 4.5.9 the derencodedkeyvalue element identifier type http www.w3.org 2009 xmldsig11#derencodedkeyvalue this can be used within a retrievalmethod or reference element to identify the referent s type the public key algorithm and value are der-encoded in accordance with the value that would be used in the subject public key info field of an x.509 certificate per section 4.1.2.7 of rfc5280 the der-encoded value is then base64-encoded. for the key value types supported in this specification refer to the following for normative references on the format of subject public key info and the relevant oid values that identify the key algorithm type rsa see section 2.3.1 of rfc3279 dsa see section 2.3.2 of rfc3279 ec see section 2 of rfc5480 specifications that define additional key types should provide such a normative reference for their own key types where possible. schema definition targetnamespace http www.w3.org 2009 xmldsig11# element name derencodedkeyvalue type dsig11 derencodedkeyvaluetype complextype name derencodedkeyvaluetype simplecontent extension base base64binary attribute name id type id use optional extension simplecontent complextype historical note the derencodedkeyvalue element was added to xml signature 1.1 in order to support certain interoperability scenarios where at least one of signer and or verifier are not able to serialize keys in the xml formats described in section 4.5.2 the keyvalue element above. the keyvalue element is to be used for bare xml key representations not xml wrappings around other binary encodings like asn.1 der for this reason the derencodedkeyvalue element is not a child of keyvalue. the derencodedkeyvalue element is also not a child of the x509data element as the keys represented by derencodedkeyvalue may not have x.509 certificates associated with them a requirement for x509data 4.5.10 the keyinforeference element a keyinforeference element within keyinfo is used to convey a reference to a keyinfo element at another location in the same or different document. for example several signatures in a document might use a key verified by an x.509v3 certificate chain appearing once in the document or remotely outside the document each signature s keyinfo can reference this chain using a single keyinforeference element instead of including the entire chain with a sequence of x509certificate elements repeated in multiple places. keyinforeference uses the same syntax and dereferencing behavior as reference s uri section 4.4.3.1 the uri attribute and the reference processing model section 4.4.3.2 the reference processing model except that there are no child elements and the presence of the uri attribute is mandatory. the result of dereferencing a keyinforeference must be a keyinfo element or an xml document with a keyinfo element as the root. note the keyinforeference element is a desirable alternative to the use of retrievalmethod when the data being referred to is a keyinfo element and the use of retrievalmethod would require one or more transform child elements which introduce security risk and implementation challenges. schema definition targetnamespace http www.w3.org 2009 xmldsig11# element name keyinforeference type dsig11 keyinforeferencetype complextype name keyinforeferencetype attribute name uri type anyuri use required attribute name id type id use optional complextype 4.6 the object element identifier type http www.w3.org 2000 09 xmldsig#object this can be used within a reference element to identify the referent s type object is an optional element that may occur one or more times. when present this element may contain any data. the object element may include optional mime type id and encoding attributes. the object s encoding attributed may be used to provide a uri that identifies the method by which the object is encoded e.g. a binary file the mimetype attribute is an optional attribute which describes the data within the object independent of its encoding this is a string with values defined by rfc2045 for example if the object contains base64 encoded png the encoding may be specified as http www.w3.org 2000 09 xmldsig#base64 and the mimetype as image png this attribute is purely advisory no validation of the mimetype information is required by this specification. applications which require normative type and encoding information for signature validation should specify transforms with well defined resulting types and or encodings. the object s id is commonly referenced from a reference in signedinfo or manifest. this element is typically used for enveloping signatures where the object being signed is to be included in the signature element. the digest is calculated over the entire object element including start and end tags. note if the application wishes to exclude the object tags from the digest calculation the reference must identify the actual data object easy for xml documents or a transform must be used to remove the object tags likely where the data object is non-xml exclusion of the object tags may be desired for cases where one wants the signature to remain valid if the data object is moved from inside a signature to outside the signature or vice versa or where the content of the object is an encoding of an original binary document and it is desired to extract and decode so as to sign the original bitwise representation. schema definition element name object type ds objecttype complextype name objecttype mixed true sequence minoccurs 0 maxoccurs unbounded any namespace any processcontents lax sequence attribute name id type id use optional attribute name mimetype type string use optional attribute name encoding type anyuri use optional complextype 5. additional signature syntax this section describes the optional to implement manifest and signatureproperties elements and describes the handling of xml processing instructions and comments. with respect to the elements manifest and signatureproperties this section specifies syntax and little behavior it is left to the application. these elements can appear anywhere the parent s content model permits the signature content model only permits them within object. 5.1 the manifest element identifier type http www.w3.org 2000 09 xmldsig#manifest this can be used within a reference element to identify the referent s type the manifest element provides a list of references. the difference from the list in signedinfo is that it is application defined which if any of the digests are actually checked against the objects referenced and what to do if the object is inaccessible or the digest compare fails. if a manifest is pointed to from signedinfo the digest over the manifest itself will be checked by the core signature validation behavior. the digests within such a manifest are checked at the application s discretion. if a manifest is referenced from another manifest even the overall digest of this two level deep manifest might not be checked. schema definition element name manifest type ds manifesttype complextype name manifesttype sequence element ref ds reference maxoccurs unbounded sequence attribute name id type id use optional complextype 5.2 the signatureproperties element identifier type http www.w3.org 2000 09 xmldsig#signatureproperties this can be used within a reference element to identify the referent s type additional information items concerning the generation of the signature s can be placed in a signatureproperty element i.e. date time stamp or the serial number of cryptographic hardware used in signature generation schema definition element name signatureproperties type ds signaturepropertiestype complextype name signaturepropertiestype sequence element ref ds signatureproperty maxoccurs unbounded sequence attribute name id type id use optional complextype element name signatureproperty type ds signaturepropertytype complextype name signaturepropertytype mixed true choice maxoccurs unbounded any namespace other processcontents lax 1,1 elements from 1 unbounded namespaces choice attribute name target type anyuri use required attribute name id type id use optional complextype 5.3 processing instructions in signature elements no xml processing instructions pis are used by this specification. note that pis placed inside signedinfo by an application will be signed unless the canonicalizationmethod algorithm discards them. this is true for any signed xml content. all of the canonicalizationmethods identified within this specification retain pis. when a pi is part of content that is signed e.g. within signedinfo or referenced xml documents any change to the pi will obviously result in a signature failure. 5.4 comments in signature elements xml comments are not used by this specification. note that unless canonicalizationmethod removes comments within signedinfo or any other referenced xml which xml-c14n does they will be signed. consequently if they are retained a change to the comment will cause a signature failure. similarly the xml signature over any xml data will be sensitive to comment changes unless a comment-ignoring canonicalization transform method such as the canonical xml xml-c14n is specified. 6. algorithms this section identifies algorithms used with the xml digital signature specification. entries contain the identifier to be used in signature elements a reference to the formal specification and definitions where applicable for the representation of keys and the results of cryptographic operations. 6.1 algorithm identifiers and implementation requirements algorithms are identified by uris that appear as an attribute to the element that identifies the algorithms role digestmethod transform signaturemethod or canonicalizationmethod all algorithms used herein take parameters but in many cases the parameters are implicit. for example a signaturemethod is implicitly given two parameters the keying info and the output of canonicalizationmethod. explicit additional parameters to an algorithm appear as content elements within the algorithm role element. such parameter elements have a descriptive element name which is frequently algorithm specific and must be in the xml signature namespace or an algorithm specific namespace. this specification defines a set of algorithms their uris and requirements for implementation. requirements are specified over implementation not over requirements for signature use. furthermore the mechanism is extensible alternative algorithms may be used by signature applications. digest required sha1 use is discouraged see sha-1 warning http www.w3.org 2000 09 xmldsig#sha1 sha256 http www.w3.org 2001 04 xmlenc#sha256 optional sha224 http www.w3.org 2001 04 xmldsig-more#sha224 sha384 http www.w3.org 2001 04 xmldsig-more#sha384 sha512 http www.w3.org 2001 04 xmlenc#sha512 encoding required base64 note http www.w3.org 2000 09 xmldsig#base64 mac required hmac-sha1 use is discouraged see sha-1 warning http www.w3.org 2000 09 xmldsig#hmac-sha1 hmac-sha256 http www.w3.org 2001 04 xmldsig-more#hmac-sha256 recommended hmac-sha384 http www.w3.org 2001 04 xmldsig-more#hmac-sha384 hmac-sha512 http www.w3.org 2001 04 xmldsig-more#hmac-sha512 optional hmac-sha224 http www.w3.org 2001 04 xmldsig-more#hmac-sha224 signature required rsawithsha256 http www.w3.org 2001 04 xmldsig-more#rsa-sha256 section 6.4.2 rsa pkcs#1 v1.5 ecdsawithsha256 http www.w3.org 2001 04 xmldsig-more#ecdsa-sha256 section 6.4.3 ecdsa dsawithsha1 signature verification http www.w3.org 2000 09 xmldsig#dsa-sha1 section 6.4.1 dsa recommended rsawithsha1 signature verification use for signature generation is discouraged see sha-1 warning http www.w3.org 2000 09 xmldsig#rsa-sha1 optional rsawithsha224 http www.w3.org 2001 04 xmldsig-more#rsa-sha224 section 6.4.2 rsa pkcs#1 v1.5 rsawithsha384 http www.w3.org 2001 04 xmldsig-more#rsa-sha384 section 6.4.2 rsa pkcs#1 v1.5 rsawithsha512 http www.w3.org 2001 04 xmldsig-more#rsa-sha512 ecdsawithsha1 use is discouraged see sha-1 warning http www.w3.org 2001 04 xmldsig-more#ecdsa-sha1 section 6.4.3 ecdsa ecdsawithsha224 http www.w3.org 2001 04 xmldsig-more#ecdsa-sha224 section 6.4.3 ecdsa ecdsawithsha384 http www.w3.org 2001 04 xmldsig-more#ecdsa-sha384 section 6.4.3 ecdsa ecdsawithsha512 http www.w3.org 2001 04 xmldsig-more#ecdsa-sha512 section 6.4.3 ecdsa dsawithsha1 signature generation http www.w3.org 2000 09 xmldsig#dsa-sha1 section 6.4.1 dsa dsawithsha256 http www.w3.org 2009 xmldsig11#dsa-sha256 section 6.4.1 dsa canonicalization required canonical xml 1.0 omit comments http www.w3.org tr 2001 rec-xml-c14n-20010315 canonical xml 1.1 omit comments http www.w3.org 2006 12 xml-c14n11 exclusive xml canonicalization 1.0 omit comments http www.w3.org 2001 10 xml-exc-c14n# recommended canonical xml 1.0 with comments http www.w3.org tr 2001 rec-xml-c14n-20010315#withcomments canonical xml 1.1 with comments http www.w3.org 2006 12 xml-c14n11#withcomments exclusive xml canonicalization 1.0 with comments http www.w3.org 2001 10 xml-exc-c14n#withcomments transform required base64 note http www.w3.org 2000 09 xmldsig#base64 enveloped signature note http www.w3.org 2000 09 xmldsig#enveloped-signature recommended xpath http www.w3.org tr 1999 rec-xpath-19991116 xpath filter 2.0 http www.w3.org 2002 06 xmldsig-filter2 optional xslt http www.w3.org tr 1999 rec-xslt-19991116 note note that the same uri is used to identify base64 both in encoding context e.g. within the object element as well as in transform context when identifying a base64 transform note the enveloped signature transform removes the signature element from the calculation of the signature when the signature is within the content that it is being signed. this may be implemented via the xpath specification specified in 6.6.4 enveloped signature transform it must have the same effect as that specified by the xpath transform. when using transforms we recommend selecting the least expressive choice that still accomplishes the needs of the use case at hand use of xpath filter 2.0 is recommended over use of xpath filter. use of xpath filter is recommended over use of xslt. note implementation requirements for the xpath transform may be downgraded to optional in a future version of this specification. 6.2 message digests this specification defines several possible digest algorithms for the digestmethod element including required algorithm sha-256. use of sha-256 is strongly recommended over sha-1 because recent advances in cryptanalysis see e.g. sha-1-analysis have cast doubt on the long-term collision resistance of sha-1. therefore sha-1 support is required in this specification only for backwards-compatibility reasons. digest algorithms that are known not to be collision resistant should not be used in digestmethod elements. for example the md5 message digest algorithm should not be used as specific collisions have been demonstrated for that algorithm. 6.2.1 sha-1 identifier http www.w3.org 2000 09 xmldsig#sha1 note use of sha-256 is strongly recommended over sha-1 because recent advances in cryptanalysis see e.g. sha-1-analysis sha-1-collisions have cast doubt on the long-term collision resistance of sha-1. the sha-1 algorithm fips-186-3 takes no explicit parameters. an example of an sha-1 digestalg element is example 10 digestmethod algorithm http www.w3.org 2000 09 xmldsig#sha1 a sha-1 digest is a 160-bit string. the content of the digestvalue element shall be the base64 encoding of this bit string viewed as a 20-octet octet stream. for example the digestvalue element for the message digest example 11 a9993e36 4706816a ba3e2571 7850c26c 9cd0d89d from appendix a of the sha-1 standard would be example 12 digestvalue qzk+nkcggwq6pivxefdcbjzq2j0 digestvalue 6.2.2 sha-224 identifier http www.w3.org 2001 04 xmldsig-more#sha224 the sha-224 algorithm fips-180-3 takes no explicit parameters. a sha-224 digest is a 224-bit string. the content of the digestvalue element shall be the base64 encoding of this bit string viewed as a 28-octet octet stream. 6.2.3 sha-256 identifier http www.w3.org 2001 04 xmlenc#sha256 the sha-256 algorithm fips-180-3 takes no explicit parameters. a sha-256 digest is a 256-bit string. the content of the digestvalue element shall be the base64 encoding of this bit string viewed as a 32-octet octet stream. 6.2.4 sha-384 identifier http www.w3.org 2001 04 xmldsig-more#sha384 the sha-384 algorithm fips-180-3 takes no explicit parameters. a sha-384 digest is a 384-bit string. the content of the digestvalue element shall be the base64 encoding of this bit string viewed as a 48-octet octet stream. 6.2.5 sha-512 identifier http www.w3.org 2001 04 xmlenc#sha512 the sha-512 algorithm fips-180-3 takes no explicit parameters. a sha-512 digest is a 512-bit string. the content of the digestvalue element shall be the base64 encoding of this bit string viewed as a 64-octet octet stream. 6.3 message authentication codes mac algorithms take two implicit parameters their keying material determined from keyinfo and the octet stream output by canonicalizationmethod. macs and signature algorithms are syntactically identical but a mac implies a shared secret key. 6.3.1 hmac identifier http www.w3.org 2000 09 xmldsig#hmac-sha1 http www.w3.org 2001 04 xmldsig-more#hmac-sha224 http www.w3.org 2001 04 xmldsig-more#hmac-sha256 http www.w3.org 2001 04 xmldsig-more#hmac-sha384 http www.w3.org 2001 04 xmldsig-more#hmac-sha512 the hmac algorithm rfc2104 hmac takes the output truncation length in bits as a parameter this specification requires that the truncation length be a multiple of 8 i.e. fall on a byte boundary because base64 encoding operates on full bytes. if the truncation parameter is not specified then all the bits of the hash are output. any signature with a truncation length that is less than half the output length of the underlying hash algorithm must be deemed invalid. an example of an hmac signaturemethod element example 13 signaturemethod algorithm http www.w3.org 2000 09 xmldsig#hmac-sha1 hmacoutputlength 128 hmacoutputlength signaturemethod the output of the hmac algorithm is ultimately the output possibly truncated of the chosen digest algorithm. this value shall be base64 encoded in the same straightforward fashion as the output of the digest algorithms. example the signaturevalue element for the hmac-sha1 digest example 14 9294727a 3638bb1c 13f48ef8 158bfc9d from the test vectors in hmac would be example 15 signaturevalue kpryejy4uxwt9i74fyv8nq signaturevalue schema definition simpletype name hmacoutputlengthtype restriction base integer simpletype 6.4 signature algorithms signature algorithms take two implicit parameters their keying material determined from keyinfo and the octet stream output by canonicalizationmethod. signature and mac algorithms are syntactically identical but a signature implies public key cryptography. 6.4.1 dsa identifier http www.w3.org 2000 09 xmldsig#dsa-sha1 http www.w3.org 2009 xmldsig11#dsa-sha256 the dsa family of algorithms is defined in fips 186-3 fips-186-3 fips 186-3 defines dsa in terms of two security parameters l and n where l p n q p is the prime modulus q is a prime divisor of p-1 fips 186-3 defines four valid pairs of l n they are 1024 160 2048 224 2048 256 and 3072 256 the pair 1024 160 corresponds to the algorithm dsawithsha1 which is identified in this specification by the uri http www.w3.org 2000 09 xmldsig#dsa-sha1. the pairs 2048 256 and 3072 256 correspond to the algorithm dsawithsha256 which is identified in this specification by the uri http www.w3.org 2009 xmldsig11#dsa-sha256. this specification does not use the 2048 224 instance of dsa which corresponds to dsawithsha224 dsa takes no explicit parameters an example of a dsa signaturemethod element is example 16 signaturemethod algorithm http www.w3.org 2009 xmldsig11#dsa-sha256 the output of the dsa algorithm consists of a pair of integers usually referred by the pair r s the signature value consists of the base64 encoding of the concatenation of two octet-streams that respectively result from the octet-encoding of the values r and s in that order. integer to octet-stream conversion must be done according to the i2osp operation defined in the rfc 3447 pkcs1 specification with a l parameter equal to 20. for example the signaturevalue element for a dsa signature r s with values specified in hexadecimal example 17 r 8bac1ab6 6410435c b7181f95 b16ab97c 92b341c0 s 41e2345f 1f56df24 58f426d1 55b4ba2d b6dcd8c8 from the example in appendix 5 of the dss standard would be example 18 signaturevalue i6watmqqq1y3gb+vswq5fjkzqcbb4jrfh1bfjfj0jtfvtlotttzyya signaturevalue security considerations regarding dsa key sizes per fips 186-3 fips-186-3 the dsa security parameter l is defined to be 1024 2048 or 3072 bits and the corresponding dsa q value is defined to be 160 224 256 and 256 bits respectively. nist provides guidance on the use of keys of various strength for various time frames in special publication sp 800-57 part 1 sp800-57 implementers should consult this publication for guidance on acceptable key lengths for applications however 2048-bit public keys are the minimum recommended key length and 3072-bit keys are recommended for securing information beyond 2030. sp800-57 part 1 states that dsa 1024-bit key sizes should not be used except to verify and honor signatures created using older legacy systems. since xml signature 1.0 requires implementations to support dsa-based digital signatures this xml signature 1.1 revision allows verifiers to verify dsa signatures for dsa keys of 1024 bits in order to validate existing signatures. xml signature 1.1 implementations may but are not required to support dsa-based signature generation. given the short key size and sp800-57 guidelines dsa with 1024-bit prime moduli should not be used to create signatures. dsa with 1024-bit prime moduli may be used to verify older legacy signatures with an understanding of the associated risks. important older signatures should be re-signed with stronger signatures. 6.4.2 rsa pkcs#1 v1.5 identifier http www.w3.org 2000 09 xmldsig#rsa-sha1 http www.w3.org 2001 04 xmldsig-more#rsa-sha224 http www.w3.org 2001 04 xmldsig-more#rsa-sha256 http www.w3.org 2001 04 xmldsig-more#rsa-sha384 http www.w3.org 2001 04 xmldsig-more#rsa-sha512 the expression rsa algorithm as used in this specification refers to the rsassa-pkcs1-v1_5 algorithm described in rfc 3447 pkcs1 the rsa algorithm takes no explicit parameters. an example of an rsa signaturemethod element is example 19 signaturemethod algorithm http www.w3.org 2000 09 xmldsig#rsa-sha1 the signaturevalue content for an rsa signature is the base64 rfc2045 encoding of the octet string computed as per rfc 3447 pkcs1 section 8.2.1 signature generation for the rsassa-pkcs1-v1_5 signature scheme computation of the signature will require concatenation of the hash value and a constant string determined by rfc 3447. signature computation and verification does not require implementation of an asn.1 parser. the resulting base64 rfc2045 string is the value of the child text node of the signaturevalue element e.g. example 20 signaturevalue iwijxqjurcxbyocei4qxjwo9kg8d3p9tlwot4t0 gyte96639in0fzfy2 rvp+ bmj01earmkzs r5vw3rwopxw signaturevalue note a line break has been added to preserve printed page width. security considerations regarding rsa key sizes nist provides guidance on the use of keys of various strength for various time frames in special publication sp 800-57 part 1 sp800-57 implementers should consult this publication for guidance on acceptable key lengths for applications however 2048-bit public keys are the minimum recommended key length and 3072-bit keys are recommended for securing information beyond 2030. all conforming implementations of xml signature 1.1 must support rsa signature generation and verification with public keys at least 2048 bits in length. rsa public keys of 1024 bits or less should not be used to create new signatures but may be used to verify signatures created by older legacy systems. xml signature 1.1 implementations must use at least 2048-bit keys for creating signatures and should use at least 3072-bit keys for signatures that will be verified beyond 2030. 6.4.3 ecdsa identifiers http www.w3.org 2001 04 xmldsig-more#ecdsa-sha1 http www.w3.org 2001 04 xmldsig-more#ecdsa-sha224 http www.w3.org 2001 04 xmldsig-more#ecdsa-sha256 http www.w3.org 2001 04 xmldsig-more#ecdsa-sha384 http www.w3.org 2001 04 xmldsig-more#ecdsa-sha512 the ecdsa algorithm fips-186-3 takes no explicit parameters. an example of a ecdsa signaturemethod element is example 21 signaturemethod algorithm http www.w3.org 2001 04 xmldsig-more#ecdsa-sha256 the output of the ecdsa algorithm consists of a pair of integers usually referred by the pair r s the signature value consists of the base64 encoding of the concatenation of two octet-streams that respectively result from the octet-encoding of the values r and s in that order. integer to octet-stream conversion must be done according to the i2osp operation defined in the rfc 3447 pkcs1 specification with the l parameter equal to the size of the base point order of the curve in bytes e.g. 32 for the p-256 curve and 66 for the p-521 curve this specification requires implementations to implement an algorithm that leads to the same results as ecdsa over the p-256 prime curve specified in section d.2.3 of fips 186-3 fips-186-3 and using the sha-256 hash algorithm referred to as the ecdsawithsha256 signature algorithm ecc-algs it is further recommended that implementations also implement algorithms that lead to the same results as ecdsa over the p-384 and p-521 prime curves these curves are defined in sections d.2.4 and d.2.5 of fips 186-3 respectively ecc-algs note as described in ietf rfc 6090 the elliptic curve dsa ecdsa and kt-i signature methods are mathematically and functionally equivalent for fields of characteristic greater than three. see ietf rfc 6090 section 7.2 ecc-algs 6.5 canonicalization algorithms if canonicalization is performed over octets the canonicalization algorithms take two implicit parameters the content and its charset. the charset is derived according to the rules of the transport protocols and media types e.g xml-media-types defines the media types for xml this information is necessary to correctly sign and verify documents and often requires careful server side configuration. various canonicalization algorithms require conversion to utf-8 the algorithms below understand at least utf-8 and utf-16 as input encodings. we recommend that externally specified algorithms do the same. knowledge of other encodings is optional. various canonicalization algorithms transcode from a non-unicode encoding to unicode. the output of these algorithms will be in nfc nfc this is because the xml processor used to prepare the xpath data model input is required by the data model to use normalization form c when converting an xml document to the ucs character domain from any encoding that is not ucs-based. we recommend that externally specified canonicalization algorithms do the same. note there can be ambiguities in converting existing charsets to unicode for an example see the xml japanese profile note xml-japanese this specification requires implementation of canonical xml 1.0 xml-c14n canonical xml 1.1 xml-c14n11 and exclusive xml canonicalization xml-exc-c14n we recommend that applications that generate signatures choose canonical xml 1.1 xml-c14n11 when inclusive canonicalization is desired. note canonical xml 1.0 xml-c14n and canonical xml 1.1 xml-c14n11 specify a standard serialization of xml that when applied to a subdocument includes the subdocument s ancestor context including all of the namespace declarations and some attributes in the xml namespace. however some applications require a method which to the extent practical excludes unused ancestor context from a canonicalized subdocument. the exclusive xml canonicalization recommendation xml-exc-c14n may be used to address requirements resulting from scenarios where a subdocument is moved between contexts. 6.5.1 canonical xml 1.0 identifier for required canonical xml 1.0 omits comments http www.w3.org tr 2001 rec-xml-c14n-20010315 identifier for canonical xml 1.0 with comments http www.w3.org tr 2001 rec-xml-c14n-20010315#withcomments input octet-stream node-set output octet-stream an example of an xml canonicalization element is example 22 canonicalizationmethod algorithm http www.w3.org tr 2001 rec-xml-c14n-20010315 the normative specification of canonical xml1.0 is xml-c14n the algorithm is capable of taking as input either an octet stream or an xpath node-set or sufficiently functional alternative the algorithm produces an octet stream as output. canonical xml is easily parameterized via an additional uri to omit or retain comments. 6.5.2 canonical xml 1.1 identifier for required canonical xml 1.1 omits comments http www.w3.org 2006 12 xml-c14n11 identifier for canonical xml 1.1 with comments http www.w3.org 2006 12 xml-c14n11#withcomments input octet-stream node-set output octet-stream the normative specification of canonical xml 1.1 is xml-c14n11 the algorithm is capable of taking as input either an octet stream or an xpath node-set or sufficiently functional alternative the algorithm produces an octet stream as output. canonical xml 1.1 is easily parameterized via an additional uri to omit or retain comments. 6.5.3 exclusive xml canonicalization 1.0 identifier for required exclusive xml canonicalization 1.0 omits comments http www.w3.org 2001 10 xml-exc-c14n# identifier for exclusive xml canonicalization 1.0 with comments http www.w3.org 2001 10 xml-exc-c14n#withcomments input octet-stream node-set output octet-stream the normative specification of exclusive xml canonicalization 1.0 is xml-exc-c14n 6.6 transform algorithms a transform algorithm has a single implicit parameter an octet stream from the reference or the output of an earlier transform. for implementation requirements please see algorithm identifiers and implementation requirements. application developers are strongly encouraged to support all transforms that are listed as recommended unless the application environment has resource constraints that would make such support impractical. compliance with this recommendation will maximize application interoperability and libraries should be available to enable support of these transforms in applications without extensive development. 6.6.1 canonicalization any canonicalization algorithm that can be used for canonicalizationmethod such as those in canonicalization algorithms section 6.5 can be used as a transform. 6.6.2 base64 identifiers http www.w3.org 2000 09 xmldsig#base64 input octet-stream node-set output octet-stream the normative specification for base64 decoding transforms is rfc2045 the base64 transform element has no content. the input is decoded by the algorithms. this transform is useful if an application needs to sign the raw data associated with the encoded content of an element. this transform accepts either an octet-stream or a node-set as input. if an octet-string is given as input then this octet-stream is processed directly. if an xpath node-set or sufficiently functional alternative is given as input then it is converted to an octet stream by performing operations logically equivalent to 1 applying an xpath transform with expression self text then 2 sorting the nodeset by document order then concatenating the string-value of each of the nodes into one long string. thus if an xml element is identified by a shortname xpointer in the reference uri and its content consists solely of base64 encoded character data then this transform automatically strips away the start and end tags of the identified element and any of its descendant elements as well as any descendant comments and processing instructions. the output of this transform is an octet stream. 6.6.3 xpath filtering identifier http www.w3.org tr 1999 rec-xpath-19991116 input octet-stream node-set output node-set the normative specification for xpath expression evaluation is xpath the xpath expression to be evaluated appears as the character content of a transform parameter child element named xpath. the input required by this transform is an xpath node-set or an octet-stream. note that if the actual input is an xpath node-set resulting from a null uri or shortname xpointer dereference then comment nodes will have been omitted. if the actual input is an octet stream then the application must convert the octet stream to an xpath node-set suitable for use by canonical xml with comments. a subsequent application of the required canonical xml algorithm would strip away these comments. in other words the input node-set should be equivalent to the one that would be created by the following process initialize an xpath evaluation context by setting the initial node equal to the input xml document s root node and set the context position and size to 1. evaluate the xpath expression namespace the evaluation of this expression includes all of the document s nodes including comments in the node-set representing the octet stream. the transform output is always an xpath node-set. the xpath expression appearing in the xpath parameter is evaluated once for each node in the input node-set. the result is converted to a boolean. if the boolean is true then the node is included in the output node-set. if the boolean is false then the node is omitted from the output node-set. note even if the input node-set has had comments removed the comment nodes still exist in the underlying parse tree and can separate text nodes. for example the markup e hello comment world e contains two text nodes. therefore the expression self text string hello world would fail. should this problem arise in the application it can be solved by either canonicalizing the document before the xpath transform to physically remove the comments or by matching the node based on the parent element s string value e.g. by using the expression self text string parent e hello world the primary purpose of this transform is to ensure that only specifically defined changes to the input xml document are permitted after the signature is affixed. this is done by omitting precisely those nodes that are allowed to change once the signature is affixed and including all other input nodes in the output. it is the responsibility of the xpath expression author to include all nodes whose change could affect the interpretation of the transform output in the application context. note that the xml-signature xpath filter 2.0 recommendation xmldsig-xpath-filter2 may be used for this purpose. that recommendation defines an xpath transform that permits the easy specification of subtree selection and omission that can be efficiently implemented. an important scenario would be a document requiring two enveloped signatures. each signature must omit itself from its own digest calculations but it is also necessary to exclude the second signature element from the digest calculations of the first signature so that adding the second signature does not break the first signature. the xpath transform establishes the following evaluation context for each node of the input node-set a context node equal to a node of the input node-set. a context position initialized to 1. a context size initialized to 1. a library of functions equal to the function set defined in xpath augmented with a function named here to be treated as if part of the library and not namespace prefixed a set of variable bindings. no means for initializing these is defined. thus the set of variable bindings used when evaluating the xpath expression is empty and use of a variable reference in the xpath expression results in an error. the set of namespace declarations in scope for the xpath expression. as a result of the context node setting the xpath expressions appearing in this transform will be quite similar to those used in used in xslt except that the size and position are always 1 to reflect the fact that the transform is automatically visiting every node in xslt one recursively calls the command apply-templates to visit the nodes of the input tree the function here is defined as follows function node-set here the here function returns a node-set containing the attribute or processing instruction node or the parent element of the text node that directly bears the xpath expression. this expression results in an error if the containing xpath expression does not appear in the same xml document against which the xpath expression is being evaluated. as an example consider creating an enveloped signature a signature element that is a descendant of an element being signed although the signed content should not be changed after signing the elements within the signature element are changing e.g. the digest value must be put inside the digestvalue and the signaturevalue must be subsequently calculated one way to prevent these changes from invalidating the digest value in digestvalue is to add an xpath transform that omits all signature elements and their descendants. for example example 23 document signature xmlns http www.w3.org 2000 09 xmldsig# signedinfo reference uri transforms transform algorithm http www.w3.org tr 1999 rec-xpath-19991116 xpath xmlns dsig dsig not ancestor-or-self dsig signature xpath transform transforms digestmethod algorithm http www.w3.org 2000 09 xmldsig#sha1 digestvalue digestvalue reference signedinfo signaturevalue signaturevalue signature document due to the null reference uri in this example the xpath transform input node-set contains all nodes in the entire parse tree starting at the root node except the comment nodes for each node in this node-set the node is included in the output node-set except if the node or one of its ancestors has a tag of signature that is in the namespace given by the replacement text for the entity dsig a more elegant solution uses the here function to omit only the signature containing the xpath transform thus allowing enveloped signatures to sign other signatures. in the example above use the xpath element example 24 xpath xmlns dsig dsig count ancestor-or-self dsig signature here ancestor dsig signature 1 count ancestor-or-self dsig signature xpath since the xpath equality operator converts node sets to string values before comparison we must instead use the xpath union operator for each node of the document the predicate expression is true if and only if the node-set containing the node and its signature element ancestors does not include the enveloped signature element containing the xpath expression the union does not produce a larger set if the enveloped signature element is in the node-set given by ancestor-or-self signature 6.6.4 enveloped signature transform identifier http www.w3.org 2000 09 xmldsig#enveloped-signature input node-set output node-set an enveloped signature transform t removes the whole signature element containing t from the digest calculation of the reference element containing t. the entire string of characters used by an xml processor to match the signature with the xml production element is removed. the output of the transform is equivalent to the output that would result from replacing t with an xpath transform containing the following xpath parameter element example 25 xpath xmlns dsig dsig count ancestor-or-self dsig signature here ancestor dsig signature 1 count ancestor-or-self dsig signature xpath the input and output requirements of this transform are identical to those of the xpath transform but may only be applied to a node-set from its parent xml document. note that it is not necessary to use an xpath expression evaluator to create this transform. however this transform must produce output in exactly the same manner as the xpath transform parameterized by the xpath expression above. 6.6.5 xslt transform identifier http www.w3.org tr 1999 rec-xslt-19991116 input octet-stream output octet-stream the normative specification for xsl transformations is xslt specification of a namespace-qualified stylesheet element which must be the sole child of the transform element indicates that the specified style sheet should be used. whether this instantiates in-line processing of local xslt declarations within the resource is determined by the xslt processing model the ordered application of multiple stylesheet may require multiple transforms. no special provision is made for the identification of a remote stylesheet at a given uri because it can be communicated via an xsl include or xsl import within the stylesheet child of the transform. this transform requires an octet stream as input. the output of this transform is an octet stream. the processing rules for the xsl style sheet xsl10 or transform element are stated in the xslt specification xslt we recommend that xslt transform authors use an output method of xml for xml and html. as xslt implementations do not produce consistent serializations of their output we further recommend inserting a transform after the xslt transform to canonicalize the output. these steps will help to ensure interoperability of the resulting signatures among applications that support the xslt transform. note that if the output is actually html then the result of these steps is logically equivalent xhtml10 7. xml canonicalization and syntax constraint considerations digital signatures only work if the verification calculations are performed on exactly the same bits as the signing calculations. if the surface representation of the signed data can change between signing and verification then some way to standardize the changeable aspect must be used before signing and verification. for example even for simple ascii text there are at least three widely used line ending sequences. if it is possible for signed text to be modified from one line ending convention to another between the time of signing and signature verification then the line endings need to be canonicalized to a standard form before signing and verification or the signatures will break. xml is subject to surface representation changes and to processing which discards some surface information. for this reason xml digital signatures have a provision for indicating canonicalization methods in the signature so that a verifier can use the same canonicalization as the signer. throughout this specification we distinguish between the canonicalization of a signature element and other signed xml data objects. it is possible for an isolated xml document to be treated as if it were binary data so that no changes can occur. in that case the digest of the document will not change and it need not be canonicalized if it is signed and verified as such. however xml that is read and processed using standard xml parsing and processing techniques is frequently changed such that some of its surface representation information is lost or modified. in particular this will occur in many cases for the signature and enclosed signedinfo elements since they and possibly an encompassing xml document will be processed as xml. similarly these considerations apply to manifest object and signatureproperties elements if those elements have been digested their digestvalue is to be checked and they are being processed as xml. the kinds of changes in xml that may need to be canonicalized can be divided into four categories. there are those related to the basic xml10 as described in 7.1 below. there are those related to dom-level-1 sax or similar processing as described in 7.2 below. third there is the possibility of coded character set conversion such as between utf-8 and utf-16 both of which all xml10 compliant processors are required to support which is described in the paragraph immediately below. and fourth there are changes that related to namespace declaration and xml namespace attribute context as described in 7.3 below. any canonicalization algorithm should yield output in a specific fixed coded character set. all canonicalization algorithms identified in this document use utf-8 without a byte order mark bom and do not provide character normalization. we recommend that signature applications create xml content signature elements and their descendants content in normalization form c nfc and check that any xml being consumed is in that form as well if not signatures may consequently fail to validate additionally none of these algorithms provide data type normalization. applications that normalize data types in varying formats e.g. true false or 1,0 may not be able to validate each other s signatures. 7.1 xml 1.0 syntax constraints and canonicalization xml 1.0 xml10 defines an interface where a conformant application reading xml is given certain information from that xml and not other information. in particular line endings are normalized to the single character xa by dropping xd characters if they are immediately followed by a xa and replacing them with xa in all other cases missing attributes declared to have default values are provided to the application as if present with the default value character references are replaced with the corresponding character entity references are replaced with the corresponding declared entity attribute values are normalized by replacing character and entity references as above replacing occurrences of x9 xa and xd with x20 space except that the sequence xd#xa is replaced by a single space and if the attribute is not declared to be cdata stripping all leading and trailing spaces and replacing all interior runs of spaces with a single space. note that items 2 4 and 5.3 depend on the presence of a schema dtd or similar declarations. the signature element type is laxly schema valid xmlschema-1 xmlschema-2 consequently external xml or even xml within the same document as the signature may be only well-formed or from another namespace where permitted by the signature schema the noted items may not be present. thus a signature with such content will only be verifiable by other signature applications if the following syntax constraints are observed when generating any signed material including the signedinfo element attributes having default values be explicitly present all entity references except amp lt gt apos quot and other character entities not representable in the encoding chosen be expanded attribute value white space be normalized 7.2 dom sax processing and canonicalization in addition to the canonicalization and syntax constraints discussed above many xml applications use the document object model dom-level-1 or the simple api for xml sax dom maps xml into a tree structure of nodes and typically assumes it will be used on an entire document with subsequent processing being done on this tree. sax converts xml into a series of events such as a start tag content etc. in either case many surface characteristics such as the ordering of attributes and insignificant white space within start end tags is lost. in addition namespace declarations are mapped over the nodes to which they apply losing the namespace prefixes in the source text and in most cases losing where namespace declarations appeared in the original instance. if an xml signature is to be produced or verified on a system using the dom or sax processing a canonical method is needed to serialize the relevant part of a dom tree or sequence of sax events. xml canonicalization specifications such as xml-c14n are based only on information which is preserved by dom and sax. for an xml signature to be verifiable by an implementation using dom or sax not only must the xml 1.0 syntax constraints given in the section 7.1 xml 1.0 syntax constraints and canonicalization be followed but an appropriate xml canonicalization must be specified so that the verifier can re-serialize dom sax mediated input into the same octet stream that was signed. 7.3 namespace context and portable signatures in xpath and consequently the canonical xml data model an element has namespace nodes that correspond to those declarations within the element and its ancestors note an element e has namespace nodes that represent its namespace declarations as well as any namespace declarations made by its ancestors that have not been overridden in e s declarations the default namespace if it is non-empty and the declaration of the prefix xml. xml-c14n when serializing a signature element or signed xml data that s the child of other elements using these data models that signature element and its children may have in-scope namespaces inherited from its ancestral context. in addition the canonical xml and canonical xml with comments algorithms define special treatment for attributes in the xml namespace which can cause them to be part of the canonicalized xml even if they were outside of the document subset. simple inheritable attributes i.e. attributes that have a value that requires at most a simple redeclaration such as xml lang and xml space are inherited from nearest ancestor in which they are declared to the apex node of canonicalized xml unless they are already declared at that node. this may frustrate the intent of the signer to create a signature in one context which remains valid in another. for example given a signature which is a child of b and a grandchild of a example 26 a xmlns n1 http foo.example b xmlns n2 http bar.example signature xmlns http www.w3.org 2000 09 xmldsig# reference uri signme signature c id signme xmlns http baz.example b a when either the element b or the signed element c is moved into a soap12-part1 envelope for transport example 27 soap envelope xmlns soap http schemas.xmlsoap.org soap envelope soap body b xmlns n2 http bar.example signature xmlns http www.w3.org 2000 09 xmldsig# signature c id signme xmlns http baz.example b soap body soap envelope the canonical form of the signature in this context will contain new namespace declarations from the soap envelope context invalidating the signature. also the canonical form will lack namespace declarations it may have originally had from element a s context also invalidating the signature. to avoid these problems the application may rely upon the enveloping application to properly divorce its body the signature payload from the context the envelope before the signature is validated. or use a canonicalization method that repels excludes instead of attracts ancestor context. xml-c14n purposefully attracts such context. 8. security considerations the xml signature specification provides a very flexible digital signature mechanism. implementers must give consideration to their application threat models and to the following factors. for additional security considerations in implementation and deployment of this specification see xmldsig-bestpractices 8.1 transforms a requirement of this specification is to permit signatures to apply to a part or totality of a xml document. see xmldsig-requirements section 3.1.3 the transforms mechanism meets this requirement by permitting one to sign data derived from processing the content of the identified resource. for instance applications that wish to sign a form but permit users to enter limited field data without invalidating a previous signature on the form might use xpath to exclude those portions the user needs to change. transforms may be arbitrarily specified and may include encoding transforms canonicalization instructions or even xslt transformations. three cautions are raised with respect to this feature in the following sections. note core validation behavior does not confirm that the signed data was obtained by applying each step of the indicated transforms. though it does check that the digest of the resulting content matches that specified in the signature. for example some applications may be satisfied with verifying an xml signature over a cached copy of already transformed data. other applications might require that content be freshly dereferenced and transformed. 8.1.1 only what is signed is secure first obviously signatures over a transformed document do not secure any information discarded by transforms only what is signed is secure. note that the use of canonical xml xml-c14n ensures that all internal entities and xml namespaces are expanded within the content being signed. all entities are replaced with their definitions and the canonical form explicitly represents the namespace that an element would otherwise inherit. applications that do not canonicalize xml content especially the signedinfo element should not use internal entities and should represent the namespace explicitly within the content being signed since they can not rely upon canonicalization to do this for them. also users concerned with the integrity of the element type definitions associated with the xml instance being signed may wish to sign those definitions as well i.e. the schema dtd or natural language description associated with the namespace identifier second an envelope containing signed information is not secured by the signature. for instance when an encrypted envelope contains a signature the signature does not protect the authenticity or integrity of unsigned envelope headers nor its ciphertext form it only secures the plaintext actually signed. 8.1.2 only what is seen should be signed additionally the signature secures any information introduced by the transform only what is seen that which is represented to the user via visual auditory or other media should be signed. if signing is intended to convey the judgment or consent of a user an automated mechanism or person then it is normally necessary to secure as exactly as practical the information that was presented to that user. note that this can be accomplished by literally signing what was presented such as the screen images shown a user. however this may result in data which is difficult for subsequent software to manipulate. instead one can sign the data along with whatever filters style sheets client profile or other information that affects its presentation. 8.1.3 see what is signed just as a user should only sign what he or she sees persons and automated mechanism that trust the validity of a transformed document on the basis of a valid signature should operate over the data that was transformed including canonicalization and signed not the original pre-transformed data. this recommendation applies to transforms specified within the signature as well as those included as part of the document itself. for instance if an xml document includes an embedded style sheet xslt it is the transformed document that should be represented to the user and signed. to meet this recommendation where a document references an external style sheet the content of that external resource should also be signed as via a signature reference otherwise the content of that external content might change which alters the resulting document without invalidating the signature. some applications might operate over the original or intermediary data but should be extremely careful about potential weaknesses introduced between the original and transformed data. this is a trust decision about the character and meaning of the transforms that an application needs to make with caution. consider a canonicalization algorithm that normalizes character case lower to upper or character composition e and accent to accented-e an adversary could introduce changes that are normalized and consequently inconsequential to signature validity but material to a dom processor. for instance by changing the case of a character one might influence the result of an xpath selection. a serious risk is introduced if that change is normalized for signature validation but the processor operates over the original data and returns a different result than intended. as a result all documents operated upon and generated by signature applications must be in nfc otherwise intermediate processors might unintentionally break the signature encoding normalizations should not be done as part of a signature transform or to state it another way if normalization does occur the application should always see operate over the normalized form. 8.2 check the security model this specification uses public key signatures and keyed hash authentication codes. these have substantially different security models. furthermore it permits user specified algorithms which may have other models. with public key signatures any number of parties can hold the public key and verify signatures while only the parties with the private key can create signatures. the number of holders of the private key should be minimized and preferably be one. confidence by verifiers in the public key they are using and its binding to the entity or capabilities represented by the corresponding private key is an important issue usually addressed by certificate or online authority systems. keyed hash authentication codes based on secret keys are typically much more efficient in terms of the computational effort required but have the characteristic that all verifiers need to have possession of the same key as the signer. thus any verifier can forge signatures. this specification permits user provided signature algorithms and keying information designators. such user provided algorithms may have different security models. for example methods involving biometrics usually depend on a physical characteristic of the authorized user that can not be changed the way public or secret keys can be and may have other security model differences. 8.3 algorithms key lengths certificates etc. the strength of a particular signature depends on all links in the security chain. this includes the signature and digest algorithms used the strength of the key generation random and the size of the key the security of key and certificate authentication and distribution mechanisms certificate chain validation policy protection of cryptographic processing from hostile observation and tampering etc. care must be exercised by applications in executing the various algorithms that may be specified in an xml signature and in the processing of any executable content that might be provided to such algorithms as parameters such as xslt transforms. the algorithms specified in this document will usually be implemented via a trusted library but even there perverse parameters might cause unacceptable processing or memory demand. even more care may be warranted with application defined algorithms. the security of an overall system will also depend on the security and integrity of its operating procedures its personnel and on the administrative enforcement of those procedures. all the factors listed in this section are important to the overall security of a system however most are beyond the scope of this specification. 8.4 error messages implementations should not provide detailed error responses related to security algorithm processing. error messages should be limited to a generic error message to avoid providing information to a potential attacker related to the specifics of the algorithm implementation. for example if an error occurs in signature verification processing the error response should be a generic message providing no specifics on the details of the processing error. 9. schema 9.1 xsd schema xml signature core schema instance xmldsig-core-schema.xsd valid xml schema instance based on xmlschema-1 xmlschema-2 xml signature 1.1 schema instance xmldsig11-schema.xsd this schema document defines the additional elements defined in this version of the xml signature specification. xml signature 1.1 schema driver xmldsig1-schema.xsd this schema instance binds together the xml signature core schema instance and the xml signature 1.1 schema instance 9.2 rng schema this section is non-normative. non-normative relax ng schema relaxng-schema information is available in a separate document xmlsec-relaxng 10. definitions authentication code protected checksum a value generated from the application of a shared key to a message via a cryptographic algorithm such that it has the properties of message authentication and integrity but not signer authentication. equivalent to protected checksum a checksum that is computed for a data object by means that protect against active attacks that would attempt to change the checksum to make it match changes made to the data object. rfc4949 authentication message the property given an authentication code protected checksum that tampering with both the data and checksum so as to introduce changes while seemingly preserving integrity are still detected. a signature should identify what is signed making it impracticable to falsify or alter either the signed matter or the signature without detection. aba-dsig-guidelines authentication signer the property that the identity of the signer is as claimed. a signature should indicate who signed a document message or record and should be difficult for another person to produce without authorization. aba-dsig-guidelines note signer authentication is an application decision e.g. does the signing key actually correspond to a specific identity that is supported by but out of scope of this specification. checksum a value that a is computed by a function that is dependent on the contents of a data object and b is stored or transmitted together with the object for the purpose of detecting changes in the data. rfc4949 core the syntax and processing defined by this specification including core validation. we use this term to distinguish other markup processing and applications semantics from our own. data object content document the actual binary octet data being operated on transformed digested or signed by an application frequently an http entity http11 note that the proper noun object designates a specific xml element. occasionally we refer to a data object as a document or as a resource s content. the term element content is used to describe the data between xml start and end tags xml10 the term xml document is used to describe data objects which conform to the xml specification xml10 integrity the property that data has not been changed destroyed or lost in an unauthorized or accidental manner. rfc4949 a simple checksum can provide integrity from incidental changes in the data message authentication is similar but also protects against an active attack to alter the data whereby a change in the checksum is introduced so as to match the change in the data. object an xml signature element wherein arbitrary non-core data may be placed. an object element is merely one type of digital data or document that can be signed via a reference. resource a resource can be anything that has identity. familiar examples include an electronic document an image a service e.g. today s weather report for los angeles and a collection of other resources.... the resource is the conceptual mapping to an entity or set of entities not necessarily the entity which corresponds to that mapping at any particular instance in time. thus a resource can remain constant even when its content---the entities to which it currently corresponds---changes over time provided that the conceptual mapping is not changed in the process. uri in order to avoid a collision of the term entity within the uri and xml specifications we use the term data object content or document to refer to the actual bits octets being operated upon. signature formally speaking a value generated from the application of a private key to a message via a cryptographic algorithm such that it has the properties of integrity message authentication and or signer authentication. however we sometimes use the term signature generically such that it encompasses authentication code values as well but we are careful to make the distinction when the property of signer authentication is relevant to the exposition. a signature may be non-exclusively described as detached enveloping or enveloped. signature application an application that implements the mandatory required must portions of this specification these conformance requirements are over application behavior the structure of the signature element type and its children including signaturevalue and the specified algorithms. signature detached the signature is over content external to the signature element and can be identified via a uri or transform. consequently the signature is detached from the content it signs. this definition typically applies to separate data objects but it also includes the instance where the signature and data object reside within the same xml document but are sibling elements. signature enveloping the signature is over content found within an object element of the signature itself. the object or its content is identified via a reference via a uri fragment identifier or transform signature enveloped the signature is over the xml content that contains the signature as an element. the content provides the root xml document element. obviously enveloped signatures must take care not to include their own value in the calculation of the signaturevalue. transform the processing of a data from its source to its derived form. typical transforms include xml canonicalization xpath and xslt. validation core the core processing requirements of this specification requiring signature validation and signedinfo reference validation. validation reference the hash value of the identified and transformed content specified by reference matches its specified digestvalue. validation signature the signaturevalue matches the result of processing signedinfo with canonicalizationmethod and signaturemethod as specified in core validation section 3.2 validation trust application the application determines that the semantics associated with a signature are valid. for example an application may validate the time stamps or the integrity of the signer key though this behavior is external to this core specification. a. references dated references below are to the latest known or appropriate edition of the referenced work. the referenced works may be subject to revision and conformant implementations may follow and are encouraged to investigate the appropriateness of following some or all more recent editions or replacements of the works cited. it is in each case implementation-defined which editions are supported. a.1 normative references ecc-algs d. mcgrew k. igoe m. salter. rfc 6090 fundamental elliptic curve cryptography algorithms. february 2011. ietf informational rfc. url http www.rfc-editor.org rfc rfc6090.txt fips-180-3 fips pub 180-3 secure hash standard. u.s. department of commerce national institute of standards and technology. url http csrc.nist.gov publications fips fips180-3 fips180-3_final.pdf fips-186-3 fips pub 186-3 digital signature standard dss june 2009. u.s. department of commerce national institute of standards and technology. url http csrc.nist.gov publications fips fips186-3 fips_186-3.pdf hmac h. krawczyk m. bellare r. canetti. hmac keyed-hashing for message authentication. february 1997. ietf rfc 2104. url http www.ietf.org rfc rfc2104.txt http11 r. fielding et al. hypertext transfer protocol http 1.1. june 1999. rfc 2616. url http www.ietf.org rfc rfc2616.txt ldap-dn k. zeilenga. lightweight directory access protocol string representation of distinguished names. june 2006. ietf rfc 4514. url http www.ietf.org rfc rfc4514.txt nfc m. davis ken whistler. tr15 unicode normalization forms.. 17 september 2010 url http www.unicode.org reports tr15 pgp j. callas l. donnerhacke h. finney d. shaw r. thayer. openpgp message format. ietf rfc 4880. november 2007. url http www.ietf.org rfc rfc4880.txt pkcs1 j. jonsson and b. kaliski. public-key cryptography standards pkcs 1 rsa cryptography specifications version 2.1. rfc 3447 informational february 2003. url http www.ietf.org rfc rfc3447.txt rfc2045 n. freed and n. borenstein. multipurpose internet mail extensions mime part one format of internet message bodies. november 1996. url http www.ietf.org rfc rfc2045.txt rfc2119 s. bradner. key words for use in rfcs to indicate requirement levels. march 1997. internet rfc 2119. url http www.ietf.org rfc rfc2119.txt rfc3279 w. polk r. housley l. bassham. algorithmupdates and identifiers for the internet x.509 public key infrastructure certificate and certificate revocation list crl profile. april 2002. internet rfc 3279. url http www.ietf.org rfc rfc3279.txt rfc3406 l. daigle d. van gulik r. iannella p. faltstrom. urn namespace definition mechanisms.. ietf rfc 3406 october 2002. url http www.ietf.org rfc rfc3406.txt rfc4055 j. schaad b. kaliski r. housley. additional algorithms and identifiers for rsa cryptography for use in the internet x.509 public key infrastructure certificate and certificate revocation list crl profile. june 2005. ietf rfc 4055. url http www.ietf.org rfc rfc4055.txt rfc5280 d. cooper et. al. internet x.509 public key infrastructure certificate and certificate revocation list crl profile. ietf rfc 5280 may 2008. url http www.ietf.org rfc rfc5280.txt rfc5480 s. turner et. al. elliptic curve cryptography subject public key information.. ietf rfc 5480 march 2009. url http www.ietf.org rfc rfc5480.txt rfc6931 d. eastlake 3rd. additional xml security uniform resource identifiers. rfc 6931 april 2013. url http tools.ietf.org html rfc6931 sp800-57 recommendation for key management part 1 general revision 3 sp800-57. july 2012. u.s. department of commerce national institute of standards and technology. url http csrc.nist.gov publications nistpubs 800-57 sp800-57_part1_rev3_general.pdf uri t. berners-lee r. fielding l. masinter. uniform resource identifiers uri generic syntax. january 2005. rfc 3986. url http www.ietf.org rfc rfc3986.txt urn r. moats. urn syntax. ietf rfc 2141. may 1997. url http www.ietf.org rfc rfc2141.txt urn-oid m. mealling. a urn namespace of object identifiers. ietf rfc 3061. february 2001. url http www.ietf.org rfc rfc3061.txt utf-8 f. yergeau. utf-8 a transformation format of iso 10646. ietf rfc 3629. november 2003. url http www.ietf.org rfc rfc3629.txt x509v3 itu-t recommendation x.509 version 3 1997 information technology open systems interconnection the directory authentication framework iso iec 9594-8 1997. xml-c14n john boyer. canonical xml version 1.0. 15 march 2001. w3c recommendation. url http www.w3.org tr 2001 rec-xml-c14n-20010315 xml-c14n11 john boyer glenn marcy. canonical xml version 1.1. 2 may 2008. w3c recommendation. url http www.w3.org tr 2008 rec-xml-c14n11-20080502 xml-exc-c14n donald e. eastlake 3rd joseph reagle john boyer. exclusive xml canonicalization version 1.0. 18 july 2002. w3c recommendation. url http www.w3.org tr 2002 rec-xml-exc-c14n-20020718 xml-media-types mit yal nalp anish karmarkar. describing media content of binary data in xml. 4 may 2005. w3c note. url http www.w3.org tr 2005 note-xml-media-types-20050504 xml-names richard tobin et al. namespaces in xml 1.0 third edition 8 december 2009. w3c recommendation. url http www.w3.org tr 2009 rec-xml-names-20091208 xml10 c. m. sperberg-mcqueen et al. extensible markup language xml 1.0 fifth edition 26 november 2008. w3c recommendation. url http www.w3.org tr 2008 rec-xml-20081126 xmldsig-xpath-filter2 merlin hughes john boyer joseph reagle. xml-signature xpath filter 2.0. 8 november 2002. w3c recommendation. url http www.w3.org tr 2002 rec-xmldsig-filter2-20021108 xmlenc-core1 j. reagle d. eastlake f. hirsch t. roessler. xml encryption syntax and processing version 1.1. 11 april 2013. w3c recommendation. url http www.w3.org tr 2013 rec-xmlenc-core1-20130411 xmlschema-1 henry s. thompson et al. xml schema part 1 structures second edition. 28 october 2004. w3c recommendation. url http www.w3.org tr 2004 rec-xmlschema-1-20041028 xmlschema-2 paul v. biron ashok malhotra. xml schema part 2 datatypes second edition. 28 october 2004. w3c recommendation. url http www.w3.org tr 2004 rec-xmlschema-2-20041028 xpath james clark steven derose. xml path language xpath version 1.0. 16 november 1999. w3c recommendation. url http www.w3.org tr 1999 rec-xpath-19991116 xptr-element norman walsh et al. xpointer element scheme. 25 march 2003. w3c recommendation. url http www.w3.org tr 2003 rec-xptr-element-20030325 xptr-framework paul grosso et al. xpointer framework. 25 march 2003. w3c recommendation. url http www.w3.org tr 2003 rec-xptr-framework-20030325 xsl10 jeremy richman et al. extensible stylesheet language xsl version 1.0. 15 october 2001. w3c recommendation. url http www.w3.org tr 2001 rec-xsl-20011015 xslt james clark. xsl transformations xslt version 1.0. 16 november 1999. w3c recommendation. url http www.w3.org tr 1999 rec-xslt-19991116 a.2 informative references aba-dsig-guidelines digital signature guidelines. 1 august 1996. information security committee american bar association. url http www.signelec.com content download digital_signature_guidelines.pdf cve-2009-0217 common vulnerabilities and exposures list cve-2009-0217 url http cve.mitre.org cgi-bin cvename.cgi name cve-2009-0217 dom-level-1 vidur apparao et al. document object model dom level 1. 1 october 1998. w3c recommendation. url http www.w3.org tr 1998 rec-dom-level-1-19981001 ieee1363 ieee 1363 standard specifications for public key cryptography. august 2000. url http grouper.ieee.org groups 1363 random d. eastlake s. crocker j. schiller. randomness recommendations for security.. ietf rfc 4086. june 2005. url http www.ietf.org rfc rfc4086.txt rdf-primer frank manola eric miller. rdf primer. 10 february 2004. w3c recommendation. url http www.w3.org tr 2004 rec-rdf-primer-20040210 relaxng-schema information technology document schema definition language dsdl part 2 regular-grammar-based validation relax ng. iso iec 19757-2 2008. url http standards.iso.org ittf publiclyavailablestandards c052348_iso_iec_19757-2_2008 e zip rfc4050 s. blake-wilson g. karlinger t. kobayashi y. wang. using the elliptic curve signature algorithm ecdsa for xml digital signatures rfc 4050 april 2005. rfc. url http www.ietf.org rfc rfc4050.txt rfc4949 r. shirey. internet security glossary version 2.. ietf rfc 4949. august 2007. url http www.ietf.org rfc rfc4949.txt sax d. megginson et al. sax the simple api for xml. may 1998. url http www.megginson.com downloads sax sha-1-analysis mcdonald c. hawkes p. and j. pieprzyk. sha-1 collisions now 252 eurocrypt 2009 rump session. url http eurocrypt2009rump.cr.yp.to 837a0a8086fa6ca714249409ddfae43d.pdf sha-1-collisions x. wang y.l. yin h. yu. finding collisions in the full sha-1. in shoup v. editor advances in cryptology crypto 2005 25th annual international cryptology conference santa barbara california usa august 14-18 2005 proceedings volume 3621 of lncs pages 17 36. springer 2005. url http people.csail.mit.edu yiqun sha1attackproceedingversion.pdf also published in http www.springerlink.com content 26vljj3xhc28ux5m soap12-part1 noah mendelsohn et al. soap version 1.2 part 1 messaging framework second edition 27 april 2007. w3c recommendation. url http www.w3.org tr 2007 rec-soap12-part1-20070427 utf-16 p. hoffman f. yergeau. utf-16 an encoding of iso 10646. ietf rfc 2781. february 2000. url http www.ietf.org rfc rfc2781.txt xhtml10 steven pemberton. xhtml 1.0 the extensible hypertext markup language second edition 1 august 2002. w3c recommendation. url http www.w3.org tr 2002 rec-xhtml1-20020801 xml-japanese m. murata. xml japanese profile 2nd edition march 2005. w3c member submission. url http www.w3.org submission 2005 subm-japanese-xml-20050324 xmldsig-bestpractices pratik datta frederick hirsch. xml signature best practices. 11 april 2013. w3c working group note. url http www.w3.org tr 2013 note-xmldsig-bestpractices-20130411 xmldsig-core joseph reagle et al. xml signature syntax and processing second edition 10 june 2008. w3c recommendation. url http www.w3.org tr 2008 rec-xmldsig-core-20080610 xmldsig-core1-chgs frederick hirsch. functional explanation of changes in xml signature 1.1. 11 april 2013. w3c working group note. url http www.w3.org tr 2013 note-xmldsig-core1-explain-20130411 xmldsig-requirements joseph reagle jr. xml-signature requirements. 14 october 1999. w3c working draft. url http www.w3.org tr 1999 wd-xmldsig-requirements-19991014 xmlsec-relaxng makoto murata frederick hirsch. xml security relax ng schemas. 11 april 2013. w3c working group note. url http www.w3.org tr 2013 note-xmlsec-rngschema-20130411 xmlsec11-reqs frederick hirsch thomas roessler. xml security 1.1 requirements and design considerations. 11 april 2013. w3c working group note. url http www.w3.org tr 2013 note-xmlsec-reqs-20130411 xptr-xmlns jonathan marsh et al. xpointer xmlns scheme. 25 march 2003. w3c recommendation. url http www.w3.org tr 2003 rec-xptr-xmlns-20030325 xptr-xpointer ron daniel jr eve maler steven derose. xpointer xpointer scheme. 19 december 2002. w3c working draft. url http www.w3.org tr 2002 wd-xptr-xpointer-20021219 xptr-xpointer-cr2001 ron daniel jr eve maler steven derose. xpointer xpointer scheme. september 2001. w3c candidate recommendation. url http www.w3.org tr 2001 cr-xptr-20010911 