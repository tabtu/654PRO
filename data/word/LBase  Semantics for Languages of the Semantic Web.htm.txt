lbase semantics for languages of the semantic web lbase semantics for languages of the semantic web w3c working group note 10 october 2003 this version http www.w3.org tr 2003 note-lbase-20031010 latest version http www.w3.org tr lbase previous version http www.w3.org tr 2003 note-lbase-20030905 authors r.v.guha ibm rguha@us.ibm.com patrick hayes ihmc phayes@ihmc.us copyright 2003 w3c mit ercim keio all rights reserved. w3c liability trademark document use and software licensing rules apply. abstract this document presents a framework for specifying the semantics for the languages of the semantic web. some of these languages notably rdf rdf-primer rdf-vocabulary rdf-syntax rdf-concepts rdf-semantics and owl owl are currently in various stages of development and we expect others to be developed in the future. this framework is intended to provide a framework for specifying the semantics of all of these languages in a uniform and coherent way. the strategy is to translate the various languages into a common base language thereby providing them with a single coherent model theory. we describe a mechanism for providing a precise semantics for the semantic web languages referred to as swels from now on. the purpose of this is to define clearly the consequences and allowed inferences from constructs in these languages. status of this document this section describes the status of this document at the time of its publication. other documents may supersede this document. a list of current w3c publications and the latest revision of this technical report can be found in the w3c technical reports index at http www.w3.org tr publication as a working group note does not imply endorsement by the w3c membership. this is a draft document and may be updated replaced or obsoleted by other documents at any time. it is inappropriate to cite this document as other than work in progress. this document results from discussions within the rdf core working group concerning the formalization of rdf and rdf-based languages. the rdf core working group is part of the w3c semantic web activity. the group s goals and requirements are discussed in the rdf core working group charter. these include requirements that... the rdf core group must take into account the various formalizations of rdf that have been proposed since the publication of the rdf model and syntax recommendation. the group is encouraged to make use both of formal techniques and implementation-led test cases throughout their work. the rdf schema system must provide an extensibility mechanism to allow future work for example on web ontology and logic-based rule languages to provide richer facilities. this document is motivated by these two requirements. it does not present an rdf core wg design for semantic web layering. rather it documents a technique that the rdf core wg are using in our discussions and in the rdf semantics specification. the rdf core wg solicit feedback from other working groups and from the rdf implementor community on the wider applicability of this technique. note that the use of the abbreviation swel in lbase differs from the prior use of swell in the mit lcs daml project. in conformance with w3c policy requirements known patent and ipr constraints associated with this note are detailed on the rdf core working group patent disclosure page. review comments on this document are invited and should be sent to the public mailing list www-rdf-comments@w3.org. an archive of comments is available at http lists.w3.org archives public www-rdf-comments discussion of this document is invited on the www-rdf-logic@w3.org list of the rdf interest group public archives table of contents 1 model-theoretic semantics 2 outline of approach 2.1 consistency 2.2 lbase syntax 2.3 interpretations 2.4 axiom schemas 2.5 entailment 3 using lbase 3.1 relation between the two... 4 inadequacies of 5 acknowledgements 6 references 7 change log 1. model-theoretic semantics a model-theoretic semantics for a language assumes that the language refers to a world and describes the minimal conditions that a world must satisfy in order to assign an appropriate meaning for every expression in the language. a particular world is called an interpretation so that model theory might be better called interpretation theory the idea is to provide a mathematical account of the properties that any such interpretation must have making as few assumptions as possible about its actual nature or intrinsic structure. model theory tries to be metaphysically and ontologically neutral. it is typically couched in the language of set theory simply because that is the normal language of mathematics for example this semantics assumes that names denote things in a set ir called the universe but the use of set-theoretic language here is not supposed to imply that the things in the universe are set-theoretic in nature. the chief utility of such a semantic theory is not to suggest any particular processing model or to provide any deep uow.acc.tab.analysis of the nature of the things being described by the language but rather to provide a technical tool to analyze the semantic properties of proposed operations on the language in particular to provide a way to determine when they preserve meaning. any proposed inference rule for example can be checked to see if it is valid with respect to a model theory i.e. if its conclusions are always true in any interpretation which makes its antecedents true. we note that the word model is often used in a rather different sense eg as in data model to refer to a computational system or data structures of some kind. to avoid misunderstanding we emphasise that the interpretations referred to in a model theory are not in general intended to be thought of as things that can be computed or manipulated by computers. 2. outline of approach there will be many semantic web languages most of which will be built on top of more basic semantic web language s it is important that this layering be clean and simple not just for human understandability but also to enable the construction of robust semantic web agents that use these languages. the emerging current practice is for each of the swels to be defined in terms of their own model theory layering it on top of the model theories of the languages they are layered upon. while having a model theory is clearly desireable and even essential for a swel this direct-construction approach has several problems. it produces a range of model theories each with its own notion of consequence and entailment. it requires expertise in logic to make sure that model theories align properly and model-theoretic alignment does not always sit naturally with interoperability requirements. experience to date particularly with the owl standard under development at the time of writing by the w3c webont working group shows that quite difficult problems can arise when layering model theories for extensions to the basic rdf layer rdf of the semantic web. moreover this strategy places a very high burden on the basic layer since it is difficult to anticipate the semantic demands which will be made by all future higher layers and the expectations of different development and user communities may conflict. further we believe that a melange of model theories will adversely impact developers building agents that implement proof systems for these layers since the proof systems will likely be different for each layer resulting in the need to micro-manage small semantic variations for various dialects and sub-languages cf. the distinctions between various dialects of owl in this document we use an alternative approach to for defining the semantics for the different swels in a fashion which ensures interoperability. we first define a basic language lbase which is expressive enough to state the content of all currently proposed web languages and has a fixed clear model-theoretic semantics. then the semantics of each swel li is defined by specifying how expressions in the li map into equivalent expressions in lbase and by providing axioms written in lbase which constrain the intended meanings of the swel special vocabulary. the lbase meaning of any expression in any swel language can then be determined by mapping it into lbase and adding the appropriate language axioms if there are any. the intended result is that the model theory of lbase is the model theory of all the semantic web languages even though the languages themselves are different. this makes it possible to use a single inference mechanism to work on these different languages. although it will possible to exploit restrictions on the languages to provide better performance the existence of a reference proof system is likely to be of utility to developers. this also allows the meanings of expressions in different swels to be compared and combined which is very difficult when they all have distinct model theories. the idea of providing a semantics for swels by translating them into logic is not new see for example marchiolri&saarela fikes&mcguinness but we plan to adopt a somewhat different style than previous axiomatic semantics which have usually operated by mapping all rdf triples to instances of a single three-place predicate. we propose rather to use the logical form of the target language as an explication of the intended meaning of the swel rather than simply as an axiomatic description of that meaning so that rdf classes translate to unary predicates rdf properties to binary relations the relation rdf type translates to application of a predicate to an argument and list-valued properties in owl or daml can be translated into n-ary or variadic relations. the syntax and semantics of lbase have been designed with this kind of translation in mind. it is our intent that the model theory of lbase be used in the spirit of its model theory and not as a programming language i.e. relations in li should correspond to relations in lbase variables should correspond to variables and so on. it is important to note that lbase is not being proposed as a swel. it is a tool for specifying the semantics of different swels. the syntax of lbase described here is not intended to be accessible for machine processing any such proposal should be considered to be a proposal for a more expressive swel. 2.1 consistency by using a well understood logic i.e. first order logic enderton as the core of lbase and providing for mutually consistent mappings of different swels into lbase we ensure that the content expressed in several swels can be combined consistently avoiding paradoxes and other problems. mapping type class language into predicate application language also ensures that set-theoretical paradoxes do not arise. although the use of this technique does not in itself guarantee that mappings between the syntax of different swels will always be consistent it does provide a general framework for detecting and identifying potential inconsistencies. it is also important that the axioms defining the vocabulary items introduced by a swel are internally consistent. although first-order logic and hence lbase is only semi-decideable we are confident that it will be routine to construct lbase interpretations which establish the relevant consistencies for all the swels currently contemplated. in the general case future efforts may have to rely on certifications from particular automated theorem provers stating that they weren t able to find an inconsistency with certain stated levels of effort. the availablity of powerful inference engines for first-order logic is of course relevant here. 2.1.1 lbase in this document we use a version of first order logic with equality as lbase. this imposes a fairly strict monotonic discipline on the language so that it cannot express local default preferences and several other commonly-used non-monotonic constructs. we expect that as the semantic web grows to encompass more and our understanding of the semantic web improves we will need to replace this lbase with more expressive logics. however we expect that first order logic will be a proper subset of such systems and hence we will be able to smoothly transition to more expressive lbase languages in the future. we note that the computational advantages claimed for various sublanguages of first-order logic such as description logics logical programming languages and frame languages are irrelevant for the purposes of using lbase as a semantic specification language. we will use first order logic with suitable minor changes to account for the use of referring expressions such as uris on the web and a few simple extensions to improve utility for the intended purposes. 2.1.2 names and variables any first-order logic is based on a set of atomic terms which are used as the basic referring expressions in the syntax. these include names which refer to entities in the domain special names and variables. lbase distinguishes the special class of urirefs defined to be a uri reference in the sense of uri urirefs are used to refer to both individuals and relations between the individuals. a name may be any string of unicode characters not starting with the characters or and containing no whitespace characters or any string of unicode characters enclosed by the symbols and the enclosed style is provided to allow names which would otherwise violate the lbase syntactic conventions in this case it is understood that the actual name is the enclosed string. for example the name br eight characters including a space can be written in lbase as br lbase allows for various collections of special names with fixed meanings defined by other specifications external to the lbase specification there is no assumption that these could be defined by collections of lbase axioms so that imposing the intended meanings on these special names may go beyond strict first-order expressiveness. in mathematical terms we allow that some sets of names refer to elements of certain fixed algebras even when the algebra has no characteristic first-order description. each such set of names has an associated predicate which is true of the things denoted by the names in the set. at present we assume two categories of such fixed names numerals and quoted strings with associated predicate names natnumber and string respectively. we expect that other categories of special names will be introduced to handle eg. xml structures. numerals are defined to be strings of the characters 0123456789 and are interpreted as decimal numerals in the usual way. since arithmetic is not first-order definable this is the first and most obvious place that lbase goes beyond first-order expressiveness. quoted strings are arbitrary character sequences enclosed in single quotation marks and are interpreted as denoting the string inside the quotation marks. to avoid ambiguity single quote marks in strings are prefixed by a backslash character which acts an escape character so that a denotes the string a double quote marks have no special interpretation. the associated predicate names natnumber string and relation see below are considered to be special names. a variable is any non-white-space character string starting with the character the characters and are considered to be punctuation symbols. the categories of punctuation whitespace names special names and variables are exclusive and each such string can be classified by examining its first character. this is not strictly necessary but is a useful convention. any lbase language is defined with respect to a vocabulary which is a set of non-special names. we require that every lbase vocabulary contain all urirefs but other expressions are allowed. we will require that every lbase interpretation provide a meaning for every special name but these interpretations are fixed so special names are not counted as part of the vocabulary. there are several aspects of meaning of expressions on the semantic web which are not yet treated by this semantics in particular it treats uris as simple names ignoring aspects of meaning encoded in particular uri forms rfc 2396 and does not provide any uow.acc.tab.analysis of time-varying data or of changes to uri denotations. the model theory also has nothing to say about whether an http uri such as http www.w3.org denotes the world wide web consortium or the html page accessible at that uri or the web site accessible via that uri. these complexities may be addressed in future extensions of lbase in general we expect that lbase will be extended both notationally and by adding axioms in order to track future standardization efforts. we do not take any position here on the way that urirefs may be composed from other expressions e.g. from relative uris or qnames the model theory simply assumes that such lexical issues have been resolved in some way that is globally coherent so that a single uriref can be taken to have the same meaning wherever it occurs. similarly the model theory given here has no special provision for tracking temporal changes. it assumes implicitly that urirefs have the same meaning whenever they occur. to provide an adequate semantics which would be sensitive to temporal changes is a research problem which is beyond the scope of this document.. 2.2 lbase syntax even though the exact syntax chosen for lbase is not important we do need a syntax for the specification. we follow the same general conventions used in most standard presentations of first-order logic with one generalization which has proven useful. we will assume that there are three sets of names not special names which together constitute the vocabulary individual names relation names and function names and that each function name has an associated arity which is a non-negative integer. in a particular vocabulary these sets may or may not be disjoint. expressions in lbase speaking strictly lbase expressions in this particular vocabulary are then constructed recursively as follows a term is either a name or a special name or a variable or else it has the form f t1 tn where f is an n-ary function name and t1 tn are terms. a formula is either atomic or boolean or quantified where an atomic formula has the form t1 t2 where t1 and t2 are terms or else the form r t1 tn where r is a relation name or a variable and t1 tn are terms a boolean formula has one of the forms w1 and w2 and and wn w1 or w2 or or wn w1 implies w2 w1 iff w2 not w1 where w1 wn are formulae and a quantified formula has one of the forms forall v1 vn w exists v1 vn w where v1 vn are variables and w is a formula. the subexpression just after the quantifier is the variable list of the quantifier. any occurrence of a variable in w is said to be bound in the quantified formula by the nearest quantifer to the occurrence which includes that variable in its variable list if there is one otherwise it is said to be free in the formula. finally an lbase knowledge base is a set of formulae. formulae are also called wellformed formulae or wffs or simply expressions in general surplus brackets may be omitted from expressions when no syntactic ambiguity would arise. some comments may be in order. the only parts of this definition which are in any way nonstandard are 1 allowing special names which was discussed earlier 2 allowing variables to occur in relation position which might seem to be at odds with the claim that lbase is first-order we discuss this further below and 3 not assigning a fixed arity to relation names. this last is a useful generalization which makes no substantial changes to the usual semantic properties of first-order logic but which eases the translation process for some swel syntactic constructs. the computational properties of such variadic relations are quite complex but lbase is not being proposed as a language for computational use. 2.3 interpretations satisfaction the following definition of an interpretation is couched in mathematical language but what it amounts to intuitively is that an interpretation provides just enough information about a possible way the world might be a possible world in order to fix the truth-value true or false of any lbase well formed formula in that world. it does this by specifying for each uriref what it is supposed to be a name of and also if it is a function symbol what values the function has for each choice of arguments and further if it is a relation symbol which sequences of things the relation holds between. this is just enough information to determine the truth-values of all atomic formulas and then this together with a set of recursive rules is enough to assign a truth value for any lbase formula. in specifying the following it is convenient to define use some standard definitions. a relation over a set s is a set of finite sequences tuples of members of s. if r is a relation and all the elements of r have the same length n then r is said to have arity n or to be a n-ary relation. not every relation need have an arity. if r is an n+1 ary relation over s which has the property that for any sequence s1 sn of members of s there is exactly one element of r of the form s0 s1 sn then r is an n-ary function and s0 is the value of the function for the arguments s1 sn. note that an n-ary function is an n+1 ary relation and that by convention the function value is the first argument of the relation so that for any n-ary function f f y x1 xn means the same as y f x1 xn the conventional textbook treatment of first-order interpretations assumes that relation symbols denote relations. we will modify this slightly to require that relation symbols denote entities with an associated relation called the relational extension and will sometimes abuse terminology by referring to the entities with relational extensions as relations. this device gives lbase some of the freedom to quantify over relations which would be familiar in a higher-order logic while remaining strictly a first-order language in its semantic and metatheoretic properties. we will use the special name relation to denote the property of having a relational extension. let vv be the set of all variables and nn be the set of all special names. we will assume that there is a globally fixed mapping sn from elements of nn to a domain isn i.e consisting of character strings and integers the exact specification of sn is given for numerals by the usual reading of a decimal numeral to denote a natural number and for quoted strings by the dequotation rules described earlier. an interpretation i of a vocabulary v is then a structure defined by a set id called the domain or universe of i a mapping is from v union vv into id a mapping iext from ir a subset of id into a relation over id+isn ie a set of tuples of elements of id+isn which satisfies the following conditions for any n-ary function symbol f in v iext i f is an n-ary function over id+isn. iext i natnum n n a natural number iext i string s s a character string iext i relation ir an interpretation then specifies the value of any other lbase expression e according to the following rules if e is then i e is a name or a variable is e a special name sn e a term f t1 tn the value of iext i f for the arguments i t1 i tn an equation a b true if i a i b otherwise false a formula of the form r t1 t2 true if iext i r contains the sequence i t1 i tn otherwise false w1 and and wn true if i wi true for i 1 through n otherwise false w1 or or wn false if i wi false for i 1 through n otherwise true w1 w2 true if i w1 i w2 otherwise false w1 w2 false if i w1 true and i w2 false otherwise true not w true if i w false otherwise false if b is a mapping from a set w of variables into id then define i+b to be the interpretation which is like i except that i+b v b v for any variable v in w. if e is then i e is forall v1 vn w false if i+b w false for some mapping b from v1 vn into id otherwise true exist v1 vn w true if i+b w true for some mapping b from v1 vn into id otherwise false finally a knowledge base is considered to be true if and only if all its elements are true i.e. to be a conjunction of its elements. intuitively the meaning of an expression containing free variables is not well specified it is formally specified but the interpretation of the free variables is arbitrary. to resolve any confusion we impose a familiar convention by which any free variables in a sentence of a knowledge base are considered to be universally quantified at the top level of the expression in which they occur. equivalently one could insist that all variables in any knowledge-base expression be bound by a quantifier in that expression this would force the implicit quantification to be made explicit. these definitions are quite conventional. the only unusual features are the incorporation of special-name values into the domain the use of an explicit extension mapping the fact that relations are not required to have a fixed arity and the description of functions as a class of relations. the explicit extension mapping is a technical device to allow relations to be applied to other relations without going outside first-order expressivity. we note that while this allows the same name to be used in both an individual and a relation position and in a sense gives relations and hence functions a first-class status it does not incorporate any comprehension principles or make any logical assumptions about what relations are in the domain. notice that no special semantic conditions were invoked to treat variables in relation position differently from other variables. in particular the language makes no comprehension assumptions whatever. the resulting language is first-order in all the usual senses it is compact and satisfies the downward skolem-lowenheim property for example and the usual machine-oriented inference processes still apply in particular the unification algorithm. one can obtain a translation into a more conventional syntax by re-writing every atomic sentence using a rule of the form r t1 tn holds r t1 tn where holds is a dummy relation indicating that the relation r is true of the remaining arguments. the presentation given here eliminates the need for this artificial translation but its existence establishes the first-order properties of the language. to translate a conventional first-order syntax into the lbase form simply qualify all quantifiers to range only over non-relations. the issue is further discussed in hayes menzel ref allowing relations with no fixed arity is a technical convenience which allows lbase to accept more natural translations from some swels. it makes no significant difference to the metatheory of the formalism compared to a fixed-arity sytnax where each relation has a given arity. treating functions as a particular kind of relation allows us to use a function symbol in a relation position albeit with a fixed arity which is one more than its arity as a function this enables some of the translations to be specified more efficiently. as noted earlier incorporating special name interpretations in particular integers into the domain takes lbase outside strict first-order compliance but these domains have natural recursive definitions and are in common use throughout computer science. mechanical inference systems typically have special-purpose reasoners which can effectively test for satisfiability in these domains. notice that the incorporation of these special domains into an interpretation does not automatically incorporate all truths of a full theory of such structures into lbase for example the presence of the integers in the semantic domain does not in itself require all truths of arithmetic to be valid or provable in lbase. 2.4 axiom schemes an axiom scheme stands for an infinite set of lbase sentences all having a similar form we will allow schemes which are like lbase formulae except that expressions of the form exp1 expn ie two expressions of the same syntactic category separated by three dots can be used and such a schema is intended to stand for the infinite knowledge base containing all the lbase formulae gotten by substituting some actual sequence of appropriate expressions terms or variables or formulae for the expression shown which we call the lbase instances of the scheme. we have in fact been using this convention already but informally now we are making it formal. for example the following is an lbase scheme forall v1... vn r v1... vn implies q a v2... vn where the expression after the first quantifier is an actual scheme expression not a conventional abbreviation which has the following lbase instances among others forall x r x implies q a x forall y yy z r y yy z implies q a y yy z axiom schemes do not take the language beyond first-order since all the instances are first-order sentences and the language is compact so if any lbase sentence follows from the infinite set of instances of an axiom scheme then it must in fact be entailed by some finite set of instances of that scheme. we note that lbase schemes should be understood only as syntactic abbreviations for infinite sets of lbase sentences when stating translation rules and specifying axiom sets. since all lbase expressions are required to be finite one should not think of lbase schemes as themselves being sentences for example as making assertions as being instances or subexpressions of lbase sentences or as being posed as theorems to be proved. such usages would go beyond the first-order lbase framework. they amount to a convention for using infinitary logic see hayes& menzel for details. this kind of restricted use of axiom schemes is familiar in many textbook presentations of logic. 2.5 entailment following conventional terminology we say that i satisfies e if i e true and that a set s of expressions entails e if every interpretation which satisfies every member of s also satisfies e. if the set s contains schemes they are understood to stand for the infinite sets of all their instances. entailment is the key idea which connects model-theoretic semantics to real-world applications. as noted earlier making an assertion amounts to claiming that the world is an interpretation which assigns the value true to the assertion. if a entails b then any interpretation that makes a true also makes b true so that an assertion of a already contains the same meaning as an assertion of b we could say that the meaning of b is somehow contained in or subsumed by that of a. if a and b entail each other then they both mean the same thing in the sense that asserting either of them makes the same claim about the world. the interest of this observation arises most vividly when a and b are different expressions since then the relation of entailment is exactly the appropriate semantic licence to justify an application inferring or generating one of them from the other. through the notions of satisfaction entailment and validity formal semantics gives a rigorous definition to a notion of meaning that can be related directly to computable methods of determining whether or not meaning is preserved by some transformation on a representation of knowledge. any process or technique which constructs a well formed formula foutput from some other finput is said to be valid if finput entails foutput otherwise invalid. note that being an invalid process does not mean that the conclusion is false and being valid does not guarantee truth. however validity represents the best guarantee that any assertional language can offer if given true inputs it will never draw a false conclusion from them. 3.0 using lbase to define semantics of a swel imagine we have a semantic web language li. to provide a semantics for li using lbase we must provide a procedure for translating expressions in li to expressions in lbase. this process will also consequently define the subset of lbase that is used by li. a set of vocabulary items introduced by li a set of axioms and or axiom schemas expressed in lbase or lbase schema that capture the intended meanings of the terms in 2 given a set of expressions g in li we apply the procedure above to obtain a set of equivalent well formed formulae in lbase. we then conjoin these with the axioms associated with the vocabulary introduced by li and any other language upon which li is layered if there are associated axiom schemata we appropriately instantiate these and conjoin them to these axioms. the resulting set referred to as a g is an axiomatic equivalent of g. there are several different styles one could adopt for writing axiomatic equivalents. the most conservative amounts to simply transliterating the basic vocabulary of the swel into lbase syntactic form then relying on the axioms to determine their meaning. in cases where the axioms amount to an iff definition of the vocabulary item however this could be shortened by translating the swel vocabulary into the defined form directly resulting in a simpler translation. for example in giving an axiomatic equivalent for owl-dl the meaning of rdfs subclassof can be captured adequately by translating it directly into the form of a logical implication aaa rdfs subclassof bbb translates into forall x aaa x implies bbb x this direct translation removes rdfs subclassof from the the axiomatic equivalent altogether however so makes it impossible to express other rdfs truths about the rdfs subclassof property. this would be acceptable if we were concerned only with owl-dl which imposes a syntactic restriction which forbids such propositions but it is not acceptable when we wish to relate different swels to one another which is the primary goal here. we therefore focus on the conservative style of translation where the burden of expressing the meaning of the swel vocabulary falls largely on the axioms. as an illustrative example we give in the following table a sketch of the axiomatic equivalent for rdf graphs using the rdf s and owl vocabularies in the form of a translation from n-triples. note this should not be referred to as an accurate or normative semantic description. rdf expression e lbase expression tr e a plain literal sss sss with any internal occurrences of prefixed with a plain literal sss ttt the term pair sss ttt a typed literal sss ddd the term literalvalueof sss tr ddd an rdf container membership property name of the form rdf nnn rdf-member nnn any other uri reference aaa aaa or aaa a blank node a variable one distinct variable per blank node a triple aaa rdf type bbb tr bbb tr aaa and rdfs class tr bbb any other triple aaa bbb ccc tr bbb tr aaa tr ccc and rdf property tr bbb an rdf graph the existential closure of the conjunction of the translations of all the triples in the graph. a set of rdf graphs the conjunction of the translations of all the graphs. rdf axioms rdf type x y implies y x rdf property rdf type rdf property rdf subject rdf property rdf predicate rdf property rdf object rdf property rdf first rdf property rdf rest rdf property rdf value rdf list rdf nil natnumber x implies rdf property rdf-member x pair x y pair u v iff x u and y v uniqueness for pairs required by graph syntax rules. rdfs axioms rdfs resource x rdfs class y implies y x iff rdf type x y rdfs range x y implies x u v implies y v rdfs domain x y implies x u v implies y u rdfs subclassof x y implies rdfs class x and rdfs class y and forall u x u implies y u rdfs class x implies rdfs subclassof x x and rdfs subclassof x rdfs resource rdfs subclassof x y and rdfs subclassof y z implies rdfs subclassof x z rdfs subpropertyof x y implies rdf property x and rdf property y and forall u v x u v implies y u v rdf property x implies rdfs subpropertyof x x rdfs subpropertyof x y and rdfs subpropertyof y z implies rdfs subpropertyof x z rdfs containermembershipproperty x implies rdfs subpropertyof x rdfs member rdf xmlliteral x implies rdfs literal x string y implies rdfs literal y string x and languagetag y implies rdfs literal pair x y rdfs datatype x implies x y implies rdfs literal y natnumber x implies rdfs containermembershipproperty rdf-member x and rdfs domain rdf-member x rdfs resource and rdfs range rdf-member x rdfs resource rdfs class rdfs resource rdfs class rdf property rdfs class rdfs class rdfs class rdfs datatype rdfs class rdf seq rdfs class rdf bag rdfs class rdf alt rdfs class rdfs container rdfs class rdf list rdfs class rdfs containermembershipproperty rdfs class rdf statement rdf property rdfs domain rdf property rdfs range rdf property rdfs subclassof rdf property rdfs subpropertyof rdf property rdfs comment rdf property rdfs seealso rdf property rdfs isdefinedby rdf property rdfs label the rest of the axioms are direct transcriptions of the rdfs axiomatic triples using the rdf to lbase transcription rules rdfs domain rdf type rdfs resource rdfs domain rdfs domain rdf property rdfs domain rdfs range rdf property rdfs domain rdfs subpropertyof rdf property rdfs domain rdfs subclassof rdfs class rdfs domain rdf subject rdf statement rdfs domain rdf predicate rdf statement rdfs domain rdf object rdf statement rdfs domain rdf member rdfs resource rdfs domain rdf first rdf list rdfs domain rdf rest rdf list rdfs domain rdfs seealso rdfs resource rdfs domain rdfs isdefinedby rdfs resource rdfs domain rdfs comment rdfs resource rdfs domain rdfs label rdfs resource rdfs domain rdfs value rdfs resource rdfs range rdf type rdfs class rdfs range rdfs domain rdfs class rdfs range rdfs range rdfs class rdfs range rdfs subpropertyof rdf property rdfs range rdfs subclassof rdfs class rdfs range rdf subject rdfs resource rdfs range rdf predicate rdfs resource rdfs range rdf object rdfs resource rdfs range rdf member rdfs resource rdfs range rdf first rdfs resource rdfs range rdf rest rdf list rdfs range rdfs seealso rdfs resource rdfs range rdfs isdefinedby rdfs resource rdfs range rdfs comment rdfs literal rdfs range rdfs label rdfs literal rdfs range rdfs value rdfs resource rdfs subclassof rdf alt rdfs container rdfs subclassof rdf bag rdfs container rdfs subclassof rdf seq rdfs container rdfs subclassof rdfs containermembershipproperty rdf property rdfs subpropertyof rdfs isdefinedby rdfs seealso rdfs datatype rdf xmlliteral rdfs subclassof rdfs datatype rdfs class rdf datatyped literal axioms rdfs literal literalvalueof x y iff y literalvalueof x y rdfs datatype y implies rdfs class y rdfs datatype y implies exists x y x in addition for each datatype named ddd one needs a datatype theory consisting of all axioms of the following form or the equivalent rdfs datatype ddd ddd literalvalueof aaa ddd where aaa is a legal lexical form for the datatype not ddd literalvalueof aaa ddd where aaa is any string which is not a legal lexical form for the datatype. if there is some notational framework in or added to lbase which enables one to write terms denoting the members of the value space of the datatype then the database theory can also contain all true axioms of the form literalvalueof aaa ddd l2v ddd aaa where the square brackets indicate the presence of the appropriate term for that value. for example using decimal numerals to denote the integers this could be all equations of the form literalvalueof 345 xsd integer 345 such axioms or equivalents would be needed in order to connect the translation to other theories which used the more conventional notations. in some cases a datatype theory can be summarized in a finite number of axioms. for example the datatype theory for xsd string can be stated by a single axiom string x iff xsd string x and string x implies literalvalueof x xsd string x 3.1 relation between the two kinds of semantics given a swel li we can provide a semantics for it either by providing it with a model or by mapping it into lbase and utilizing the model theory associated with lbase. given a set of expressions g in li and its axiomatic equivalent in lbase a g any lbase interpretation of a g defines an li interpetation for g. the natural li interpretation from its own model theory will in general be simpler than the lbase interpretation for example interpretations of rdf will not make use of the universal quantification negation or disjunction rules and the underlying structures need have no functional relations. in general therefore the most natural semantics for li will be obtained by simply ignoring some aspects of the lbase interpretation of a g in category-theoretic terms it will be the result of applying an appropriate forgetful functor to the lbase structure. nevertheless this extra structure is harmless since it does not affect entailment in li considered in isolation and it may be useful since it provides a natural way to define consistency across several swels at the same time and to define entailment from kbs which express content in different or even in mixed swels simultaneously. for these reasons we propose to adopt it as a convention that the appropriate notion of satisfaction for any swel expression g is in fact defined relative to an lbase interpretation of a g the following diagram illustrates the relation between li lbase g and interpretations of g according to the different model theories. the important point to note about the above diagram is that if the li to lbase mapping and model theory for li are done consistently then the two routes from g to a satisfying interpretation will be equivalent. this is because the li axioms included in the lbase equivalent of g should be sufficient to guarantee that any satisfying interpretation in the lbase model theory of the lbase equivalent of g will contain a substructure which is a satisfying interpretation of g according to the li model theory and vice versa. the utility of this framework for combining assertions in several different swels is illustrated by the following diagram which is an overlay of two copies of the previous diagram. note that the g1+g2 equivalent in this case contains axioms for both languages ensuring if all is done properly that any lbase interpretation will contain appropriate substructures for both sentences. if the translations into lbase are appropriately defined at a sufficient level of detail then even tighter semantic integration could be achieved where expressions which mix vocabulary from several swels could be given a coherent interpretation which satisfies the semantic conditions of both languages. this will be possible only when the swels have a particularly close relationship however. in the particular case where one swel the one used by g2 is layered on top of another the one used by g1 the interpretations of g2 will be a subset of those of g1 4.0 inadequacies of lbase the lbase described above has several deficiencies as a base system for the semantic web. in particular it does not capture the social meaning of uris. it merely treats them as opaque symbols. a future web logic should go further towards capturing this intention. at the moment lbase does not provide any facilities related to the representation of time and change. however many existing techniques for temporal representation use languages similar to lbase in expressive power and we are optimistic that lbase can provide a useful framework in which to experiment with temporal ontologies for web use. it might turn out that some aspects of what we want to represent on the the semantic web requires more than can be expressed using the lbase described in this document. in particular lbase does not provide a mechanism for expressing propositional attitudes or true second order constructs. a future version of lbase which includes the above lbase as a proper subset might have to include such facilities. 5.0 acknowledgements we would like to thank members of the rdf core working group tim berners-lee richard fikes sandro hawke jim hendler and peter patel-schneider for comments on various versions of this document. 6.0 references enderton a mathematical introduction to logic h.b.enderton 2nd edition 2001 harcourt academic press. fikes mcguinness r. fikes d. l. mcguinness an axiomatic semantics for rdf rdf schema and daml+oil ksl technical report ksl-01-01 2001 hayes menzel p. hayes c. menzel a semantics for the knowledge interchange format 6 august 2001 proceedings of 2001 workshop on the ieee standard upper ontology owl web ontology language owl reference version 1.0 mike dean dan connolly frank van harmelen james hendler ian horrocks deborah l. mcguinness peter f. patel-schneider and lynn andrea stein. w3c working draft 12 november 2002. this version is http www.w3.org tr 2002 wd-owl-ref-20021112 latest version is available at http www.w3.org tr owl-ref marchiori saarela m. marchioi j. saarela query metadata logic metalog 1998 rdf-concepts resource description framework rdf concepts and abstract syntax klyne g. carroll j. editors world wide web consortium working draft 10 october 2003 work in progress this version is http www.w3.org tr 2003 wd-rdf-concepts-20031010 the latest version is http www.w3.org tr rdf-concepts rdf-syntax rdf xml syntax specification revised beckett d. editor world wide web consortium working draft 10 october 2003 work in progress this version is http www.w3.org tr 2003 wd-rdf-syntax-grammar-20031010 the latest version is http www.w3.org tr rdf-syntax-grammar rdf-semantics rdf semantics hayes p. editor world wide web consortium working draft 10 october 2003 work in progress this version is http www.w3.org tr 2003 wd-rdf-mt-20031010 the latest version is http www.w3.org tr rdf-mt rdf-tests rdf test cases grant j. beckett d. editors world wide web consortium working draft 5 september 2003 work in progress this version is http www.w3.org tr 2003 wd-rdf-testcases-20031010 the latest version is http www.w3.org tr rdf-testcases rdfms resource description framework rdf model and syntax w3c recommendation 22 february 1999 http www.w3.org tr 1999 rec-rdf-syntax-19990222 rdf-primer rdf primer manola f. miller e. editors world wide web consortium working draft 5 september 2003 work in progress this version is http www.w3.org tr 2003 wd-rdf-primer-20031010 the latest version is http www.w3.org tr rdf-primer rdf-vocabulary rdf vocabulary description language 1.0 rdf schema brickley d. guha r.v. editors world wide web consortium november 2002. consortium working draft 10 october 2003 work in progress this version is http www.w3.org tr 2003 wd-rdf-schema-20031010 the latest version is http www.w3.org tr rdf-schema uri t. berners-lee fielding and masinter rfc 2396 uniform resource identifiers uri generic syntax august 1998. webont the web ontology working group xml t. bray j. paoli c.m. sperberg.mcqueen e. maler. extensible markup language xml 1.0 second edition w3c recommendation 6 october 2000 7. change log since the version of 23 january the definition of quoted strings has been modified to simplify character escaping the syntax allowing names to be enclosed in introduced and the xmlthing category of special names deleted it was underspecifed and not necessary. several minor editorial changes have been made throughout the document heading numbers corrected etc. the example translation of rdf rdfs has been updated so as to conform to the description given in the rdf semantics document and the discussion of axiomatic equivalents expanded. thanks to peter patel-schneider for critical comments on the earlier version. 