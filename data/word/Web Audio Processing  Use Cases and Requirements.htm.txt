web audio processing use cases and requirements web audio processing use cases and requirements w3c working group note 29 january 2013 this version http www.w3.org tr 2013 note-webaudio-usecases-20130129 latest published version http www.w3.org tr webaudio-usecases previous version http www.w3.org tr 2012 wd-webaudio-usecases-20121004 latest editor s draft https dvcs.w3.org hg audio raw-file tip reqs overview.html editors joe berkovitz noteflight olivier thereaux british broadcasting corporation bbc copyright 2013 w3c mit ercim keio all rights reserved. w3c liability trademark and document use rules apply. abstract this document introduces a series of scenarios and a list of requirements guiding the work of the w3c audio working group in its development of a web api for processing and synthesis of audio on the web. status of this document this section describes the status of this document at the time of its publication. other documents may supersede this document. a list of current w3c publications and the latest revision of this technical report can be found in the w3c technical reports index at http www.w3.org tr this document was published by the audio working group as a working group note. if you wish to make comments regarding this document please send them to public-audio@w3.org subscribe archives all comments are welcome. publication as a working group note does not imply endorsement by the w3c membership. this is a draft document and may be updated replaced or obsoleted by other documents at any time. it is inappropriate to cite this document as other than work in progress. this document was produced by a group operating under the 5 february 2004 w3c patent policy. w3c maintains a public list of any patent disclosures made in connection with the deliverables of the group that page also includes instructions for disclosing a patent. an individual who has actual knowledge of a patent which the individual believes contains essential claim s must disclose the information in accordance with section 6 of the w3c patent policy. table of contents 1. introduction 2. web audio scenarios 2.1 video chat application 2.2 3d game with music and convincing sound effects 2.3 online music production tool 2.4 online radio broadcast 2.5 music creation environment with sampled instruments 2.6 connected dj booth 2.7 playful sonification of user interfaces 2.8 podcast on a flight 2.9 short film with director s commentary and audio description 2.10 web-based guitar practice service 2.11 user control of audio a. acknowledgements 1. introduction what should the future web sound like that was in essence the mission of the w3c audio working group when it was chartered in early 2011 to support the features required by advanced interactive applications including the ability to process and synthesize audio bringing audio processing and synthesis capabilities to the open web platform should allow developers to re-create well-loved audio software on the open web and add great sound to web games and applications it may also enable web developers to reinvent the world of audio and music by making it more connected linked and social. this document attempts to describe the scenarios considered by the w3c audio working group in its work to define web audio technologies. not intended to be a comprehensive list of things which the web audio standards will make possible it nevertheless attempts to document a number of key applications of audio which web audio standards should enable provide a basis for discussion on the desired architecture of web audio standards offer examples for early uses of the technology which can then be used to gather feedback on the draft standard and extract technical and architectural requirements for the web audio apis or libraries built upon it. the notes and implementation considerations sections will note which constructs of the web audio api working draft apply. whenever possible the document will note which features are yet to be implemented or documented in that specification as of 02 august 2012. 2. web audio scenarios this section will introduce a number of scenarios involving the use of web audio processing or synthesis technologies and discuss implementation and architectural considerations. 2.1 video chat application three people have joined a three-way conversation through a web application. each of them see the other two participants in split windows and hear their voice in sync with the video. the application provides a simple interface to control the incoming audio and video of the other participants at any time the user can mute the incoming streams control the overall sound volume or mute themselves while continuing to send a live video stream through the application. advanced controls are also available. in the audio option panel the user has the ability to adapt the incoming sound to their taste through a graphic equalizer interface as well as a number of filters for voice enhancement a feature which can be useful between people with hearing difficulties in imperfect listening environments or to compensate for poor transmission environments. another option allows the user to change the spatialization of the voices of their interlocutors the default is a binaural mix matching the disposition of split-windows on the screen but the interface makes it possible to reverse the left-right balance or make the other participants appear closer or further apart. the makers of the chat applications also offer a fun version which allows users to distort pitch speed other effects their voice. they are considering adding the option to the default software as such a feature could also be used to protect one participants privacy in some contexts. notes and implementation considerations the processing capabilities needed by this scenario include mixing and spatialization of several sound sources controlling the gain mute and volume control of several audio sources filtering eq voice enhancement modifying the pitch and speed of sound sources this scenario is also a good example of the need for audio capture from line in internal microphone or other inputs we expect this to be provided by html media capture. the first scenario in webrtc s use cases and requirements document has been a strong inspiration for this scenario. most of the technology described above should be covered by the web real-time communication api. the scenario illustrates however the need to integrate audio processing with the handling of rtc streams with a technical requirement for processing of the audio signal at both ends capture of the user s voice and output of its correspondents conversation speed changes are currently unsupported by the web audio api. 2.2 3d game with music and convincing sound effects a commuter is playing a 3d first-person adventure game on their mobile device. the game is built entirely using open web technologies and includes rich convincing sound piped through the commuter s stereo headphones. as soon as the game starts a musical background starts loops seamlessly and transitions smoothly from one music track to another as the player enters a house. some of the music is generated live and reacts to the state of the game tempo time signature note properties and envelopes change depending on the the health level of the characters and their actions. while walking in a corridor the player can hear the muffled sound of a ticking grandfather s clock. following the direction of the sound and entering a large hall the sound of the clock becomes clear reverberating in the large hall. at any time the sound of the clock spatialized in real-time based on the position of the player s character in the room relative to the clock and the current camera angle. the soundscape changes bringing a more somber scary atmosphere to the scene the once full orchestral underscore is slowly reduced instrument by instrument to a lonely and echoing cello. the player equips a firearm. suddenly a giant snake springs from behind a corner its hissing becoming a little louder as the snake turns its head towards the player. the weapon fires at the touch of a key and the player can hear the sound of bullets in near-perfect synchronization with the firing as well as the sound of bullets ricocheting against walls. the sounds are played immediately after the player presses the key but the action and video frame rate can remain smooth even when a lot of sounds bullets being fired echoing and ricocheting sound of the impacts etc are played at the same time. the snake is now dead and many flies gather around it and around the player s character buzzing and zooming in the virtual space of the room. notes and implementation considerations developing the soundscape for a game as the one described above can benefit from a modular node based approach to audio processing. in our scenario some of the processing needs to happen for a number of sources at the same time e.g room effects while others e.g mixing and spatialization need to happen on a per-source basis. a graph-based api makes it very easy to envision construct and control the necessary processing architecture in ways that would be possible with other kinds of apis but more difficult to implement. the fundamental audionode construct in the web audio api supports this approach. while a single looping music background can be created today with the html5 audio element the ability to transition smoothly from one musical background to another requires additional capabilities that are found in the web audio api including sample-accurate playback scheduling and automated cross-fading of multiple sources. related api features include audiobuffersourcenode.start and audioparam.setvalueattime the musical background of the game not only involves seamless looping and transitioning of full tracks but also the automated creation of generative music from basic building blocks or algorithms some of the music is generated live and reacts to the state of the game as well as the creation and evolution of a musical score from multiple instrument tracks the once full orchestral underscore is slowly reduced instrument by instrument related requirements for such features are developed in details within the online music production tool and music creation environment with sampled instruments scenarios. the scenario illustrates many aspects of the creation of a credible soundscape. the game character is evolving in a virtual three-dimensional environment and the soundscape is at all times spatialized a panning model can be used to spatialize sound sources in the game audiopanningnode obstruction occlusion modeling is used to muffle the sound of the clock going through walls and the sound of flies buzzing around would need doppler shift simulation to sound believable also supported by audiopanningnode the listener s position is part of this 3d model as well audiolistener as the soundscape changes from small room to large hall the game benefits from the simulation of acoustic spaces possibly through the use of a convolution engine for high quality room effects as supported by convolvernode in the web audio api. many sounds in the scenario are triggered by events in the game and would need to be played with low latency. the sound of the bullets as they are fired and ricochet against the walls in particular illustrate a requirement for basic polyphony and high-performance playback and processing of many sounds. these are supported by the general ability of the web audio api to include many sound-generating nodes with independent scheduling and high-throughput native algorithms. 2.3 online music production tool a music enthusiast creates a musical composition from audio media clips using a web-based digital audio workstation daw application. audio clips are arranged on a timeline representing multiple tracks of audio. each track s volume panning and effects may be controlled separately. individual tracks may be muted or soloed to preview various combination of tracks at a given moment. audio effects may be applied per-track as inline insert effects. additionally each track can send its signal to one or more global send effects which are shared across tracks. sub-mixes of various combinations of tracks can be made and a final mix bus controls the overall volume of the mix and may have additional insert effects. insert and send effects include dynamics compressors including multi-band extremely high-quality reverberation filters such as parametric low-shelf high-shelf graphic eq etc. also included are various kinds of delay effects such as ping-pong delays and bpm-synchronized delays with feedback. various kinds of time-modulated effects are available such as chorus phasor resonant filter sweeps and bpm-synchronized panners. distortion effects include subtle tube simulators and aggressive bit decimators. each effect has its own ui for adjusting its parameters. real-time changes to the parameters can be made e.g. with a mouse and the audible results heard with no perceptible lag. audio clips may be arranged on the timeline with a high-degree of precision with sample accurate playback certain clips may be repeated loops containing beat-based musical material and are synchronized with other such looped clips according to a certain musical tempo. these in turn can be synchronized with sequences controlling real-time synthesized playback. the values of volume panning send levels and each parameter of each effect can be changed over time displayed and controlled through a powerful ui dealing with automation curves. these curves may be arbitrary and can be used for example to control volume fade-ins filter sweeps and may be synchronized in time with the music beat synchronized visualizers may be applied for technical uow.acc.tab.analysis of the signal. these visualizers can be as simple as displaying the signal level in a vu meter or more complex such as real-time frequency uow.acc.tab.analysis or l r phase displays. the actual audio clips to be arranged on the timeline are managed in a library of available clips. these can be searched and sorted in a variety of ways and with high-efficiency. although the clips can be cloud-based local caching offers nearly instantaneous access and glitch-free playback. the final mix may be rendered at faster than real-time and then uploaded and shared with others. the session representing the clips timeline effects automation etc. may also be shared with others for shared-mixing collaboration. notes and implementation considerations this scenario details the large number of feature requirements typically expected of professional audio software or hardware. it encompasses many advanced audio control capabilities such as filtering effects dynamics compression and control of various audio parameters. building such an application may only be reasonably possible if the technology enables the control of audio with acceptable performance in particular for real-time processing and control of audio parameters and sample accurate scheduling of sound playback. because performance is such a key aspect of this scenario it should probably be possible to control the buffer size of the underlying audio api this would allow users with slower machines to pick a larger buffer setting that does not cause clicks and pops in the audio stream. the ability to visualize the samples and their processing benefits from real-time time-domain and frequency uow.acc.tab.analysis as supplied by the web audio api s realtimeanalyzernode. clips must be able to be loaded into memory for fast playback. the web audio api s audiobuffer and audiobuffersourcenode interfaces address this requirement. some sound sources may be purely algorithmic in nature such as oscillators or noise generators. this implies the ability to generate sound from both precomputed and dynamically computed arbitrary sound samples. the web audio api s ability to create an audiobuffer from arrays of numerical samples coupled with the ability of javascriptaudionode to supply numerical samples on the fly both address this requirement. the ability to schedule both audio clip playback and effects parameter value changes in advance is essential to support automated mixdown to export an audio file the audio rendering pipeline must be able to yield buffers of sample frames directly rather than being forced to an audio device destination. built-in codecs to translate these buffers to standard audio file output formats are also desirable. typical per-channel effects such as panning gain control compression and filtering must be readily available in a native high-performance implementation. typical master bus effects such as room reverb must be readily available. such effects are applied to the entire mix as a final processing stage. a single convolvernode is capable of simulating a wide range of room acoustics. 2.4 online radio broadcast a web-based online radio application supports one-to-many audio broadcasting on various channels. for any one broadcast channel it exposes three separate user interfaces on different pages. one interface is used by the broadcaster controlling a radio show on the channel. a second interface allows invited guests to supply live audio to the show. the third interface is for the live online audience listening to the channel. the broadcaster interface supports live and recorded audio source selection as well as mixing of those sources. audio sources include any local microphone prerecorded audio such as jingles or tracks from music libraries a remote microphone for a remote guest a simple mixer lets the broadcaster control the volume pan and effects processing for each local or remote audio source blending them into a single stereo output mix that is broadcast as the show s content. indicators track the level of each active source. this mixer also incorporates some automatic features to make the broadcaster s life easier including ducking of prerecorded audio sources when any local or remote microphone source is active. muting un-muting of sources causes an automatic fast volume fade-out in to avoid audio transients. the broadcaster can hear a live monitor mix through headphones with an adjustable level for monitoring their local microphone. the application is aware of when prerecorded audio is playing in the mix and each audio track s descriptive metadata is shown to the audience in synchronization with what they are hearing. the guest interface supports a single live audio source from a choice of any local microphone. the audience interface delivers the channel s broadcast mix but also offers basic volume and eq control plus the ability to pause rewind resume the live stream. optionally the listener can slow down the content of the audio without changing its pitch for example to aid in understanding a foreign language. an advanced feature would give the audience control over the mix itself. the mix of tracks and sources created by the broadcaster would be a default but the listener would have the ability to create a different mix. for instance in the case of a radio play with a mix of voices sound effects and music the listener could be offered an interface to control the relative volume of the voices to effects and music or create a binaural mix tailored specifically to their taste. such a feature would provide valuable personalization of the radio experience as well as significant accessibility enhancements. notes and implementation considerations as with the video chat application scenario streaming and local device discovery and access within this scenario are handled by the web real-time communication api. the local audio processing in this scenario highlights the requirement that rtc streams and web audio be tightly integrated. incoming mediastreams must be able to be exposed as audio sources and audio destinations must be able to yield an outgoing rtc stream. for example the broadcaster s browser employs a set of incoming mediastreams from microphones remote participants etc. locally processes their audio through a graph of audionodes and directs the output to an outgoing mediastream representing the live mix for the show. building this application requires the application of gain control panning audio effects and blending of multiple mono and stereo audio sources to yield a stereo mix. some relevant features in the api include audiogainnode convolvernode audiopannernode. noise gating suppressing output when a source s level falls below some minimum threshold is highly desirable for microphone inputs to avoid stray room noise being included in the broadcast mix. this could be implemented as a custom algorithm using a javascriptaudionode. to drive the visual feedback to the broadcaster on audio source activity and to control automatic ducking this scenario needs a way to easily detect the time-averaged signal level on a given audio source. the web audio api does not currently provide a prepackaged way to do this but it can be implemented with custom js processing or an ultra-low-pass filter built with biquadfilternode. ducking affects the level of multiple audio sources at once which implies the ability to associate a single dynamic audio parameter to the gain associated with these sources signal paths. the specification s audiogain interface provides this. smooth muting requires the ability to smoothly automate gain changes over a time interval without using browser-unfriendly coding techniques like tight loops or high-frequency callbacks. the parameter automation features associated with audioparam are useful for this kind of feature. pausing and resuming the show on the audience side implies the ability to buffer data received from audio sources in the processing graph and also to send buffered data to audio destinations. speed changes are currently unsupported by the web audio api. thus the functionality for audio speed changing a custom algorithm requires the ability to create custom audio transformations using a browser programming language e.g. javascriptaudionode when audio delivery is slowed down audio samples will have to be locally buffered by the application up to some allowed limit since they continue to be delivered by the incoming stream at a normal rate. there is a standard way to access a set of metadata properties for media resources with the following w3c documents ontology for media resources 1.0. this document defines a core set of metadata properties for media resources along with their mappings to elements from a set of existing metadata formats. api for media resources 1.0. this api provides developers with a convenient access to metadata information stored in different metadata formats. it provides means to access the set of metadata properties defined in the ontology for media resources 1.0 specification. the ability for the listeners to create their own mix rely on the possibility of sending multiple tracks in the rtc stream. this is in scope of the current webrtc specification where one mediastream can have multiple mediastreamtracks. 2.5 music creation environment with sampled instruments a composer is employing a web-based application to create and edit a musical composition with live synthesized playback. the user interface for composing can take a number of forms including conventional western notation and a piano-roll style display. the document can be sonically rendered on demand as a piece of music i.e. a series of precisely timed pitched and modulated audio events notes the musician occasionally stops editing and wishes to hear playback of some or all of the score they are working on to take stock of their work. at this point the program performs sequenced playback of some portion of the document. some simple effects such as instrument panning and room reverb are also applied for a more realistic and satisfying effect. compositions in this editor employ a set of instrument samples i.e. a pre-existing library of recorded audio snippets. any given snippet is a brief audio recording of a note played on an instrument with some specific and known combination of pitch dynamics and articulation. the combinations in the library are necessarily limited in number to avoid bandwidth and storage overhead. during playback the editor must simulate the sound of each instrument playing its part in the composition. this is done by transforming the available pre-recorded samples from their original pitch duration and volume to match the characteristics prescribed by each note in the composed music. these per-note transformations must also be scheduled to be played at the times prescribed by the composition. during playback a moving cursor indicates the exact point in the music that is being heard at each moment. at some point the user exports an mp3 or wav file from the program for some other purpose. this file contains the same audio rendition of the score that is played interactively when the user requested it earlier. notes and implementation considerations instrument samples must be able to be loaded into memory for fast processing during music rendering. these pre-loaded audio snippets must have a one-to-many relationship with objects in the web audio api representing specific notes to avoid duplicating the same sample in memory for each note in a composition that is rendered with it. the api s audiobuffer and audiobuffersourcenode interfaces address this requirement. it must be possible to schedule large numbers of individual events over a long period of time each of which is a transformation of some original audio sample without degrading real-time browser performance. a graph-based approach such as that in the web audio api makes the construction of any given transformation practical by supporting simple recipes for creating sub-graphs built around a sample s pre-loaded audiobuffer. these subgraphs can be constructed and scheduled to be played in the future. in one approach to supporting longer compositions the construction and scheduling of future events can be kept topped up via periodic timer callbacks to avoid the overhead of creating huge graphs all at once. a given sample must be able to be arbitrarily transformed in pitch and volume to match a note in the music. audiobuffersourcenode s playbackrate attribute provides the pitch-change capability while audiogainnode allows the volume to be adjusted. a given sample must be able to be arbitrarily transformed in duration without changing its pitch to match a note in the music. audiobuffersourcenode s looping parameters provide sample-accurate start and end loop points allowing a note of arbitrary duration to be generated even though the original recording may be brief. looped samples by definition do not have a clean ending. to avoid an abrupt glitchy cutoff at the end of a note a gain and or filter envelope must be applied. such envelopes normally follow an exponential trajectory during key time intervals in the life cycle of a note. the audioparam features of the web audio api in conjunction with audiogainnode and biquadfilternode support this requirement. it is necessary to coordinate visual display with sequenced playback of the document such as a moving cursor or highlighting effect applied to notes. this implies the need to programmatically determine the exact time offset within the performance of the sound being currently rendered through the computer s audio output channel. this time offset must in turn have a well-defined relationship to time offsets in prior api requests to schedule various notes at various times. the api provides such a capability in the audiocontext.currenttime attribute. to export an audio file the audio rendering pipeline must be able to yield buffers of sample frames directly rather than being forced to an audio device destination. built-in codecs to translate these buffers to standard audio file output formats are also desirable. typical per-channel effects such as stereo pan control must be readily available. panning allows the sound output for each instrument channel to appear to occupy a different spatial location in the output mix adding greatly to the realism of the playback. adding and configuring one of the web audio api s audiopannernode for each channel output path provides this capability. typical master bus effects such as room reverb must be readily available. such effects are applied to the entire mix as a final processing stage. a single convolvernode is capable of simulating a wide range of room acoustics. 2.6 connected dj booth a popular dj is playing a live set using a popular web-based dj software. the web application allows her to perform both in the club where she is mixing as well as online with tens of thousands joining live to enjoy the set. the dj-deck web interface offers the typical features of decks and turntables. while a first track is playing and its sound sent to both the sound system in the club and streamed to the web browsers of fans around the world the dj would be able to quickly select several other track play them through headphones without affecting the main audio output of the application and match them to the track currently playing through a mix of pausing skipping forward or back and pitch speed change. the application helps automate a lot of this work by measuring the beat of the current track at 125bpm and the one of the chosen next track at 140 bpm it can automatically slow down the second track and even position it to match the beats of the one currently playing. once the correct match is reached the dj would be able to start playing the track in the main audio output either immediately or by slowly changing the volume controls for each track. she uses a cross fader to let the new song blend into the old one and eventually goes completely across so only the new song is playing. this gives the illusion that the song never ended. at the other end fans listening to the set would be able to watch a video of the dj mixing accompanied by a graphic visualization of the music picked from a variety of choices spectrum uow.acc.tab.analysis level-meter view or a number of 2d or 3d abstract visualizations displayed either next to or overlaid on the dj video. notes and implementation considerations as in many other scenarios in this document it is expected that apis such as the web real-time communication api will be used for the streaming of audio and video across a number of clients. one of the specific requirements illustrated by this scenario is the ability to have two different outputs for the sound one for the headphones and one for the music stream sent to all the clients. with the typical web-friendly hardware this would be difficult or impossible to implement by considering both as audio destinations since they seldom have or allow two sound outputs to be used at the same time. and indeed in the current web audio api draft a given audiocontext can only use one audiodestinationnode as destination. however if we consider that the headphones are the audio output and that the streaming dj set is not a typical audio destination but an outgoing mediastream passed on to the webrtc api it should be possible to implement this scenario sending output to both headphones and the stream and gradually sending sound from one to the other without affecting the exact state of playback and processing of a source. with the web audio api this can be achieved by using the createmediastreamdestination interface. this scenario makes heavy usage of audio uow.acc.tab.analysis capabilities both for automation purposes beat detection and beat matching and visualization spectrum level and other abstract visualization modes the requirement for pitch speed change are not currently covered by the web audio api s native processing nodes. such processing would probably have to be handled with custom processing nodes. 2.7 playful sonification of user interfaces a child is visiting a social website designed for kids. the playful colorful html interface is accompanied by sound effects played as the child hovers or clicks on some of the elements of the page. for example when filling in a form the sound of a typewriter can be heard as the child types in the form field. some of the sounds are spatialized and have a different volume depending on where and how the child interacts with the page. when an action triggers a download visualized with a progress bar a gradually rising pitch sound accompanies the download and another sound ping is played when the download is complete. notes and implementation considerations although the web ui incorporates many sound effects its controls are embedded in the site s pages using standard web technology such as html form elements and css stylesheets. javascript event handlers may be attached to these elements causing graphs of audionodes to be constructed and activated to produce sound output. modularity spatialization and mixing play an important role in this scenario as for the others in this document. various effects can be achieved through programmatic variation of these sounds using the web audio api. the download progress could smoothly vary the pitch of an audiobuffersourcenode s playbackrate using an exponential ramp function or a more realistic typewriter sound could be achieved by varying an output filter s frequency based on the keypress s character code. in a future version of css stylesheets may be able to support simple types of sonification such as attaching a typewriter key sound to an html textarea element or a click sound to an html button. these can be thought of as an extension of the visual skinning concepts already embodied by style attributes such as background-image. 2.8 podcast on a flight a traveler is subscribed to a podcast and has previously downloaded an audio book on his device using the podcast s web-based application. the audio files are stored locally on his device giving simple and convenient access to episodic content whenever the user wishes to listen. sitting in an airplane for a 2-hour flight he opens the podcast application in his html browser and sees that the episode he has selected lasts 3 hours. the application offers a speed-up feature that allows the speech to be delivered at a faster than normal speed without pitch distortion chipmunk voices he sets the audition time to 2 hours in order to finish the audio book before landing. he also sets the sound control in the application to noisy environment causing the sound to be equalized for greatest intelligibility in a noisy setting such as an airplane. notes and implementation considerations local audio can be downloaded stored and retrieved using the html file api. this scenario requires a special audio transformation that can compress the duration of speech without affecting overall timbre and intelligibility. in the web audio api this function isn t natively supported but could be accomplished through attaching custom processing code to a javascriptaudionode. the noisy environment setting could be accomplished through equalization features in the web audio api such as biquadfilternode or convolvernode. 2.9 short film with director s commentary and audio description a video editor is using an online editing tool to refine the soundtrack of a short film. once the video is ready she will work with the production team to prepare an audio description of the scenes to make the video work more accessible to people with sight impairments. the video director is also planning to add an audio commentary track to explain the creative process behind the film. using the online tool the video editor extracts the existing recorded vocals from the video stream modifies their levels and performs other modifications of the audio stream. she also adds several songs including a orchestral background and pop songs at different parts of the film soundtrack. several foley effects footsteps doors opening and closing etc. are also added to make the soundscape of each scene complete. while editing the online tool must ensure that the audio and video playback are synchronized allowing the editor to insert audio samples at the right time. as the length of one of the songs is slightly different from the video segment she is matching it with she can synchronize the two by slightly speeding up or slowing down the audio track. the final soundtrack is mixed down into the final soundtrack added to the video as a replacement for the original audio track and synced with the video track. once the audio description and commentary are recorded the film displayed in a html web page can be played with its original audio track embedded in the video container or with any of the audio commentary tracks loaded from a different source and synchronized with the video playback. when there s audio on the commentary track the main track volume is reduced ducked gradually and smoothly brought back to full volume when the commentary description track is silent. the visitor can switch between audio tracks on the fly without affecting the video playback. pausing the video playback also pauses the commentary track which then remains in sync when playback resumes. notes and implementation considerations this scenario is in many ways fairly similar to a number of others already discussed throughout the document. the ability to lay out a number of sources and mix them in a consistent soundtrack is the subject of the online music production tool scenario while some effects such as ducking have already been discussed in the online radio broadcast scenario. essentially this use case illustrates the need to do all these things in sync with video. in the context of the open web platform it means that audio processing api to integrate with the html5 mediacontroller interface. 2.10 web-based guitar practice service a serious guitar player uses a web-based tool to practice a new tune. connecting a usb microphone and a pair of headphones to their computer the guitarist is able to tune an acoustic guitar using a graphical interface and set a metronome for the practice session. a mix of one or more backing tracks can be optionally selected for the guitarist to play along with with or without the metronome present. during a practice session the microphone audio is analyzed to determine whether the guitarist is playing the correct notes in tempo and visual feedback is provided via a graphical interface of guitar tablature sheet music with superimposed highlighting. the guitarist s performance during each session is recorded optionally mixed with the audio backing-track mix. at the conclusion of a session this performance can be saved to various file formats or uploaded to an online social music service for sharing and commentary with other users. notes and implementation considerations the audio input reflects the guitarist s performance which is itself aurally synchronized by the guitarist to the current audio output. the scenario requires that the input be analyzed for correct rhythmic and pitch content. such an algorithm can be implemented in a javascriptaudionode. analysis of the performance in turn requires measurement of the real-time latency in both audio input and output so that the algorithm analyzing the live performance can know the temporal relationship of a given output sample reflecting the metronome and or backing track to a given input sample reflecting the guitarist playing along with that output these latencies are unpredictable from one system to another and cannot be hard-coded. currently the web audio api lacks such support. this scenario uses a mixture of sound sources including a live microphone input a synthesized metronome and a set of pre-recorded audio backing tracks which are synced to a fixed tempo the mixing of these sources to the browser s audio output can be accomplished by a combination of instances of audiogainnode and audiopannernode. the live input requires microphone access which it is anticipated will be available via html media capture bridged through an audionode interface. pre-recorded backing tracks can be loaded into audiobuffers and used as sample-accurate synced sources by wrapping these in audiobuffersourcenode instances. metronome synthesis can be accomplished with a variety of means provided by the web audio api. in one approach an implementer could use an oscillator square-wave source to generate the metronome sound. a timer callback repeatedly runs at a low frequency to maintain a pool of these instances scheduled to occur on future beats in the music which can be sample-accurately synced to offsets in the backing tracks given the lock-step timing in the web audio api programmatic output of a recorded session s audio buffer must be accomplished to files via the html5 file api or upload streams via mediastreams or http the scenario implies the use of one or more encoders on this buffered data to yield the supported audio file formats. native audio-to-file encoding is not currently supported by the web audio api and thus would need to be implemented in javascript. 2.11 user control of audio a programmer wants to create a browser extension to allow the user to control the volume of audio. the extension should let the user control the audio volume on a per-tab basis or to kill any audio playing completely. the extension developer wishes to make sure killing the audio is done in a way that takes care of garbage collection. among the features sometimes requested for his extension are the ability to limit the audio volume to an acceptable level both per tab and globally. on operating systems that allow it the developer would also like his extension to mute or pause sound when a critical system sound is being played. notes and implementation considerations this function is likely to combine usage of both a browser-specific extension api and the web audio api. one way to implement this scenario would be to use a browser-dependent api to iterate through a list of window objects and then for each window object iterate through a list of active audiocontexts and manage their volume or more conveniently manage some kind of master audio volume for the window neither of these latter approaches are currently supported by the web audio api. the ability to mute or pause sounds when the operating system fires a critical system sound is modelled after the feature in existing operating systems which will automatically mute applications when outputting a system sound. as such this may not involve any specific requirement for the web audio api. however because some operating systems may implement such a feature web audio apps may want to be notified of the muting and act accordingly suspend pause etc there may therefore be a requirement for the web audio api to provide such an event handler. a. acknowledgements this document is the result of the work of the w3c audio working group. members of the working group at the time of publication included bateman adrian microsoft corporation berkovitz joe invited expert cardoso gabriel inria carlson eric apple inc. chen bin baidu inc. geelnard marcus opera software goode adam google inc. gregan matthew mozilla foundation j genstedt philip opera software kalliokoski jussi invited expert lowis chris british broadcasting corporation macdonald alistair invited expert mandyam giridhar qualcomm innovation center inc michel thierry w3c ercim noble jer apple inc. o callahan robert mozilla foundation olivier frank microsoft corporation paradis matthew british broadcasting corporation peraza barreras jorge armando microsoft corporation raman t.v. google inc. rogers chris google inc. schepers doug w3c mit shires glen google inc. smith michael w3c keio thereaux olivier british broadcasting corporation wei james intel corporation wilson chris google inc. young milan nuance communications inc. the people who have contributed to discussions on public-audio@w3.org are also gratefully acknowledged. this document was also heavily influenced by earlier work by the audio working group and others including a list of core use cases authored by the w3c audio incubator group which predated the w3c audio working group the use cases requirements from web rtc the scenarios from the media streams processing 